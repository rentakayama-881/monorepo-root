// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend-gin/ent/backupcode"
	"backend-gin/ent/badge"
	"backend-gin/ent/credential"
	"backend-gin/ent/devicefingerprint"
	"backend-gin/ent/deviceusermapping"
	"backend-gin/ent/emailverificationtoken"
	"backend-gin/ent/passkey"
	"backend-gin/ent/passwordresettoken"
	"backend-gin/ent/predicate"
	"backend-gin/ent/securityevent"
	"backend-gin/ent/session"
	"backend-gin/ent/sessionlock"
	"backend-gin/ent/sudosession"
	"backend-gin/ent/thread"
	"backend-gin/ent/totppendingtoken"
	"backend-gin/ent/user"
	"backend-gin/ent/userbadge"
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// UserUpdate is the builder for updating User entities.
type UserUpdate struct {
	config
	hooks    []Hook
	mutation *UserMutation
}

// Where appends a list predicates to the UserUpdate builder.
func (_u *UserUpdate) Where(ps ...predicate.User) *UserUpdate {
	_u.mutation.Where(ps...)
	return _u
}

// SetUpdatedAt sets the "updated_at" field.
func (_u *UserUpdate) SetUpdatedAt(v time.Time) *UserUpdate {
	_u.mutation.SetUpdatedAt(v)
	return _u
}

// SetDeletedAt sets the "deleted_at" field.
func (_u *UserUpdate) SetDeletedAt(v time.Time) *UserUpdate {
	_u.mutation.SetDeletedAt(v)
	return _u
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (_u *UserUpdate) SetNillableDeletedAt(v *time.Time) *UserUpdate {
	if v != nil {
		_u.SetDeletedAt(*v)
	}
	return _u
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (_u *UserUpdate) ClearDeletedAt() *UserUpdate {
	_u.mutation.ClearDeletedAt()
	return _u
}

// SetEmail sets the "email" field.
func (_u *UserUpdate) SetEmail(v string) *UserUpdate {
	_u.mutation.SetEmail(v)
	return _u
}

// SetNillableEmail sets the "email" field if the given value is not nil.
func (_u *UserUpdate) SetNillableEmail(v *string) *UserUpdate {
	if v != nil {
		_u.SetEmail(*v)
	}
	return _u
}

// SetUsername sets the "username" field.
func (_u *UserUpdate) SetUsername(v string) *UserUpdate {
	_u.mutation.SetUsername(v)
	return _u
}

// SetNillableUsername sets the "username" field if the given value is not nil.
func (_u *UserUpdate) SetNillableUsername(v *string) *UserUpdate {
	if v != nil {
		_u.SetUsername(*v)
	}
	return _u
}

// ClearUsername clears the value of the "username" field.
func (_u *UserUpdate) ClearUsername() *UserUpdate {
	_u.mutation.ClearUsername()
	return _u
}

// SetPasswordHash sets the "password_hash" field.
func (_u *UserUpdate) SetPasswordHash(v string) *UserUpdate {
	_u.mutation.SetPasswordHash(v)
	return _u
}

// SetNillablePasswordHash sets the "password_hash" field if the given value is not nil.
func (_u *UserUpdate) SetNillablePasswordHash(v *string) *UserUpdate {
	if v != nil {
		_u.SetPasswordHash(*v)
	}
	return _u
}

// SetEmailVerified sets the "email_verified" field.
func (_u *UserUpdate) SetEmailVerified(v bool) *UserUpdate {
	_u.mutation.SetEmailVerified(v)
	return _u
}

// SetNillableEmailVerified sets the "email_verified" field if the given value is not nil.
func (_u *UserUpdate) SetNillableEmailVerified(v *bool) *UserUpdate {
	if v != nil {
		_u.SetEmailVerified(*v)
	}
	return _u
}

// SetAvatarURL sets the "avatar_url" field.
func (_u *UserUpdate) SetAvatarURL(v string) *UserUpdate {
	_u.mutation.SetAvatarURL(v)
	return _u
}

// SetNillableAvatarURL sets the "avatar_url" field if the given value is not nil.
func (_u *UserUpdate) SetNillableAvatarURL(v *string) *UserUpdate {
	if v != nil {
		_u.SetAvatarURL(*v)
	}
	return _u
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (_u *UserUpdate) ClearAvatarURL() *UserUpdate {
	_u.mutation.ClearAvatarURL()
	return _u
}

// SetFullName sets the "full_name" field.
func (_u *UserUpdate) SetFullName(v string) *UserUpdate {
	_u.mutation.SetFullName(v)
	return _u
}

// SetNillableFullName sets the "full_name" field if the given value is not nil.
func (_u *UserUpdate) SetNillableFullName(v *string) *UserUpdate {
	if v != nil {
		_u.SetFullName(*v)
	}
	return _u
}

// ClearFullName clears the value of the "full_name" field.
func (_u *UserUpdate) ClearFullName() *UserUpdate {
	_u.mutation.ClearFullName()
	return _u
}

// SetBio sets the "bio" field.
func (_u *UserUpdate) SetBio(v string) *UserUpdate {
	_u.mutation.SetBio(v)
	return _u
}

// SetNillableBio sets the "bio" field if the given value is not nil.
func (_u *UserUpdate) SetNillableBio(v *string) *UserUpdate {
	if v != nil {
		_u.SetBio(*v)
	}
	return _u
}

// ClearBio clears the value of the "bio" field.
func (_u *UserUpdate) ClearBio() *UserUpdate {
	_u.mutation.ClearBio()
	return _u
}

// SetPronouns sets the "pronouns" field.
func (_u *UserUpdate) SetPronouns(v string) *UserUpdate {
	_u.mutation.SetPronouns(v)
	return _u
}

// SetNillablePronouns sets the "pronouns" field if the given value is not nil.
func (_u *UserUpdate) SetNillablePronouns(v *string) *UserUpdate {
	if v != nil {
		_u.SetPronouns(*v)
	}
	return _u
}

// ClearPronouns clears the value of the "pronouns" field.
func (_u *UserUpdate) ClearPronouns() *UserUpdate {
	_u.mutation.ClearPronouns()
	return _u
}

// SetCompany sets the "company" field.
func (_u *UserUpdate) SetCompany(v string) *UserUpdate {
	_u.mutation.SetCompany(v)
	return _u
}

// SetNillableCompany sets the "company" field if the given value is not nil.
func (_u *UserUpdate) SetNillableCompany(v *string) *UserUpdate {
	if v != nil {
		_u.SetCompany(*v)
	}
	return _u
}

// ClearCompany clears the value of the "company" field.
func (_u *UserUpdate) ClearCompany() *UserUpdate {
	_u.mutation.ClearCompany()
	return _u
}

// SetTelegram sets the "telegram" field.
func (_u *UserUpdate) SetTelegram(v string) *UserUpdate {
	_u.mutation.SetTelegram(v)
	return _u
}

// SetNillableTelegram sets the "telegram" field if the given value is not nil.
func (_u *UserUpdate) SetNillableTelegram(v *string) *UserUpdate {
	if v != nil {
		_u.SetTelegram(*v)
	}
	return _u
}

// ClearTelegram clears the value of the "telegram" field.
func (_u *UserUpdate) ClearTelegram() *UserUpdate {
	_u.mutation.ClearTelegram()
	return _u
}

// SetSocialAccounts sets the "social_accounts" field.
func (_u *UserUpdate) SetSocialAccounts(v map[string]interface{}) *UserUpdate {
	_u.mutation.SetSocialAccounts(v)
	return _u
}

// ClearSocialAccounts clears the value of the "social_accounts" field.
func (_u *UserUpdate) ClearSocialAccounts() *UserUpdate {
	_u.mutation.ClearSocialAccounts()
	return _u
}

// SetPrimaryBadgeID sets the "primary_badge_id" field.
func (_u *UserUpdate) SetPrimaryBadgeID(v int) *UserUpdate {
	_u.mutation.SetPrimaryBadgeID(v)
	return _u
}

// SetNillablePrimaryBadgeID sets the "primary_badge_id" field if the given value is not nil.
func (_u *UserUpdate) SetNillablePrimaryBadgeID(v *int) *UserUpdate {
	if v != nil {
		_u.SetPrimaryBadgeID(*v)
	}
	return _u
}

// ClearPrimaryBadgeID clears the value of the "primary_badge_id" field.
func (_u *UserUpdate) ClearPrimaryBadgeID() *UserUpdate {
	_u.mutation.ClearPrimaryBadgeID()
	return _u
}

// SetTotpSecret sets the "totp_secret" field.
func (_u *UserUpdate) SetTotpSecret(v string) *UserUpdate {
	_u.mutation.SetTotpSecret(v)
	return _u
}

// SetNillableTotpSecret sets the "totp_secret" field if the given value is not nil.
func (_u *UserUpdate) SetNillableTotpSecret(v *string) *UserUpdate {
	if v != nil {
		_u.SetTotpSecret(*v)
	}
	return _u
}

// ClearTotpSecret clears the value of the "totp_secret" field.
func (_u *UserUpdate) ClearTotpSecret() *UserUpdate {
	_u.mutation.ClearTotpSecret()
	return _u
}

// SetTotpEnabled sets the "totp_enabled" field.
func (_u *UserUpdate) SetTotpEnabled(v bool) *UserUpdate {
	_u.mutation.SetTotpEnabled(v)
	return _u
}

// SetNillableTotpEnabled sets the "totp_enabled" field if the given value is not nil.
func (_u *UserUpdate) SetNillableTotpEnabled(v *bool) *UserUpdate {
	if v != nil {
		_u.SetTotpEnabled(*v)
	}
	return _u
}

// SetTotpVerified sets the "totp_verified" field.
func (_u *UserUpdate) SetTotpVerified(v bool) *UserUpdate {
	_u.mutation.SetTotpVerified(v)
	return _u
}

// SetNillableTotpVerified sets the "totp_verified" field if the given value is not nil.
func (_u *UserUpdate) SetNillableTotpVerified(v *bool) *UserUpdate {
	if v != nil {
		_u.SetTotpVerified(*v)
	}
	return _u
}

// SetTotpVerifiedAt sets the "totp_verified_at" field.
func (_u *UserUpdate) SetTotpVerifiedAt(v time.Time) *UserUpdate {
	_u.mutation.SetTotpVerifiedAt(v)
	return _u
}

// SetNillableTotpVerifiedAt sets the "totp_verified_at" field if the given value is not nil.
func (_u *UserUpdate) SetNillableTotpVerifiedAt(v *time.Time) *UserUpdate {
	if v != nil {
		_u.SetTotpVerifiedAt(*v)
	}
	return _u
}

// ClearTotpVerifiedAt clears the value of the "totp_verified_at" field.
func (_u *UserUpdate) ClearTotpVerifiedAt() *UserUpdate {
	_u.mutation.ClearTotpVerifiedAt()
	return _u
}

// SetFailedLoginAttempts sets the "failed_login_attempts" field.
func (_u *UserUpdate) SetFailedLoginAttempts(v int) *UserUpdate {
	_u.mutation.ResetFailedLoginAttempts()
	_u.mutation.SetFailedLoginAttempts(v)
	return _u
}

// SetNillableFailedLoginAttempts sets the "failed_login_attempts" field if the given value is not nil.
func (_u *UserUpdate) SetNillableFailedLoginAttempts(v *int) *UserUpdate {
	if v != nil {
		_u.SetFailedLoginAttempts(*v)
	}
	return _u
}

// AddFailedLoginAttempts adds value to the "failed_login_attempts" field.
func (_u *UserUpdate) AddFailedLoginAttempts(v int) *UserUpdate {
	_u.mutation.AddFailedLoginAttempts(v)
	return _u
}

// SetLastFailedAt sets the "last_failed_at" field.
func (_u *UserUpdate) SetLastFailedAt(v time.Time) *UserUpdate {
	_u.mutation.SetLastFailedAt(v)
	return _u
}

// SetNillableLastFailedAt sets the "last_failed_at" field if the given value is not nil.
func (_u *UserUpdate) SetNillableLastFailedAt(v *time.Time) *UserUpdate {
	if v != nil {
		_u.SetLastFailedAt(*v)
	}
	return _u
}

// ClearLastFailedAt clears the value of the "last_failed_at" field.
func (_u *UserUpdate) ClearLastFailedAt() *UserUpdate {
	_u.mutation.ClearLastFailedAt()
	return _u
}

// SetLastLoginAt sets the "last_login_at" field.
func (_u *UserUpdate) SetLastLoginAt(v time.Time) *UserUpdate {
	_u.mutation.SetLastLoginAt(v)
	return _u
}

// SetNillableLastLoginAt sets the "last_login_at" field if the given value is not nil.
func (_u *UserUpdate) SetNillableLastLoginAt(v *time.Time) *UserUpdate {
	if v != nil {
		_u.SetLastLoginAt(*v)
	}
	return _u
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (_u *UserUpdate) ClearLastLoginAt() *UserUpdate {
	_u.mutation.ClearLastLoginAt()
	return _u
}

// SetLastLoginIP sets the "last_login_ip" field.
func (_u *UserUpdate) SetLastLoginIP(v string) *UserUpdate {
	_u.mutation.SetLastLoginIP(v)
	return _u
}

// SetNillableLastLoginIP sets the "last_login_ip" field if the given value is not nil.
func (_u *UserUpdate) SetNillableLastLoginIP(v *string) *UserUpdate {
	if v != nil {
		_u.SetLastLoginIP(*v)
	}
	return _u
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (_u *UserUpdate) ClearLastLoginIP() *UserUpdate {
	_u.mutation.ClearLastLoginIP()
	return _u
}

// SetLockedUntil sets the "locked_until" field.
func (_u *UserUpdate) SetLockedUntil(v time.Time) *UserUpdate {
	_u.mutation.SetLockedUntil(v)
	return _u
}

// SetNillableLockedUntil sets the "locked_until" field if the given value is not nil.
func (_u *UserUpdate) SetNillableLockedUntil(v *time.Time) *UserUpdate {
	if v != nil {
		_u.SetLockedUntil(*v)
	}
	return _u
}

// ClearLockedUntil clears the value of the "locked_until" field.
func (_u *UserUpdate) ClearLockedUntil() *UserUpdate {
	_u.mutation.ClearLockedUntil()
	return _u
}

// SetLockReason sets the "lock_reason" field.
func (_u *UserUpdate) SetLockReason(v string) *UserUpdate {
	_u.mutation.SetLockReason(v)
	return _u
}

// SetNillableLockReason sets the "lock_reason" field if the given value is not nil.
func (_u *UserUpdate) SetNillableLockReason(v *string) *UserUpdate {
	if v != nil {
		_u.SetLockReason(*v)
	}
	return _u
}

// ClearLockReason clears the value of the "lock_reason" field.
func (_u *UserUpdate) ClearLockReason() *UserUpdate {
	_u.mutation.ClearLockReason()
	return _u
}

// AddPasskeyIDs adds the "passkeys" edge to the Passkey entity by IDs.
func (_u *UserUpdate) AddPasskeyIDs(ids ...int) *UserUpdate {
	_u.mutation.AddPasskeyIDs(ids...)
	return _u
}

// AddPasskeys adds the "passkeys" edges to the Passkey entity.
func (_u *UserUpdate) AddPasskeys(v ...*Passkey) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPasskeyIDs(ids...)
}

// AddSessionIDs adds the "sessions" edge to the Session entity by IDs.
func (_u *UserUpdate) AddSessionIDs(ids ...int) *UserUpdate {
	_u.mutation.AddSessionIDs(ids...)
	return _u
}

// AddSessions adds the "sessions" edges to the Session entity.
func (_u *UserUpdate) AddSessions(v ...*Session) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSessionIDs(ids...)
}

// AddBackupCodeIDs adds the "backup_codes" edge to the BackupCode entity by IDs.
func (_u *UserUpdate) AddBackupCodeIDs(ids ...int) *UserUpdate {
	_u.mutation.AddBackupCodeIDs(ids...)
	return _u
}

// AddBackupCodes adds the "backup_codes" edges to the BackupCode entity.
func (_u *UserUpdate) AddBackupCodes(v ...*BackupCode) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddBackupCodeIDs(ids...)
}

// AddThreadIDs adds the "threads" edge to the Thread entity by IDs.
func (_u *UserUpdate) AddThreadIDs(ids ...int) *UserUpdate {
	_u.mutation.AddThreadIDs(ids...)
	return _u
}

// AddThreads adds the "threads" edges to the Thread entity.
func (_u *UserUpdate) AddThreads(v ...*Thread) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddThreadIDs(ids...)
}

// AddUserBadgeIDs adds the "user_badges" edge to the UserBadge entity by IDs.
func (_u *UserUpdate) AddUserBadgeIDs(ids ...int) *UserUpdate {
	_u.mutation.AddUserBadgeIDs(ids...)
	return _u
}

// AddUserBadges adds the "user_badges" edges to the UserBadge entity.
func (_u *UserUpdate) AddUserBadges(v ...*UserBadge) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddUserBadgeIDs(ids...)
}

// AddSessionLockIDs adds the "session_locks" edge to the SessionLock entity by IDs.
func (_u *UserUpdate) AddSessionLockIDs(ids ...int) *UserUpdate {
	_u.mutation.AddSessionLockIDs(ids...)
	return _u
}

// AddSessionLocks adds the "session_locks" edges to the SessionLock entity.
func (_u *UserUpdate) AddSessionLocks(v ...*SessionLock) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSessionLockIDs(ids...)
}

// AddEmailVerificationTokenIDs adds the "email_verification_tokens" edge to the EmailVerificationToken entity by IDs.
func (_u *UserUpdate) AddEmailVerificationTokenIDs(ids ...int) *UserUpdate {
	_u.mutation.AddEmailVerificationTokenIDs(ids...)
	return _u
}

// AddEmailVerificationTokens adds the "email_verification_tokens" edges to the EmailVerificationToken entity.
func (_u *UserUpdate) AddEmailVerificationTokens(v ...*EmailVerificationToken) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddEmailVerificationTokenIDs(ids...)
}

// AddPasswordResetTokenIDs adds the "password_reset_tokens" edge to the PasswordResetToken entity by IDs.
func (_u *UserUpdate) AddPasswordResetTokenIDs(ids ...int) *UserUpdate {
	_u.mutation.AddPasswordResetTokenIDs(ids...)
	return _u
}

// AddPasswordResetTokens adds the "password_reset_tokens" edges to the PasswordResetToken entity.
func (_u *UserUpdate) AddPasswordResetTokens(v ...*PasswordResetToken) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPasswordResetTokenIDs(ids...)
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by IDs.
func (_u *UserUpdate) AddCredentialIDs(ids ...int) *UserUpdate {
	_u.mutation.AddCredentialIDs(ids...)
	return _u
}

// AddCredentials adds the "credentials" edges to the Credential entity.
func (_u *UserUpdate) AddCredentials(v ...*Credential) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCredentialIDs(ids...)
}

// AddTotpPendingTokenIDs adds the "totp_pending_tokens" edge to the TOTPPendingToken entity by IDs.
func (_u *UserUpdate) AddTotpPendingTokenIDs(ids ...int) *UserUpdate {
	_u.mutation.AddTotpPendingTokenIDs(ids...)
	return _u
}

// AddTotpPendingTokens adds the "totp_pending_tokens" edges to the TOTPPendingToken entity.
func (_u *UserUpdate) AddTotpPendingTokens(v ...*TOTPPendingToken) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddTotpPendingTokenIDs(ids...)
}

// AddSecurityEventIDs adds the "security_events" edge to the SecurityEvent entity by IDs.
func (_u *UserUpdate) AddSecurityEventIDs(ids ...int) *UserUpdate {
	_u.mutation.AddSecurityEventIDs(ids...)
	return _u
}

// AddSecurityEvents adds the "security_events" edges to the SecurityEvent entity.
func (_u *UserUpdate) AddSecurityEvents(v ...*SecurityEvent) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSecurityEventIDs(ids...)
}

// AddDeviceFingerprintIDs adds the "device_fingerprints" edge to the DeviceFingerprint entity by IDs.
func (_u *UserUpdate) AddDeviceFingerprintIDs(ids ...int) *UserUpdate {
	_u.mutation.AddDeviceFingerprintIDs(ids...)
	return _u
}

// AddDeviceFingerprints adds the "device_fingerprints" edges to the DeviceFingerprint entity.
func (_u *UserUpdate) AddDeviceFingerprints(v ...*DeviceFingerprint) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddDeviceFingerprintIDs(ids...)
}

// AddDeviceUserMappingIDs adds the "device_user_mappings" edge to the DeviceUserMapping entity by IDs.
func (_u *UserUpdate) AddDeviceUserMappingIDs(ids ...int) *UserUpdate {
	_u.mutation.AddDeviceUserMappingIDs(ids...)
	return _u
}

// AddDeviceUserMappings adds the "device_user_mappings" edges to the DeviceUserMapping entity.
func (_u *UserUpdate) AddDeviceUserMappings(v ...*DeviceUserMapping) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddDeviceUserMappingIDs(ids...)
}

// AddSudoSessionIDs adds the "sudo_sessions" edge to the SudoSession entity by IDs.
func (_u *UserUpdate) AddSudoSessionIDs(ids ...int) *UserUpdate {
	_u.mutation.AddSudoSessionIDs(ids...)
	return _u
}

// AddSudoSessions adds the "sudo_sessions" edges to the SudoSession entity.
func (_u *UserUpdate) AddSudoSessions(v ...*SudoSession) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSudoSessionIDs(ids...)
}

// SetPrimaryBadge sets the "primary_badge" edge to the Badge entity.
func (_u *UserUpdate) SetPrimaryBadge(v *Badge) *UserUpdate {
	return _u.SetPrimaryBadgeID(v.ID)
}

// Mutation returns the UserMutation object of the builder.
func (_u *UserUpdate) Mutation() *UserMutation {
	return _u.mutation
}

// ClearPasskeys clears all "passkeys" edges to the Passkey entity.
func (_u *UserUpdate) ClearPasskeys() *UserUpdate {
	_u.mutation.ClearPasskeys()
	return _u
}

// RemovePasskeyIDs removes the "passkeys" edge to Passkey entities by IDs.
func (_u *UserUpdate) RemovePasskeyIDs(ids ...int) *UserUpdate {
	_u.mutation.RemovePasskeyIDs(ids...)
	return _u
}

// RemovePasskeys removes "passkeys" edges to Passkey entities.
func (_u *UserUpdate) RemovePasskeys(v ...*Passkey) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePasskeyIDs(ids...)
}

// ClearSessions clears all "sessions" edges to the Session entity.
func (_u *UserUpdate) ClearSessions() *UserUpdate {
	_u.mutation.ClearSessions()
	return _u
}

// RemoveSessionIDs removes the "sessions" edge to Session entities by IDs.
func (_u *UserUpdate) RemoveSessionIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveSessionIDs(ids...)
	return _u
}

// RemoveSessions removes "sessions" edges to Session entities.
func (_u *UserUpdate) RemoveSessions(v ...*Session) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSessionIDs(ids...)
}

// ClearBackupCodes clears all "backup_codes" edges to the BackupCode entity.
func (_u *UserUpdate) ClearBackupCodes() *UserUpdate {
	_u.mutation.ClearBackupCodes()
	return _u
}

// RemoveBackupCodeIDs removes the "backup_codes" edge to BackupCode entities by IDs.
func (_u *UserUpdate) RemoveBackupCodeIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveBackupCodeIDs(ids...)
	return _u
}

// RemoveBackupCodes removes "backup_codes" edges to BackupCode entities.
func (_u *UserUpdate) RemoveBackupCodes(v ...*BackupCode) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveBackupCodeIDs(ids...)
}

// ClearThreads clears all "threads" edges to the Thread entity.
func (_u *UserUpdate) ClearThreads() *UserUpdate {
	_u.mutation.ClearThreads()
	return _u
}

// RemoveThreadIDs removes the "threads" edge to Thread entities by IDs.
func (_u *UserUpdate) RemoveThreadIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveThreadIDs(ids...)
	return _u
}

// RemoveThreads removes "threads" edges to Thread entities.
func (_u *UserUpdate) RemoveThreads(v ...*Thread) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveThreadIDs(ids...)
}

// ClearUserBadges clears all "user_badges" edges to the UserBadge entity.
func (_u *UserUpdate) ClearUserBadges() *UserUpdate {
	_u.mutation.ClearUserBadges()
	return _u
}

// RemoveUserBadgeIDs removes the "user_badges" edge to UserBadge entities by IDs.
func (_u *UserUpdate) RemoveUserBadgeIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveUserBadgeIDs(ids...)
	return _u
}

// RemoveUserBadges removes "user_badges" edges to UserBadge entities.
func (_u *UserUpdate) RemoveUserBadges(v ...*UserBadge) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveUserBadgeIDs(ids...)
}

// ClearSessionLocks clears all "session_locks" edges to the SessionLock entity.
func (_u *UserUpdate) ClearSessionLocks() *UserUpdate {
	_u.mutation.ClearSessionLocks()
	return _u
}

// RemoveSessionLockIDs removes the "session_locks" edge to SessionLock entities by IDs.
func (_u *UserUpdate) RemoveSessionLockIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveSessionLockIDs(ids...)
	return _u
}

// RemoveSessionLocks removes "session_locks" edges to SessionLock entities.
func (_u *UserUpdate) RemoveSessionLocks(v ...*SessionLock) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSessionLockIDs(ids...)
}

// ClearEmailVerificationTokens clears all "email_verification_tokens" edges to the EmailVerificationToken entity.
func (_u *UserUpdate) ClearEmailVerificationTokens() *UserUpdate {
	_u.mutation.ClearEmailVerificationTokens()
	return _u
}

// RemoveEmailVerificationTokenIDs removes the "email_verification_tokens" edge to EmailVerificationToken entities by IDs.
func (_u *UserUpdate) RemoveEmailVerificationTokenIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveEmailVerificationTokenIDs(ids...)
	return _u
}

// RemoveEmailVerificationTokens removes "email_verification_tokens" edges to EmailVerificationToken entities.
func (_u *UserUpdate) RemoveEmailVerificationTokens(v ...*EmailVerificationToken) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveEmailVerificationTokenIDs(ids...)
}

// ClearPasswordResetTokens clears all "password_reset_tokens" edges to the PasswordResetToken entity.
func (_u *UserUpdate) ClearPasswordResetTokens() *UserUpdate {
	_u.mutation.ClearPasswordResetTokens()
	return _u
}

// RemovePasswordResetTokenIDs removes the "password_reset_tokens" edge to PasswordResetToken entities by IDs.
func (_u *UserUpdate) RemovePasswordResetTokenIDs(ids ...int) *UserUpdate {
	_u.mutation.RemovePasswordResetTokenIDs(ids...)
	return _u
}

// RemovePasswordResetTokens removes "password_reset_tokens" edges to PasswordResetToken entities.
func (_u *UserUpdate) RemovePasswordResetTokens(v ...*PasswordResetToken) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePasswordResetTokenIDs(ids...)
}

// ClearCredentials clears all "credentials" edges to the Credential entity.
func (_u *UserUpdate) ClearCredentials() *UserUpdate {
	_u.mutation.ClearCredentials()
	return _u
}

// RemoveCredentialIDs removes the "credentials" edge to Credential entities by IDs.
func (_u *UserUpdate) RemoveCredentialIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveCredentialIDs(ids...)
	return _u
}

// RemoveCredentials removes "credentials" edges to Credential entities.
func (_u *UserUpdate) RemoveCredentials(v ...*Credential) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCredentialIDs(ids...)
}

// ClearTotpPendingTokens clears all "totp_pending_tokens" edges to the TOTPPendingToken entity.
func (_u *UserUpdate) ClearTotpPendingTokens() *UserUpdate {
	_u.mutation.ClearTotpPendingTokens()
	return _u
}

// RemoveTotpPendingTokenIDs removes the "totp_pending_tokens" edge to TOTPPendingToken entities by IDs.
func (_u *UserUpdate) RemoveTotpPendingTokenIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveTotpPendingTokenIDs(ids...)
	return _u
}

// RemoveTotpPendingTokens removes "totp_pending_tokens" edges to TOTPPendingToken entities.
func (_u *UserUpdate) RemoveTotpPendingTokens(v ...*TOTPPendingToken) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveTotpPendingTokenIDs(ids...)
}

// ClearSecurityEvents clears all "security_events" edges to the SecurityEvent entity.
func (_u *UserUpdate) ClearSecurityEvents() *UserUpdate {
	_u.mutation.ClearSecurityEvents()
	return _u
}

// RemoveSecurityEventIDs removes the "security_events" edge to SecurityEvent entities by IDs.
func (_u *UserUpdate) RemoveSecurityEventIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveSecurityEventIDs(ids...)
	return _u
}

// RemoveSecurityEvents removes "security_events" edges to SecurityEvent entities.
func (_u *UserUpdate) RemoveSecurityEvents(v ...*SecurityEvent) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSecurityEventIDs(ids...)
}

// ClearDeviceFingerprints clears all "device_fingerprints" edges to the DeviceFingerprint entity.
func (_u *UserUpdate) ClearDeviceFingerprints() *UserUpdate {
	_u.mutation.ClearDeviceFingerprints()
	return _u
}

// RemoveDeviceFingerprintIDs removes the "device_fingerprints" edge to DeviceFingerprint entities by IDs.
func (_u *UserUpdate) RemoveDeviceFingerprintIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveDeviceFingerprintIDs(ids...)
	return _u
}

// RemoveDeviceFingerprints removes "device_fingerprints" edges to DeviceFingerprint entities.
func (_u *UserUpdate) RemoveDeviceFingerprints(v ...*DeviceFingerprint) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveDeviceFingerprintIDs(ids...)
}

// ClearDeviceUserMappings clears all "device_user_mappings" edges to the DeviceUserMapping entity.
func (_u *UserUpdate) ClearDeviceUserMappings() *UserUpdate {
	_u.mutation.ClearDeviceUserMappings()
	return _u
}

// RemoveDeviceUserMappingIDs removes the "device_user_mappings" edge to DeviceUserMapping entities by IDs.
func (_u *UserUpdate) RemoveDeviceUserMappingIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveDeviceUserMappingIDs(ids...)
	return _u
}

// RemoveDeviceUserMappings removes "device_user_mappings" edges to DeviceUserMapping entities.
func (_u *UserUpdate) RemoveDeviceUserMappings(v ...*DeviceUserMapping) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveDeviceUserMappingIDs(ids...)
}

// ClearSudoSessions clears all "sudo_sessions" edges to the SudoSession entity.
func (_u *UserUpdate) ClearSudoSessions() *UserUpdate {
	_u.mutation.ClearSudoSessions()
	return _u
}

// RemoveSudoSessionIDs removes the "sudo_sessions" edge to SudoSession entities by IDs.
func (_u *UserUpdate) RemoveSudoSessionIDs(ids ...int) *UserUpdate {
	_u.mutation.RemoveSudoSessionIDs(ids...)
	return _u
}

// RemoveSudoSessions removes "sudo_sessions" edges to SudoSession entities.
func (_u *UserUpdate) RemoveSudoSessions(v ...*SudoSession) *UserUpdate {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSudoSessionIDs(ids...)
}

// ClearPrimaryBadge clears the "primary_badge" edge to the Badge entity.
func (_u *UserUpdate) ClearPrimaryBadge() *UserUpdate {
	_u.mutation.ClearPrimaryBadge()
	return _u
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (_u *UserUpdate) Save(ctx context.Context) (int, error) {
	_u.defaults()
	return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (_u *UserUpdate) SaveX(ctx context.Context) int {
	affected, err := _u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (_u *UserUpdate) Exec(ctx context.Context) error {
	_, err := _u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (_u *UserUpdate) ExecX(ctx context.Context) {
	if err := _u.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (_u *UserUpdate) defaults() {
	if _, ok := _u.mutation.UpdatedAt(); !ok {
		v := user.UpdateDefaultUpdatedAt()
		_u.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (_u *UserUpdate) check() error {
	if v, ok := _u.mutation.Email(); ok {
		if err := user.EmailValidator(v); err != nil {
			return &ValidationError{Name: "email", err: fmt.Errorf(`ent: validator failed for field "User.email": %w`, err)}
		}
	}
	if v, ok := _u.mutation.PasswordHash(); ok {
		if err := user.PasswordHashValidator(v); err != nil {
			return &ValidationError{Name: "password_hash", err: fmt.Errorf(`ent: validator failed for field "User.password_hash": %w`, err)}
		}
	}
	if v, ok := _u.mutation.LastLoginIP(); ok {
		if err := user.LastLoginIPValidator(v); err != nil {
			return &ValidationError{Name: "last_login_ip", err: fmt.Errorf(`ent: validator failed for field "User.last_login_ip": %w`, err)}
		}
	}
	if v, ok := _u.mutation.LockReason(); ok {
		if err := user.LockReasonValidator(v); err != nil {
			return &ValidationError{Name: "lock_reason", err: fmt.Errorf(`ent: validator failed for field "User.lock_reason": %w`, err)}
		}
	}
	return nil
}

func (_u *UserUpdate) sqlSave(ctx context.Context) (_node int, err error) {
	if err := _u.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt))
	if ps := _u.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := _u.mutation.UpdatedAt(); ok {
		_spec.SetField(user.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := _u.mutation.DeletedAt(); ok {
		_spec.SetField(user.FieldDeletedAt, field.TypeTime, value)
	}
	if _u.mutation.DeletedAtCleared() {
		_spec.ClearField(user.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := _u.mutation.Email(); ok {
		_spec.SetField(user.FieldEmail, field.TypeString, value)
	}
	if value, ok := _u.mutation.Username(); ok {
		_spec.SetField(user.FieldUsername, field.TypeString, value)
	}
	if _u.mutation.UsernameCleared() {
		_spec.ClearField(user.FieldUsername, field.TypeString)
	}
	if value, ok := _u.mutation.PasswordHash(); ok {
		_spec.SetField(user.FieldPasswordHash, field.TypeString, value)
	}
	if value, ok := _u.mutation.EmailVerified(); ok {
		_spec.SetField(user.FieldEmailVerified, field.TypeBool, value)
	}
	if value, ok := _u.mutation.AvatarURL(); ok {
		_spec.SetField(user.FieldAvatarURL, field.TypeString, value)
	}
	if _u.mutation.AvatarURLCleared() {
		_spec.ClearField(user.FieldAvatarURL, field.TypeString)
	}
	if value, ok := _u.mutation.FullName(); ok {
		_spec.SetField(user.FieldFullName, field.TypeString, value)
	}
	if _u.mutation.FullNameCleared() {
		_spec.ClearField(user.FieldFullName, field.TypeString)
	}
	if value, ok := _u.mutation.Bio(); ok {
		_spec.SetField(user.FieldBio, field.TypeString, value)
	}
	if _u.mutation.BioCleared() {
		_spec.ClearField(user.FieldBio, field.TypeString)
	}
	if value, ok := _u.mutation.Pronouns(); ok {
		_spec.SetField(user.FieldPronouns, field.TypeString, value)
	}
	if _u.mutation.PronounsCleared() {
		_spec.ClearField(user.FieldPronouns, field.TypeString)
	}
	if value, ok := _u.mutation.Company(); ok {
		_spec.SetField(user.FieldCompany, field.TypeString, value)
	}
	if _u.mutation.CompanyCleared() {
		_spec.ClearField(user.FieldCompany, field.TypeString)
	}
	if value, ok := _u.mutation.Telegram(); ok {
		_spec.SetField(user.FieldTelegram, field.TypeString, value)
	}
	if _u.mutation.TelegramCleared() {
		_spec.ClearField(user.FieldTelegram, field.TypeString)
	}
	if value, ok := _u.mutation.SocialAccounts(); ok {
		_spec.SetField(user.FieldSocialAccounts, field.TypeJSON, value)
	}
	if _u.mutation.SocialAccountsCleared() {
		_spec.ClearField(user.FieldSocialAccounts, field.TypeJSON)
	}
	if value, ok := _u.mutation.TotpSecret(); ok {
		_spec.SetField(user.FieldTotpSecret, field.TypeString, value)
	}
	if _u.mutation.TotpSecretCleared() {
		_spec.ClearField(user.FieldTotpSecret, field.TypeString)
	}
	if value, ok := _u.mutation.TotpEnabled(); ok {
		_spec.SetField(user.FieldTotpEnabled, field.TypeBool, value)
	}
	if value, ok := _u.mutation.TotpVerified(); ok {
		_spec.SetField(user.FieldTotpVerified, field.TypeBool, value)
	}
	if value, ok := _u.mutation.TotpVerifiedAt(); ok {
		_spec.SetField(user.FieldTotpVerifiedAt, field.TypeTime, value)
	}
	if _u.mutation.TotpVerifiedAtCleared() {
		_spec.ClearField(user.FieldTotpVerifiedAt, field.TypeTime)
	}
	if value, ok := _u.mutation.FailedLoginAttempts(); ok {
		_spec.SetField(user.FieldFailedLoginAttempts, field.TypeInt, value)
	}
	if value, ok := _u.mutation.AddedFailedLoginAttempts(); ok {
		_spec.AddField(user.FieldFailedLoginAttempts, field.TypeInt, value)
	}
	if value, ok := _u.mutation.LastFailedAt(); ok {
		_spec.SetField(user.FieldLastFailedAt, field.TypeTime, value)
	}
	if _u.mutation.LastFailedAtCleared() {
		_spec.ClearField(user.FieldLastFailedAt, field.TypeTime)
	}
	if value, ok := _u.mutation.LastLoginAt(); ok {
		_spec.SetField(user.FieldLastLoginAt, field.TypeTime, value)
	}
	if _u.mutation.LastLoginAtCleared() {
		_spec.ClearField(user.FieldLastLoginAt, field.TypeTime)
	}
	if value, ok := _u.mutation.LastLoginIP(); ok {
		_spec.SetField(user.FieldLastLoginIP, field.TypeString, value)
	}
	if _u.mutation.LastLoginIPCleared() {
		_spec.ClearField(user.FieldLastLoginIP, field.TypeString)
	}
	if value, ok := _u.mutation.LockedUntil(); ok {
		_spec.SetField(user.FieldLockedUntil, field.TypeTime, value)
	}
	if _u.mutation.LockedUntilCleared() {
		_spec.ClearField(user.FieldLockedUntil, field.TypeTime)
	}
	if value, ok := _u.mutation.LockReason(); ok {
		_spec.SetField(user.FieldLockReason, field.TypeString, value)
	}
	if _u.mutation.LockReasonCleared() {
		_spec.ClearField(user.FieldLockReason, field.TypeString)
	}
	if _u.mutation.PasskeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasskeysTable,
			Columns: []string{user.PasskeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passkey.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPasskeysIDs(); len(nodes) > 0 && !_u.mutation.PasskeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasskeysTable,
			Columns: []string{user.PasskeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passkey.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PasskeysIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasskeysTable,
			Columns: []string{user.PasskeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passkey.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionsTable,
			Columns: []string{user.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSessionsIDs(); len(nodes) > 0 && !_u.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionsTable,
			Columns: []string{user.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionsTable,
			Columns: []string{user.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.BackupCodesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.BackupCodesTable,
			Columns: []string{user.BackupCodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(backupcode.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedBackupCodesIDs(); len(nodes) > 0 && !_u.mutation.BackupCodesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.BackupCodesTable,
			Columns: []string{user.BackupCodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(backupcode.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.BackupCodesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.BackupCodesTable,
			Columns: []string{user.BackupCodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(backupcode.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ThreadsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ThreadsTable,
			Columns: []string{user.ThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(thread.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedThreadsIDs(); len(nodes) > 0 && !_u.mutation.ThreadsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ThreadsTable,
			Columns: []string{user.ThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(thread.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ThreadsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ThreadsTable,
			Columns: []string{user.ThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(thread.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.UserBadgesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserBadgesTable,
			Columns: []string{user.UserBadgesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(userbadge.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedUserBadgesIDs(); len(nodes) > 0 && !_u.mutation.UserBadgesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserBadgesTable,
			Columns: []string{user.UserBadgesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(userbadge.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.UserBadgesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserBadgesTable,
			Columns: []string{user.UserBadgesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(userbadge.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SessionLocksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionLocksTable,
			Columns: []string{user.SessionLocksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sessionlock.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSessionLocksIDs(); len(nodes) > 0 && !_u.mutation.SessionLocksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionLocksTable,
			Columns: []string{user.SessionLocksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sessionlock.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SessionLocksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionLocksTable,
			Columns: []string{user.SessionLocksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sessionlock.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.EmailVerificationTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.EmailVerificationTokensTable,
			Columns: []string{user.EmailVerificationTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(emailverificationtoken.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedEmailVerificationTokensIDs(); len(nodes) > 0 && !_u.mutation.EmailVerificationTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.EmailVerificationTokensTable,
			Columns: []string{user.EmailVerificationTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(emailverificationtoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.EmailVerificationTokensIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.EmailVerificationTokensTable,
			Columns: []string{user.EmailVerificationTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(emailverificationtoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PasswordResetTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasswordResetTokensTable,
			Columns: []string{user.PasswordResetTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passwordresettoken.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPasswordResetTokensIDs(); len(nodes) > 0 && !_u.mutation.PasswordResetTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasswordResetTokensTable,
			Columns: []string{user.PasswordResetTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passwordresettoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PasswordResetTokensIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasswordResetTokensTable,
			Columns: []string{user.PasswordResetTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passwordresettoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CredentialsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CredentialsTable,
			Columns: []string{user.CredentialsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(credential.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCredentialsIDs(); len(nodes) > 0 && !_u.mutation.CredentialsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CredentialsTable,
			Columns: []string{user.CredentialsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(credential.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CredentialsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CredentialsTable,
			Columns: []string{user.CredentialsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(credential.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.TotpPendingTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TotpPendingTokensTable,
			Columns: []string{user.TotpPendingTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(totppendingtoken.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedTotpPendingTokensIDs(); len(nodes) > 0 && !_u.mutation.TotpPendingTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TotpPendingTokensTable,
			Columns: []string{user.TotpPendingTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(totppendingtoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.TotpPendingTokensIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TotpPendingTokensTable,
			Columns: []string{user.TotpPendingTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(totppendingtoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SecurityEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SecurityEventsTable,
			Columns: []string{user.SecurityEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(securityevent.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSecurityEventsIDs(); len(nodes) > 0 && !_u.mutation.SecurityEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SecurityEventsTable,
			Columns: []string{user.SecurityEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(securityevent.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SecurityEventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SecurityEventsTable,
			Columns: []string{user.SecurityEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(securityevent.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.DeviceFingerprintsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceFingerprintsTable,
			Columns: []string{user.DeviceFingerprintsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(devicefingerprint.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedDeviceFingerprintsIDs(); len(nodes) > 0 && !_u.mutation.DeviceFingerprintsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceFingerprintsTable,
			Columns: []string{user.DeviceFingerprintsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(devicefingerprint.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.DeviceFingerprintsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceFingerprintsTable,
			Columns: []string{user.DeviceFingerprintsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(devicefingerprint.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.DeviceUserMappingsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceUserMappingsTable,
			Columns: []string{user.DeviceUserMappingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(deviceusermapping.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedDeviceUserMappingsIDs(); len(nodes) > 0 && !_u.mutation.DeviceUserMappingsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceUserMappingsTable,
			Columns: []string{user.DeviceUserMappingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(deviceusermapping.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.DeviceUserMappingsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceUserMappingsTable,
			Columns: []string{user.DeviceUserMappingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(deviceusermapping.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SudoSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SudoSessionsTable,
			Columns: []string{user.SudoSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sudosession.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSudoSessionsIDs(); len(nodes) > 0 && !_u.mutation.SudoSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SudoSessionsTable,
			Columns: []string{user.SudoSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sudosession.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SudoSessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SudoSessionsTable,
			Columns: []string{user.SudoSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sudosession.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PrimaryBadgeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   user.PrimaryBadgeTable,
			Columns: []string{user.PrimaryBadgeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(badge.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PrimaryBadgeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   user.PrimaryBadgeTable,
			Columns: []string{user.PrimaryBadgeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(badge.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _node, err = sqlgraph.UpdateNodes(ctx, _u.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{user.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	_u.mutation.done = true
	return _node, nil
}

// UserUpdateOne is the builder for updating a single User entity.
type UserUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *UserMutation
}

// SetUpdatedAt sets the "updated_at" field.
func (_u *UserUpdateOne) SetUpdatedAt(v time.Time) *UserUpdateOne {
	_u.mutation.SetUpdatedAt(v)
	return _u
}

// SetDeletedAt sets the "deleted_at" field.
func (_u *UserUpdateOne) SetDeletedAt(v time.Time) *UserUpdateOne {
	_u.mutation.SetDeletedAt(v)
	return _u
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableDeletedAt(v *time.Time) *UserUpdateOne {
	if v != nil {
		_u.SetDeletedAt(*v)
	}
	return _u
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (_u *UserUpdateOne) ClearDeletedAt() *UserUpdateOne {
	_u.mutation.ClearDeletedAt()
	return _u
}

// SetEmail sets the "email" field.
func (_u *UserUpdateOne) SetEmail(v string) *UserUpdateOne {
	_u.mutation.SetEmail(v)
	return _u
}

// SetNillableEmail sets the "email" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableEmail(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetEmail(*v)
	}
	return _u
}

// SetUsername sets the "username" field.
func (_u *UserUpdateOne) SetUsername(v string) *UserUpdateOne {
	_u.mutation.SetUsername(v)
	return _u
}

// SetNillableUsername sets the "username" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableUsername(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetUsername(*v)
	}
	return _u
}

// ClearUsername clears the value of the "username" field.
func (_u *UserUpdateOne) ClearUsername() *UserUpdateOne {
	_u.mutation.ClearUsername()
	return _u
}

// SetPasswordHash sets the "password_hash" field.
func (_u *UserUpdateOne) SetPasswordHash(v string) *UserUpdateOne {
	_u.mutation.SetPasswordHash(v)
	return _u
}

// SetNillablePasswordHash sets the "password_hash" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillablePasswordHash(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetPasswordHash(*v)
	}
	return _u
}

// SetEmailVerified sets the "email_verified" field.
func (_u *UserUpdateOne) SetEmailVerified(v bool) *UserUpdateOne {
	_u.mutation.SetEmailVerified(v)
	return _u
}

// SetNillableEmailVerified sets the "email_verified" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableEmailVerified(v *bool) *UserUpdateOne {
	if v != nil {
		_u.SetEmailVerified(*v)
	}
	return _u
}

// SetAvatarURL sets the "avatar_url" field.
func (_u *UserUpdateOne) SetAvatarURL(v string) *UserUpdateOne {
	_u.mutation.SetAvatarURL(v)
	return _u
}

// SetNillableAvatarURL sets the "avatar_url" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableAvatarURL(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetAvatarURL(*v)
	}
	return _u
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (_u *UserUpdateOne) ClearAvatarURL() *UserUpdateOne {
	_u.mutation.ClearAvatarURL()
	return _u
}

// SetFullName sets the "full_name" field.
func (_u *UserUpdateOne) SetFullName(v string) *UserUpdateOne {
	_u.mutation.SetFullName(v)
	return _u
}

// SetNillableFullName sets the "full_name" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableFullName(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetFullName(*v)
	}
	return _u
}

// ClearFullName clears the value of the "full_name" field.
func (_u *UserUpdateOne) ClearFullName() *UserUpdateOne {
	_u.mutation.ClearFullName()
	return _u
}

// SetBio sets the "bio" field.
func (_u *UserUpdateOne) SetBio(v string) *UserUpdateOne {
	_u.mutation.SetBio(v)
	return _u
}

// SetNillableBio sets the "bio" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableBio(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetBio(*v)
	}
	return _u
}

// ClearBio clears the value of the "bio" field.
func (_u *UserUpdateOne) ClearBio() *UserUpdateOne {
	_u.mutation.ClearBio()
	return _u
}

// SetPronouns sets the "pronouns" field.
func (_u *UserUpdateOne) SetPronouns(v string) *UserUpdateOne {
	_u.mutation.SetPronouns(v)
	return _u
}

// SetNillablePronouns sets the "pronouns" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillablePronouns(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetPronouns(*v)
	}
	return _u
}

// ClearPronouns clears the value of the "pronouns" field.
func (_u *UserUpdateOne) ClearPronouns() *UserUpdateOne {
	_u.mutation.ClearPronouns()
	return _u
}

// SetCompany sets the "company" field.
func (_u *UserUpdateOne) SetCompany(v string) *UserUpdateOne {
	_u.mutation.SetCompany(v)
	return _u
}

// SetNillableCompany sets the "company" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableCompany(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetCompany(*v)
	}
	return _u
}

// ClearCompany clears the value of the "company" field.
func (_u *UserUpdateOne) ClearCompany() *UserUpdateOne {
	_u.mutation.ClearCompany()
	return _u
}

// SetTelegram sets the "telegram" field.
func (_u *UserUpdateOne) SetTelegram(v string) *UserUpdateOne {
	_u.mutation.SetTelegram(v)
	return _u
}

// SetNillableTelegram sets the "telegram" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableTelegram(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetTelegram(*v)
	}
	return _u
}

// ClearTelegram clears the value of the "telegram" field.
func (_u *UserUpdateOne) ClearTelegram() *UserUpdateOne {
	_u.mutation.ClearTelegram()
	return _u
}

// SetSocialAccounts sets the "social_accounts" field.
func (_u *UserUpdateOne) SetSocialAccounts(v map[string]interface{}) *UserUpdateOne {
	_u.mutation.SetSocialAccounts(v)
	return _u
}

// ClearSocialAccounts clears the value of the "social_accounts" field.
func (_u *UserUpdateOne) ClearSocialAccounts() *UserUpdateOne {
	_u.mutation.ClearSocialAccounts()
	return _u
}

// SetPrimaryBadgeID sets the "primary_badge_id" field.
func (_u *UserUpdateOne) SetPrimaryBadgeID(v int) *UserUpdateOne {
	_u.mutation.SetPrimaryBadgeID(v)
	return _u
}

// SetNillablePrimaryBadgeID sets the "primary_badge_id" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillablePrimaryBadgeID(v *int) *UserUpdateOne {
	if v != nil {
		_u.SetPrimaryBadgeID(*v)
	}
	return _u
}

// ClearPrimaryBadgeID clears the value of the "primary_badge_id" field.
func (_u *UserUpdateOne) ClearPrimaryBadgeID() *UserUpdateOne {
	_u.mutation.ClearPrimaryBadgeID()
	return _u
}

// SetTotpSecret sets the "totp_secret" field.
func (_u *UserUpdateOne) SetTotpSecret(v string) *UserUpdateOne {
	_u.mutation.SetTotpSecret(v)
	return _u
}

// SetNillableTotpSecret sets the "totp_secret" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableTotpSecret(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetTotpSecret(*v)
	}
	return _u
}

// ClearTotpSecret clears the value of the "totp_secret" field.
func (_u *UserUpdateOne) ClearTotpSecret() *UserUpdateOne {
	_u.mutation.ClearTotpSecret()
	return _u
}

// SetTotpEnabled sets the "totp_enabled" field.
func (_u *UserUpdateOne) SetTotpEnabled(v bool) *UserUpdateOne {
	_u.mutation.SetTotpEnabled(v)
	return _u
}

// SetNillableTotpEnabled sets the "totp_enabled" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableTotpEnabled(v *bool) *UserUpdateOne {
	if v != nil {
		_u.SetTotpEnabled(*v)
	}
	return _u
}

// SetTotpVerified sets the "totp_verified" field.
func (_u *UserUpdateOne) SetTotpVerified(v bool) *UserUpdateOne {
	_u.mutation.SetTotpVerified(v)
	return _u
}

// SetNillableTotpVerified sets the "totp_verified" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableTotpVerified(v *bool) *UserUpdateOne {
	if v != nil {
		_u.SetTotpVerified(*v)
	}
	return _u
}

// SetTotpVerifiedAt sets the "totp_verified_at" field.
func (_u *UserUpdateOne) SetTotpVerifiedAt(v time.Time) *UserUpdateOne {
	_u.mutation.SetTotpVerifiedAt(v)
	return _u
}

// SetNillableTotpVerifiedAt sets the "totp_verified_at" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableTotpVerifiedAt(v *time.Time) *UserUpdateOne {
	if v != nil {
		_u.SetTotpVerifiedAt(*v)
	}
	return _u
}

// ClearTotpVerifiedAt clears the value of the "totp_verified_at" field.
func (_u *UserUpdateOne) ClearTotpVerifiedAt() *UserUpdateOne {
	_u.mutation.ClearTotpVerifiedAt()
	return _u
}

// SetFailedLoginAttempts sets the "failed_login_attempts" field.
func (_u *UserUpdateOne) SetFailedLoginAttempts(v int) *UserUpdateOne {
	_u.mutation.ResetFailedLoginAttempts()
	_u.mutation.SetFailedLoginAttempts(v)
	return _u
}

// SetNillableFailedLoginAttempts sets the "failed_login_attempts" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableFailedLoginAttempts(v *int) *UserUpdateOne {
	if v != nil {
		_u.SetFailedLoginAttempts(*v)
	}
	return _u
}

// AddFailedLoginAttempts adds value to the "failed_login_attempts" field.
func (_u *UserUpdateOne) AddFailedLoginAttempts(v int) *UserUpdateOne {
	_u.mutation.AddFailedLoginAttempts(v)
	return _u
}

// SetLastFailedAt sets the "last_failed_at" field.
func (_u *UserUpdateOne) SetLastFailedAt(v time.Time) *UserUpdateOne {
	_u.mutation.SetLastFailedAt(v)
	return _u
}

// SetNillableLastFailedAt sets the "last_failed_at" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableLastFailedAt(v *time.Time) *UserUpdateOne {
	if v != nil {
		_u.SetLastFailedAt(*v)
	}
	return _u
}

// ClearLastFailedAt clears the value of the "last_failed_at" field.
func (_u *UserUpdateOne) ClearLastFailedAt() *UserUpdateOne {
	_u.mutation.ClearLastFailedAt()
	return _u
}

// SetLastLoginAt sets the "last_login_at" field.
func (_u *UserUpdateOne) SetLastLoginAt(v time.Time) *UserUpdateOne {
	_u.mutation.SetLastLoginAt(v)
	return _u
}

// SetNillableLastLoginAt sets the "last_login_at" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableLastLoginAt(v *time.Time) *UserUpdateOne {
	if v != nil {
		_u.SetLastLoginAt(*v)
	}
	return _u
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (_u *UserUpdateOne) ClearLastLoginAt() *UserUpdateOne {
	_u.mutation.ClearLastLoginAt()
	return _u
}

// SetLastLoginIP sets the "last_login_ip" field.
func (_u *UserUpdateOne) SetLastLoginIP(v string) *UserUpdateOne {
	_u.mutation.SetLastLoginIP(v)
	return _u
}

// SetNillableLastLoginIP sets the "last_login_ip" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableLastLoginIP(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetLastLoginIP(*v)
	}
	return _u
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (_u *UserUpdateOne) ClearLastLoginIP() *UserUpdateOne {
	_u.mutation.ClearLastLoginIP()
	return _u
}

// SetLockedUntil sets the "locked_until" field.
func (_u *UserUpdateOne) SetLockedUntil(v time.Time) *UserUpdateOne {
	_u.mutation.SetLockedUntil(v)
	return _u
}

// SetNillableLockedUntil sets the "locked_until" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableLockedUntil(v *time.Time) *UserUpdateOne {
	if v != nil {
		_u.SetLockedUntil(*v)
	}
	return _u
}

// ClearLockedUntil clears the value of the "locked_until" field.
func (_u *UserUpdateOne) ClearLockedUntil() *UserUpdateOne {
	_u.mutation.ClearLockedUntil()
	return _u
}

// SetLockReason sets the "lock_reason" field.
func (_u *UserUpdateOne) SetLockReason(v string) *UserUpdateOne {
	_u.mutation.SetLockReason(v)
	return _u
}

// SetNillableLockReason sets the "lock_reason" field if the given value is not nil.
func (_u *UserUpdateOne) SetNillableLockReason(v *string) *UserUpdateOne {
	if v != nil {
		_u.SetLockReason(*v)
	}
	return _u
}

// ClearLockReason clears the value of the "lock_reason" field.
func (_u *UserUpdateOne) ClearLockReason() *UserUpdateOne {
	_u.mutation.ClearLockReason()
	return _u
}

// AddPasskeyIDs adds the "passkeys" edge to the Passkey entity by IDs.
func (_u *UserUpdateOne) AddPasskeyIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddPasskeyIDs(ids...)
	return _u
}

// AddPasskeys adds the "passkeys" edges to the Passkey entity.
func (_u *UserUpdateOne) AddPasskeys(v ...*Passkey) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPasskeyIDs(ids...)
}

// AddSessionIDs adds the "sessions" edge to the Session entity by IDs.
func (_u *UserUpdateOne) AddSessionIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddSessionIDs(ids...)
	return _u
}

// AddSessions adds the "sessions" edges to the Session entity.
func (_u *UserUpdateOne) AddSessions(v ...*Session) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSessionIDs(ids...)
}

// AddBackupCodeIDs adds the "backup_codes" edge to the BackupCode entity by IDs.
func (_u *UserUpdateOne) AddBackupCodeIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddBackupCodeIDs(ids...)
	return _u
}

// AddBackupCodes adds the "backup_codes" edges to the BackupCode entity.
func (_u *UserUpdateOne) AddBackupCodes(v ...*BackupCode) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddBackupCodeIDs(ids...)
}

// AddThreadIDs adds the "threads" edge to the Thread entity by IDs.
func (_u *UserUpdateOne) AddThreadIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddThreadIDs(ids...)
	return _u
}

// AddThreads adds the "threads" edges to the Thread entity.
func (_u *UserUpdateOne) AddThreads(v ...*Thread) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddThreadIDs(ids...)
}

// AddUserBadgeIDs adds the "user_badges" edge to the UserBadge entity by IDs.
func (_u *UserUpdateOne) AddUserBadgeIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddUserBadgeIDs(ids...)
	return _u
}

// AddUserBadges adds the "user_badges" edges to the UserBadge entity.
func (_u *UserUpdateOne) AddUserBadges(v ...*UserBadge) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddUserBadgeIDs(ids...)
}

// AddSessionLockIDs adds the "session_locks" edge to the SessionLock entity by IDs.
func (_u *UserUpdateOne) AddSessionLockIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddSessionLockIDs(ids...)
	return _u
}

// AddSessionLocks adds the "session_locks" edges to the SessionLock entity.
func (_u *UserUpdateOne) AddSessionLocks(v ...*SessionLock) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSessionLockIDs(ids...)
}

// AddEmailVerificationTokenIDs adds the "email_verification_tokens" edge to the EmailVerificationToken entity by IDs.
func (_u *UserUpdateOne) AddEmailVerificationTokenIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddEmailVerificationTokenIDs(ids...)
	return _u
}

// AddEmailVerificationTokens adds the "email_verification_tokens" edges to the EmailVerificationToken entity.
func (_u *UserUpdateOne) AddEmailVerificationTokens(v ...*EmailVerificationToken) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddEmailVerificationTokenIDs(ids...)
}

// AddPasswordResetTokenIDs adds the "password_reset_tokens" edge to the PasswordResetToken entity by IDs.
func (_u *UserUpdateOne) AddPasswordResetTokenIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddPasswordResetTokenIDs(ids...)
	return _u
}

// AddPasswordResetTokens adds the "password_reset_tokens" edges to the PasswordResetToken entity.
func (_u *UserUpdateOne) AddPasswordResetTokens(v ...*PasswordResetToken) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddPasswordResetTokenIDs(ids...)
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by IDs.
func (_u *UserUpdateOne) AddCredentialIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddCredentialIDs(ids...)
	return _u
}

// AddCredentials adds the "credentials" edges to the Credential entity.
func (_u *UserUpdateOne) AddCredentials(v ...*Credential) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddCredentialIDs(ids...)
}

// AddTotpPendingTokenIDs adds the "totp_pending_tokens" edge to the TOTPPendingToken entity by IDs.
func (_u *UserUpdateOne) AddTotpPendingTokenIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddTotpPendingTokenIDs(ids...)
	return _u
}

// AddTotpPendingTokens adds the "totp_pending_tokens" edges to the TOTPPendingToken entity.
func (_u *UserUpdateOne) AddTotpPendingTokens(v ...*TOTPPendingToken) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddTotpPendingTokenIDs(ids...)
}

// AddSecurityEventIDs adds the "security_events" edge to the SecurityEvent entity by IDs.
func (_u *UserUpdateOne) AddSecurityEventIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddSecurityEventIDs(ids...)
	return _u
}

// AddSecurityEvents adds the "security_events" edges to the SecurityEvent entity.
func (_u *UserUpdateOne) AddSecurityEvents(v ...*SecurityEvent) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSecurityEventIDs(ids...)
}

// AddDeviceFingerprintIDs adds the "device_fingerprints" edge to the DeviceFingerprint entity by IDs.
func (_u *UserUpdateOne) AddDeviceFingerprintIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddDeviceFingerprintIDs(ids...)
	return _u
}

// AddDeviceFingerprints adds the "device_fingerprints" edges to the DeviceFingerprint entity.
func (_u *UserUpdateOne) AddDeviceFingerprints(v ...*DeviceFingerprint) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddDeviceFingerprintIDs(ids...)
}

// AddDeviceUserMappingIDs adds the "device_user_mappings" edge to the DeviceUserMapping entity by IDs.
func (_u *UserUpdateOne) AddDeviceUserMappingIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddDeviceUserMappingIDs(ids...)
	return _u
}

// AddDeviceUserMappings adds the "device_user_mappings" edges to the DeviceUserMapping entity.
func (_u *UserUpdateOne) AddDeviceUserMappings(v ...*DeviceUserMapping) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddDeviceUserMappingIDs(ids...)
}

// AddSudoSessionIDs adds the "sudo_sessions" edge to the SudoSession entity by IDs.
func (_u *UserUpdateOne) AddSudoSessionIDs(ids ...int) *UserUpdateOne {
	_u.mutation.AddSudoSessionIDs(ids...)
	return _u
}

// AddSudoSessions adds the "sudo_sessions" edges to the SudoSession entity.
func (_u *UserUpdateOne) AddSudoSessions(v ...*SudoSession) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.AddSudoSessionIDs(ids...)
}

// SetPrimaryBadge sets the "primary_badge" edge to the Badge entity.
func (_u *UserUpdateOne) SetPrimaryBadge(v *Badge) *UserUpdateOne {
	return _u.SetPrimaryBadgeID(v.ID)
}

// Mutation returns the UserMutation object of the builder.
func (_u *UserUpdateOne) Mutation() *UserMutation {
	return _u.mutation
}

// ClearPasskeys clears all "passkeys" edges to the Passkey entity.
func (_u *UserUpdateOne) ClearPasskeys() *UserUpdateOne {
	_u.mutation.ClearPasskeys()
	return _u
}

// RemovePasskeyIDs removes the "passkeys" edge to Passkey entities by IDs.
func (_u *UserUpdateOne) RemovePasskeyIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemovePasskeyIDs(ids...)
	return _u
}

// RemovePasskeys removes "passkeys" edges to Passkey entities.
func (_u *UserUpdateOne) RemovePasskeys(v ...*Passkey) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePasskeyIDs(ids...)
}

// ClearSessions clears all "sessions" edges to the Session entity.
func (_u *UserUpdateOne) ClearSessions() *UserUpdateOne {
	_u.mutation.ClearSessions()
	return _u
}

// RemoveSessionIDs removes the "sessions" edge to Session entities by IDs.
func (_u *UserUpdateOne) RemoveSessionIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveSessionIDs(ids...)
	return _u
}

// RemoveSessions removes "sessions" edges to Session entities.
func (_u *UserUpdateOne) RemoveSessions(v ...*Session) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSessionIDs(ids...)
}

// ClearBackupCodes clears all "backup_codes" edges to the BackupCode entity.
func (_u *UserUpdateOne) ClearBackupCodes() *UserUpdateOne {
	_u.mutation.ClearBackupCodes()
	return _u
}

// RemoveBackupCodeIDs removes the "backup_codes" edge to BackupCode entities by IDs.
func (_u *UserUpdateOne) RemoveBackupCodeIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveBackupCodeIDs(ids...)
	return _u
}

// RemoveBackupCodes removes "backup_codes" edges to BackupCode entities.
func (_u *UserUpdateOne) RemoveBackupCodes(v ...*BackupCode) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveBackupCodeIDs(ids...)
}

// ClearThreads clears all "threads" edges to the Thread entity.
func (_u *UserUpdateOne) ClearThreads() *UserUpdateOne {
	_u.mutation.ClearThreads()
	return _u
}

// RemoveThreadIDs removes the "threads" edge to Thread entities by IDs.
func (_u *UserUpdateOne) RemoveThreadIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveThreadIDs(ids...)
	return _u
}

// RemoveThreads removes "threads" edges to Thread entities.
func (_u *UserUpdateOne) RemoveThreads(v ...*Thread) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveThreadIDs(ids...)
}

// ClearUserBadges clears all "user_badges" edges to the UserBadge entity.
func (_u *UserUpdateOne) ClearUserBadges() *UserUpdateOne {
	_u.mutation.ClearUserBadges()
	return _u
}

// RemoveUserBadgeIDs removes the "user_badges" edge to UserBadge entities by IDs.
func (_u *UserUpdateOne) RemoveUserBadgeIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveUserBadgeIDs(ids...)
	return _u
}

// RemoveUserBadges removes "user_badges" edges to UserBadge entities.
func (_u *UserUpdateOne) RemoveUserBadges(v ...*UserBadge) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveUserBadgeIDs(ids...)
}

// ClearSessionLocks clears all "session_locks" edges to the SessionLock entity.
func (_u *UserUpdateOne) ClearSessionLocks() *UserUpdateOne {
	_u.mutation.ClearSessionLocks()
	return _u
}

// RemoveSessionLockIDs removes the "session_locks" edge to SessionLock entities by IDs.
func (_u *UserUpdateOne) RemoveSessionLockIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveSessionLockIDs(ids...)
	return _u
}

// RemoveSessionLocks removes "session_locks" edges to SessionLock entities.
func (_u *UserUpdateOne) RemoveSessionLocks(v ...*SessionLock) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSessionLockIDs(ids...)
}

// ClearEmailVerificationTokens clears all "email_verification_tokens" edges to the EmailVerificationToken entity.
func (_u *UserUpdateOne) ClearEmailVerificationTokens() *UserUpdateOne {
	_u.mutation.ClearEmailVerificationTokens()
	return _u
}

// RemoveEmailVerificationTokenIDs removes the "email_verification_tokens" edge to EmailVerificationToken entities by IDs.
func (_u *UserUpdateOne) RemoveEmailVerificationTokenIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveEmailVerificationTokenIDs(ids...)
	return _u
}

// RemoveEmailVerificationTokens removes "email_verification_tokens" edges to EmailVerificationToken entities.
func (_u *UserUpdateOne) RemoveEmailVerificationTokens(v ...*EmailVerificationToken) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveEmailVerificationTokenIDs(ids...)
}

// ClearPasswordResetTokens clears all "password_reset_tokens" edges to the PasswordResetToken entity.
func (_u *UserUpdateOne) ClearPasswordResetTokens() *UserUpdateOne {
	_u.mutation.ClearPasswordResetTokens()
	return _u
}

// RemovePasswordResetTokenIDs removes the "password_reset_tokens" edge to PasswordResetToken entities by IDs.
func (_u *UserUpdateOne) RemovePasswordResetTokenIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemovePasswordResetTokenIDs(ids...)
	return _u
}

// RemovePasswordResetTokens removes "password_reset_tokens" edges to PasswordResetToken entities.
func (_u *UserUpdateOne) RemovePasswordResetTokens(v ...*PasswordResetToken) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemovePasswordResetTokenIDs(ids...)
}

// ClearCredentials clears all "credentials" edges to the Credential entity.
func (_u *UserUpdateOne) ClearCredentials() *UserUpdateOne {
	_u.mutation.ClearCredentials()
	return _u
}

// RemoveCredentialIDs removes the "credentials" edge to Credential entities by IDs.
func (_u *UserUpdateOne) RemoveCredentialIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveCredentialIDs(ids...)
	return _u
}

// RemoveCredentials removes "credentials" edges to Credential entities.
func (_u *UserUpdateOne) RemoveCredentials(v ...*Credential) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveCredentialIDs(ids...)
}

// ClearTotpPendingTokens clears all "totp_pending_tokens" edges to the TOTPPendingToken entity.
func (_u *UserUpdateOne) ClearTotpPendingTokens() *UserUpdateOne {
	_u.mutation.ClearTotpPendingTokens()
	return _u
}

// RemoveTotpPendingTokenIDs removes the "totp_pending_tokens" edge to TOTPPendingToken entities by IDs.
func (_u *UserUpdateOne) RemoveTotpPendingTokenIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveTotpPendingTokenIDs(ids...)
	return _u
}

// RemoveTotpPendingTokens removes "totp_pending_tokens" edges to TOTPPendingToken entities.
func (_u *UserUpdateOne) RemoveTotpPendingTokens(v ...*TOTPPendingToken) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveTotpPendingTokenIDs(ids...)
}

// ClearSecurityEvents clears all "security_events" edges to the SecurityEvent entity.
func (_u *UserUpdateOne) ClearSecurityEvents() *UserUpdateOne {
	_u.mutation.ClearSecurityEvents()
	return _u
}

// RemoveSecurityEventIDs removes the "security_events" edge to SecurityEvent entities by IDs.
func (_u *UserUpdateOne) RemoveSecurityEventIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveSecurityEventIDs(ids...)
	return _u
}

// RemoveSecurityEvents removes "security_events" edges to SecurityEvent entities.
func (_u *UserUpdateOne) RemoveSecurityEvents(v ...*SecurityEvent) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSecurityEventIDs(ids...)
}

// ClearDeviceFingerprints clears all "device_fingerprints" edges to the DeviceFingerprint entity.
func (_u *UserUpdateOne) ClearDeviceFingerprints() *UserUpdateOne {
	_u.mutation.ClearDeviceFingerprints()
	return _u
}

// RemoveDeviceFingerprintIDs removes the "device_fingerprints" edge to DeviceFingerprint entities by IDs.
func (_u *UserUpdateOne) RemoveDeviceFingerprintIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveDeviceFingerprintIDs(ids...)
	return _u
}

// RemoveDeviceFingerprints removes "device_fingerprints" edges to DeviceFingerprint entities.
func (_u *UserUpdateOne) RemoveDeviceFingerprints(v ...*DeviceFingerprint) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveDeviceFingerprintIDs(ids...)
}

// ClearDeviceUserMappings clears all "device_user_mappings" edges to the DeviceUserMapping entity.
func (_u *UserUpdateOne) ClearDeviceUserMappings() *UserUpdateOne {
	_u.mutation.ClearDeviceUserMappings()
	return _u
}

// RemoveDeviceUserMappingIDs removes the "device_user_mappings" edge to DeviceUserMapping entities by IDs.
func (_u *UserUpdateOne) RemoveDeviceUserMappingIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveDeviceUserMappingIDs(ids...)
	return _u
}

// RemoveDeviceUserMappings removes "device_user_mappings" edges to DeviceUserMapping entities.
func (_u *UserUpdateOne) RemoveDeviceUserMappings(v ...*DeviceUserMapping) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveDeviceUserMappingIDs(ids...)
}

// ClearSudoSessions clears all "sudo_sessions" edges to the SudoSession entity.
func (_u *UserUpdateOne) ClearSudoSessions() *UserUpdateOne {
	_u.mutation.ClearSudoSessions()
	return _u
}

// RemoveSudoSessionIDs removes the "sudo_sessions" edge to SudoSession entities by IDs.
func (_u *UserUpdateOne) RemoveSudoSessionIDs(ids ...int) *UserUpdateOne {
	_u.mutation.RemoveSudoSessionIDs(ids...)
	return _u
}

// RemoveSudoSessions removes "sudo_sessions" edges to SudoSession entities.
func (_u *UserUpdateOne) RemoveSudoSessions(v ...*SudoSession) *UserUpdateOne {
	ids := make([]int, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _u.RemoveSudoSessionIDs(ids...)
}

// ClearPrimaryBadge clears the "primary_badge" edge to the Badge entity.
func (_u *UserUpdateOne) ClearPrimaryBadge() *UserUpdateOne {
	_u.mutation.ClearPrimaryBadge()
	return _u
}

// Where appends a list predicates to the UserUpdate builder.
func (_u *UserUpdateOne) Where(ps ...predicate.User) *UserUpdateOne {
	_u.mutation.Where(ps...)
	return _u
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (_u *UserUpdateOne) Select(field string, fields ...string) *UserUpdateOne {
	_u.fields = append([]string{field}, fields...)
	return _u
}

// Save executes the query and returns the updated User entity.
func (_u *UserUpdateOne) Save(ctx context.Context) (*User, error) {
	_u.defaults()
	return withHooks(ctx, _u.sqlSave, _u.mutation, _u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (_u *UserUpdateOne) SaveX(ctx context.Context) *User {
	node, err := _u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (_u *UserUpdateOne) Exec(ctx context.Context) error {
	_, err := _u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (_u *UserUpdateOne) ExecX(ctx context.Context) {
	if err := _u.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (_u *UserUpdateOne) defaults() {
	if _, ok := _u.mutation.UpdatedAt(); !ok {
		v := user.UpdateDefaultUpdatedAt()
		_u.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (_u *UserUpdateOne) check() error {
	if v, ok := _u.mutation.Email(); ok {
		if err := user.EmailValidator(v); err != nil {
			return &ValidationError{Name: "email", err: fmt.Errorf(`ent: validator failed for field "User.email": %w`, err)}
		}
	}
	if v, ok := _u.mutation.PasswordHash(); ok {
		if err := user.PasswordHashValidator(v); err != nil {
			return &ValidationError{Name: "password_hash", err: fmt.Errorf(`ent: validator failed for field "User.password_hash": %w`, err)}
		}
	}
	if v, ok := _u.mutation.LastLoginIP(); ok {
		if err := user.LastLoginIPValidator(v); err != nil {
			return &ValidationError{Name: "last_login_ip", err: fmt.Errorf(`ent: validator failed for field "User.last_login_ip": %w`, err)}
		}
	}
	if v, ok := _u.mutation.LockReason(); ok {
		if err := user.LockReasonValidator(v); err != nil {
			return &ValidationError{Name: "lock_reason", err: fmt.Errorf(`ent: validator failed for field "User.lock_reason": %w`, err)}
		}
	}
	return nil
}

func (_u *UserUpdateOne) sqlSave(ctx context.Context) (_node *User, err error) {
	if err := _u.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeInt))
	id, ok := _u.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "User.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := _u.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
		for _, f := range fields {
			if !user.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != user.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := _u.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := _u.mutation.UpdatedAt(); ok {
		_spec.SetField(user.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := _u.mutation.DeletedAt(); ok {
		_spec.SetField(user.FieldDeletedAt, field.TypeTime, value)
	}
	if _u.mutation.DeletedAtCleared() {
		_spec.ClearField(user.FieldDeletedAt, field.TypeTime)
	}
	if value, ok := _u.mutation.Email(); ok {
		_spec.SetField(user.FieldEmail, field.TypeString, value)
	}
	if value, ok := _u.mutation.Username(); ok {
		_spec.SetField(user.FieldUsername, field.TypeString, value)
	}
	if _u.mutation.UsernameCleared() {
		_spec.ClearField(user.FieldUsername, field.TypeString)
	}
	if value, ok := _u.mutation.PasswordHash(); ok {
		_spec.SetField(user.FieldPasswordHash, field.TypeString, value)
	}
	if value, ok := _u.mutation.EmailVerified(); ok {
		_spec.SetField(user.FieldEmailVerified, field.TypeBool, value)
	}
	if value, ok := _u.mutation.AvatarURL(); ok {
		_spec.SetField(user.FieldAvatarURL, field.TypeString, value)
	}
	if _u.mutation.AvatarURLCleared() {
		_spec.ClearField(user.FieldAvatarURL, field.TypeString)
	}
	if value, ok := _u.mutation.FullName(); ok {
		_spec.SetField(user.FieldFullName, field.TypeString, value)
	}
	if _u.mutation.FullNameCleared() {
		_spec.ClearField(user.FieldFullName, field.TypeString)
	}
	if value, ok := _u.mutation.Bio(); ok {
		_spec.SetField(user.FieldBio, field.TypeString, value)
	}
	if _u.mutation.BioCleared() {
		_spec.ClearField(user.FieldBio, field.TypeString)
	}
	if value, ok := _u.mutation.Pronouns(); ok {
		_spec.SetField(user.FieldPronouns, field.TypeString, value)
	}
	if _u.mutation.PronounsCleared() {
		_spec.ClearField(user.FieldPronouns, field.TypeString)
	}
	if value, ok := _u.mutation.Company(); ok {
		_spec.SetField(user.FieldCompany, field.TypeString, value)
	}
	if _u.mutation.CompanyCleared() {
		_spec.ClearField(user.FieldCompany, field.TypeString)
	}
	if value, ok := _u.mutation.Telegram(); ok {
		_spec.SetField(user.FieldTelegram, field.TypeString, value)
	}
	if _u.mutation.TelegramCleared() {
		_spec.ClearField(user.FieldTelegram, field.TypeString)
	}
	if value, ok := _u.mutation.SocialAccounts(); ok {
		_spec.SetField(user.FieldSocialAccounts, field.TypeJSON, value)
	}
	if _u.mutation.SocialAccountsCleared() {
		_spec.ClearField(user.FieldSocialAccounts, field.TypeJSON)
	}
	if value, ok := _u.mutation.TotpSecret(); ok {
		_spec.SetField(user.FieldTotpSecret, field.TypeString, value)
	}
	if _u.mutation.TotpSecretCleared() {
		_spec.ClearField(user.FieldTotpSecret, field.TypeString)
	}
	if value, ok := _u.mutation.TotpEnabled(); ok {
		_spec.SetField(user.FieldTotpEnabled, field.TypeBool, value)
	}
	if value, ok := _u.mutation.TotpVerified(); ok {
		_spec.SetField(user.FieldTotpVerified, field.TypeBool, value)
	}
	if value, ok := _u.mutation.TotpVerifiedAt(); ok {
		_spec.SetField(user.FieldTotpVerifiedAt, field.TypeTime, value)
	}
	if _u.mutation.TotpVerifiedAtCleared() {
		_spec.ClearField(user.FieldTotpVerifiedAt, field.TypeTime)
	}
	if value, ok := _u.mutation.FailedLoginAttempts(); ok {
		_spec.SetField(user.FieldFailedLoginAttempts, field.TypeInt, value)
	}
	if value, ok := _u.mutation.AddedFailedLoginAttempts(); ok {
		_spec.AddField(user.FieldFailedLoginAttempts, field.TypeInt, value)
	}
	if value, ok := _u.mutation.LastFailedAt(); ok {
		_spec.SetField(user.FieldLastFailedAt, field.TypeTime, value)
	}
	if _u.mutation.LastFailedAtCleared() {
		_spec.ClearField(user.FieldLastFailedAt, field.TypeTime)
	}
	if value, ok := _u.mutation.LastLoginAt(); ok {
		_spec.SetField(user.FieldLastLoginAt, field.TypeTime, value)
	}
	if _u.mutation.LastLoginAtCleared() {
		_spec.ClearField(user.FieldLastLoginAt, field.TypeTime)
	}
	if value, ok := _u.mutation.LastLoginIP(); ok {
		_spec.SetField(user.FieldLastLoginIP, field.TypeString, value)
	}
	if _u.mutation.LastLoginIPCleared() {
		_spec.ClearField(user.FieldLastLoginIP, field.TypeString)
	}
	if value, ok := _u.mutation.LockedUntil(); ok {
		_spec.SetField(user.FieldLockedUntil, field.TypeTime, value)
	}
	if _u.mutation.LockedUntilCleared() {
		_spec.ClearField(user.FieldLockedUntil, field.TypeTime)
	}
	if value, ok := _u.mutation.LockReason(); ok {
		_spec.SetField(user.FieldLockReason, field.TypeString, value)
	}
	if _u.mutation.LockReasonCleared() {
		_spec.ClearField(user.FieldLockReason, field.TypeString)
	}
	if _u.mutation.PasskeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasskeysTable,
			Columns: []string{user.PasskeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passkey.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPasskeysIDs(); len(nodes) > 0 && !_u.mutation.PasskeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasskeysTable,
			Columns: []string{user.PasskeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passkey.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PasskeysIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasskeysTable,
			Columns: []string{user.PasskeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passkey.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionsTable,
			Columns: []string{user.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSessionsIDs(); len(nodes) > 0 && !_u.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionsTable,
			Columns: []string{user.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionsTable,
			Columns: []string{user.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(session.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.BackupCodesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.BackupCodesTable,
			Columns: []string{user.BackupCodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(backupcode.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedBackupCodesIDs(); len(nodes) > 0 && !_u.mutation.BackupCodesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.BackupCodesTable,
			Columns: []string{user.BackupCodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(backupcode.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.BackupCodesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.BackupCodesTable,
			Columns: []string{user.BackupCodesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(backupcode.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.ThreadsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ThreadsTable,
			Columns: []string{user.ThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(thread.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedThreadsIDs(); len(nodes) > 0 && !_u.mutation.ThreadsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ThreadsTable,
			Columns: []string{user.ThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(thread.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.ThreadsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ThreadsTable,
			Columns: []string{user.ThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(thread.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.UserBadgesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserBadgesTable,
			Columns: []string{user.UserBadgesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(userbadge.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedUserBadgesIDs(); len(nodes) > 0 && !_u.mutation.UserBadgesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserBadgesTable,
			Columns: []string{user.UserBadgesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(userbadge.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.UserBadgesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserBadgesTable,
			Columns: []string{user.UserBadgesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(userbadge.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SessionLocksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionLocksTable,
			Columns: []string{user.SessionLocksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sessionlock.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSessionLocksIDs(); len(nodes) > 0 && !_u.mutation.SessionLocksCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionLocksTable,
			Columns: []string{user.SessionLocksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sessionlock.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SessionLocksIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SessionLocksTable,
			Columns: []string{user.SessionLocksColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sessionlock.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.EmailVerificationTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.EmailVerificationTokensTable,
			Columns: []string{user.EmailVerificationTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(emailverificationtoken.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedEmailVerificationTokensIDs(); len(nodes) > 0 && !_u.mutation.EmailVerificationTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.EmailVerificationTokensTable,
			Columns: []string{user.EmailVerificationTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(emailverificationtoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.EmailVerificationTokensIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.EmailVerificationTokensTable,
			Columns: []string{user.EmailVerificationTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(emailverificationtoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PasswordResetTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasswordResetTokensTable,
			Columns: []string{user.PasswordResetTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passwordresettoken.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedPasswordResetTokensIDs(); len(nodes) > 0 && !_u.mutation.PasswordResetTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasswordResetTokensTable,
			Columns: []string{user.PasswordResetTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passwordresettoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PasswordResetTokensIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PasswordResetTokensTable,
			Columns: []string{user.PasswordResetTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(passwordresettoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.CredentialsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CredentialsTable,
			Columns: []string{user.CredentialsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(credential.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedCredentialsIDs(); len(nodes) > 0 && !_u.mutation.CredentialsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CredentialsTable,
			Columns: []string{user.CredentialsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(credential.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.CredentialsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CredentialsTable,
			Columns: []string{user.CredentialsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(credential.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.TotpPendingTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TotpPendingTokensTable,
			Columns: []string{user.TotpPendingTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(totppendingtoken.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedTotpPendingTokensIDs(); len(nodes) > 0 && !_u.mutation.TotpPendingTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TotpPendingTokensTable,
			Columns: []string{user.TotpPendingTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(totppendingtoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.TotpPendingTokensIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TotpPendingTokensTable,
			Columns: []string{user.TotpPendingTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(totppendingtoken.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SecurityEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SecurityEventsTable,
			Columns: []string{user.SecurityEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(securityevent.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSecurityEventsIDs(); len(nodes) > 0 && !_u.mutation.SecurityEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SecurityEventsTable,
			Columns: []string{user.SecurityEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(securityevent.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SecurityEventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SecurityEventsTable,
			Columns: []string{user.SecurityEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(securityevent.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.DeviceFingerprintsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceFingerprintsTable,
			Columns: []string{user.DeviceFingerprintsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(devicefingerprint.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedDeviceFingerprintsIDs(); len(nodes) > 0 && !_u.mutation.DeviceFingerprintsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceFingerprintsTable,
			Columns: []string{user.DeviceFingerprintsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(devicefingerprint.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.DeviceFingerprintsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceFingerprintsTable,
			Columns: []string{user.DeviceFingerprintsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(devicefingerprint.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.DeviceUserMappingsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceUserMappingsTable,
			Columns: []string{user.DeviceUserMappingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(deviceusermapping.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedDeviceUserMappingsIDs(); len(nodes) > 0 && !_u.mutation.DeviceUserMappingsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceUserMappingsTable,
			Columns: []string{user.DeviceUserMappingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(deviceusermapping.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.DeviceUserMappingsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceUserMappingsTable,
			Columns: []string{user.DeviceUserMappingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(deviceusermapping.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.SudoSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SudoSessionsTable,
			Columns: []string{user.SudoSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sudosession.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.RemovedSudoSessionsIDs(); len(nodes) > 0 && !_u.mutation.SudoSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SudoSessionsTable,
			Columns: []string{user.SudoSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sudosession.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.SudoSessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SudoSessionsTable,
			Columns: []string{user.SudoSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sudosession.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if _u.mutation.PrimaryBadgeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   user.PrimaryBadgeTable,
			Columns: []string{user.PrimaryBadgeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(badge.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := _u.mutation.PrimaryBadgeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   user.PrimaryBadgeTable,
			Columns: []string{user.PrimaryBadgeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(badge.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &User{config: _u.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, _u.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{user.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	_u.mutation.done = true
	return _node, nil
}
