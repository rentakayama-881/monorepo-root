// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend-gin/ent/admin"
	"backend-gin/ent/artifactsubmission"
	"backend-gin/ent/backupcode"
	"backend-gin/ent/badge"
	"backend-gin/ent/category"
	"backend-gin/ent/chaincursor"
	"backend-gin/ent/consultationrequest"
	"backend-gin/ent/credential"
	"backend-gin/ent/devicefingerprint"
	"backend-gin/ent/deviceusermapping"
	"backend-gin/ent/emailverificationtoken"
	"backend-gin/ent/endorsement"
	"backend-gin/ent/finaloffer"
	"backend-gin/ent/ipgeocache"
	"backend-gin/ent/passkey"
	"backend-gin/ent/passwordresettoken"
	"backend-gin/ent/predicate"
	"backend-gin/ent/securityevent"
	"backend-gin/ent/session"
	"backend-gin/ent/sessionlock"
	"backend-gin/ent/sudosession"
	"backend-gin/ent/tag"
	"backend-gin/ent/totppendingtoken"
	"backend-gin/ent/user"
	"backend-gin/ent/userbadge"
	"backend-gin/ent/validationcase"
	"backend-gin/ent/validationcaselog"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdmin                  = "Admin"
	TypeArtifactSubmission     = "ArtifactSubmission"
	TypeBackupCode             = "BackupCode"
	TypeBadge                  = "Badge"
	TypeCategory               = "Category"
	TypeChainCursor            = "ChainCursor"
	TypeConsultationRequest    = "ConsultationRequest"
	TypeCredential             = "Credential"
	TypeDeviceFingerprint      = "DeviceFingerprint"
	TypeDeviceUserMapping      = "DeviceUserMapping"
	TypeEmailVerificationToken = "EmailVerificationToken"
	TypeEndorsement            = "Endorsement"
	TypeFinalOffer             = "FinalOffer"
	TypeIPGeoCache             = "IPGeoCache"
	TypePasskey                = "Passkey"
	TypePasswordResetToken     = "PasswordResetToken"
	TypeSecurityEvent          = "SecurityEvent"
	TypeSession                = "Session"
	TypeSessionLock            = "SessionLock"
	TypeSudoSession            = "SudoSession"
	TypeTOTPPendingToken       = "TOTPPendingToken"
	TypeTag                    = "Tag"
	TypeUser                   = "User"
	TypeUserBadge              = "UserBadge"
	TypeValidationCase         = "ValidationCase"
	TypeValidationCaseLog      = "ValidationCaseLog"
)

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	email                 *string
	password_hash         *string
	name                  *string
	clearedFields         map[string]struct{}
	granted_badges        map[int]struct{}
	removedgranted_badges map[int]struct{}
	clearedgranted_badges bool
	done                  bool
	oldValue              func(context.Context) (*Admin, error)
	predicates            []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id int) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdminMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[admin.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdminMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[admin.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, admin.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *AdminMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AdminMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AdminMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *AdminMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *AdminMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *AdminMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetName sets the "name" field.
func (m *AdminMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdminMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AdminMutation) ResetName() {
	m.name = nil
}

// AddGrantedBadgeIDs adds the "granted_badges" edge to the UserBadge entity by ids.
func (m *AdminMutation) AddGrantedBadgeIDs(ids ...int) {
	if m.granted_badges == nil {
		m.granted_badges = make(map[int]struct{})
	}
	for i := range ids {
		m.granted_badges[ids[i]] = struct{}{}
	}
}

// ClearGrantedBadges clears the "granted_badges" edge to the UserBadge entity.
func (m *AdminMutation) ClearGrantedBadges() {
	m.clearedgranted_badges = true
}

// GrantedBadgesCleared reports if the "granted_badges" edge to the UserBadge entity was cleared.
func (m *AdminMutation) GrantedBadgesCleared() bool {
	return m.clearedgranted_badges
}

// RemoveGrantedBadgeIDs removes the "granted_badges" edge to the UserBadge entity by IDs.
func (m *AdminMutation) RemoveGrantedBadgeIDs(ids ...int) {
	if m.removedgranted_badges == nil {
		m.removedgranted_badges = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.granted_badges, ids[i])
		m.removedgranted_badges[ids[i]] = struct{}{}
	}
}

// RemovedGrantedBadges returns the removed IDs of the "granted_badges" edge to the UserBadge entity.
func (m *AdminMutation) RemovedGrantedBadgesIDs() (ids []int) {
	for id := range m.removedgranted_badges {
		ids = append(ids, id)
	}
	return
}

// GrantedBadgesIDs returns the "granted_badges" edge IDs in the mutation.
func (m *AdminMutation) GrantedBadgesIDs() (ids []int) {
	for id := range m.granted_badges {
		ids = append(ids, id)
	}
	return
}

// ResetGrantedBadges resets all changes to the "granted_badges" edge.
func (m *AdminMutation) ResetGrantedBadges() {
	m.granted_badges = nil
	m.clearedgranted_badges = false
	m.removedgranted_badges = nil
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Admin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, admin.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, admin.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, admin.FieldPasswordHash)
	}
	if m.name != nil {
		fields = append(fields, admin.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	case admin.FieldDeletedAt:
		return m.DeletedAt()
	case admin.FieldEmail:
		return m.Email()
	case admin.FieldPasswordHash:
		return m.PasswordHash()
	case admin.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case admin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case admin.FieldEmail:
		return m.OldEmail(ctx)
	case admin.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case admin.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case admin.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case admin.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case admin.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case admin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(admin.FieldDeletedAt) {
		fields = append(fields, admin.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	switch name {
	case admin.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case admin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case admin.FieldEmail:
		m.ResetEmail()
		return nil
	case admin.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case admin.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.granted_badges != nil {
		edges = append(edges, admin.EdgeGrantedBadges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeGrantedBadges:
		ids := make([]ent.Value, 0, len(m.granted_badges))
		for id := range m.granted_badges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgranted_badges != nil {
		edges = append(edges, admin.EdgeGrantedBadges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeGrantedBadges:
		ids := make([]ent.Value, 0, len(m.removedgranted_badges))
		for id := range m.removedgranted_badges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgranted_badges {
		edges = append(edges, admin.EdgeGrantedBadges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeGrantedBadges:
		return m.clearedgranted_badges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeGrantedBadges:
		m.ResetGrantedBadges()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// ArtifactSubmissionMutation represents an operation that mutates the ArtifactSubmission nodes in the graph.
type ArtifactSubmissionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	document_id            *string
	clearedFields          map[string]struct{}
	validation_case        *int
	clearedvalidation_case bool
	validator_user         *int
	clearedvalidator_user  bool
	done                   bool
	oldValue               func(context.Context) (*ArtifactSubmission, error)
	predicates             []predicate.ArtifactSubmission
}

var _ ent.Mutation = (*ArtifactSubmissionMutation)(nil)

// artifactsubmissionOption allows management of the mutation configuration using functional options.
type artifactsubmissionOption func(*ArtifactSubmissionMutation)

// newArtifactSubmissionMutation creates new mutation for the ArtifactSubmission entity.
func newArtifactSubmissionMutation(c config, op Op, opts ...artifactsubmissionOption) *ArtifactSubmissionMutation {
	m := &ArtifactSubmissionMutation{
		config:        c,
		op:            op,
		typ:           TypeArtifactSubmission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtifactSubmissionID sets the ID field of the mutation.
func withArtifactSubmissionID(id int) artifactsubmissionOption {
	return func(m *ArtifactSubmissionMutation) {
		var (
			err   error
			once  sync.Once
			value *ArtifactSubmission
		)
		m.oldValue = func(ctx context.Context) (*ArtifactSubmission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ArtifactSubmission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtifactSubmission sets the old ArtifactSubmission of the mutation.
func withArtifactSubmission(node *ArtifactSubmission) artifactsubmissionOption {
	return func(m *ArtifactSubmissionMutation) {
		m.oldValue = func(context.Context) (*ArtifactSubmission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtifactSubmissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtifactSubmissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtifactSubmissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtifactSubmissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ArtifactSubmission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ArtifactSubmissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ArtifactSubmissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ArtifactSubmission entity.
// If the ArtifactSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactSubmissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ArtifactSubmissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ArtifactSubmissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ArtifactSubmissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ArtifactSubmission entity.
// If the ArtifactSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactSubmissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ArtifactSubmissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ArtifactSubmissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ArtifactSubmissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ArtifactSubmission entity.
// If the ArtifactSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactSubmissionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ArtifactSubmissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[artifactsubmission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ArtifactSubmissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[artifactsubmission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ArtifactSubmissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, artifactsubmission.FieldDeletedAt)
}

// SetValidationCaseID sets the "validation_case_id" field.
func (m *ArtifactSubmissionMutation) SetValidationCaseID(i int) {
	m.validation_case = &i
}

// ValidationCaseID returns the value of the "validation_case_id" field in the mutation.
func (m *ArtifactSubmissionMutation) ValidationCaseID() (r int, exists bool) {
	v := m.validation_case
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationCaseID returns the old "validation_case_id" field's value of the ArtifactSubmission entity.
// If the ArtifactSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactSubmissionMutation) OldValidationCaseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationCaseID: %w", err)
	}
	return oldValue.ValidationCaseID, nil
}

// ResetValidationCaseID resets all changes to the "validation_case_id" field.
func (m *ArtifactSubmissionMutation) ResetValidationCaseID() {
	m.validation_case = nil
}

// SetValidatorUserID sets the "validator_user_id" field.
func (m *ArtifactSubmissionMutation) SetValidatorUserID(i int) {
	m.validator_user = &i
}

// ValidatorUserID returns the value of the "validator_user_id" field in the mutation.
func (m *ArtifactSubmissionMutation) ValidatorUserID() (r int, exists bool) {
	v := m.validator_user
	if v == nil {
		return
	}
	return *v, true
}

// OldValidatorUserID returns the old "validator_user_id" field's value of the ArtifactSubmission entity.
// If the ArtifactSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactSubmissionMutation) OldValidatorUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidatorUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidatorUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidatorUserID: %w", err)
	}
	return oldValue.ValidatorUserID, nil
}

// ResetValidatorUserID resets all changes to the "validator_user_id" field.
func (m *ArtifactSubmissionMutation) ResetValidatorUserID() {
	m.validator_user = nil
}

// SetDocumentID sets the "document_id" field.
func (m *ArtifactSubmissionMutation) SetDocumentID(s string) {
	m.document_id = &s
}

// DocumentID returns the value of the "document_id" field in the mutation.
func (m *ArtifactSubmissionMutation) DocumentID() (r string, exists bool) {
	v := m.document_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentID returns the old "document_id" field's value of the ArtifactSubmission entity.
// If the ArtifactSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtifactSubmissionMutation) OldDocumentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentID: %w", err)
	}
	return oldValue.DocumentID, nil
}

// ResetDocumentID resets all changes to the "document_id" field.
func (m *ArtifactSubmissionMutation) ResetDocumentID() {
	m.document_id = nil
}

// ClearValidationCase clears the "validation_case" edge to the ValidationCase entity.
func (m *ArtifactSubmissionMutation) ClearValidationCase() {
	m.clearedvalidation_case = true
	m.clearedFields[artifactsubmission.FieldValidationCaseID] = struct{}{}
}

// ValidationCaseCleared reports if the "validation_case" edge to the ValidationCase entity was cleared.
func (m *ArtifactSubmissionMutation) ValidationCaseCleared() bool {
	return m.clearedvalidation_case
}

// ValidationCaseIDs returns the "validation_case" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValidationCaseID instead. It exists only for internal usage by the builders.
func (m *ArtifactSubmissionMutation) ValidationCaseIDs() (ids []int) {
	if id := m.validation_case; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValidationCase resets all changes to the "validation_case" edge.
func (m *ArtifactSubmissionMutation) ResetValidationCase() {
	m.validation_case = nil
	m.clearedvalidation_case = false
}

// ClearValidatorUser clears the "validator_user" edge to the User entity.
func (m *ArtifactSubmissionMutation) ClearValidatorUser() {
	m.clearedvalidator_user = true
	m.clearedFields[artifactsubmission.FieldValidatorUserID] = struct{}{}
}

// ValidatorUserCleared reports if the "validator_user" edge to the User entity was cleared.
func (m *ArtifactSubmissionMutation) ValidatorUserCleared() bool {
	return m.clearedvalidator_user
}

// ValidatorUserIDs returns the "validator_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValidatorUserID instead. It exists only for internal usage by the builders.
func (m *ArtifactSubmissionMutation) ValidatorUserIDs() (ids []int) {
	if id := m.validator_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValidatorUser resets all changes to the "validator_user" edge.
func (m *ArtifactSubmissionMutation) ResetValidatorUser() {
	m.validator_user = nil
	m.clearedvalidator_user = false
}

// Where appends a list predicates to the ArtifactSubmissionMutation builder.
func (m *ArtifactSubmissionMutation) Where(ps ...predicate.ArtifactSubmission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtifactSubmissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtifactSubmissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ArtifactSubmission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtifactSubmissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtifactSubmissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ArtifactSubmission).
func (m *ArtifactSubmissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtifactSubmissionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, artifactsubmission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, artifactsubmission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, artifactsubmission.FieldDeletedAt)
	}
	if m.validation_case != nil {
		fields = append(fields, artifactsubmission.FieldValidationCaseID)
	}
	if m.validator_user != nil {
		fields = append(fields, artifactsubmission.FieldValidatorUserID)
	}
	if m.document_id != nil {
		fields = append(fields, artifactsubmission.FieldDocumentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtifactSubmissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artifactsubmission.FieldCreatedAt:
		return m.CreatedAt()
	case artifactsubmission.FieldUpdatedAt:
		return m.UpdatedAt()
	case artifactsubmission.FieldDeletedAt:
		return m.DeletedAt()
	case artifactsubmission.FieldValidationCaseID:
		return m.ValidationCaseID()
	case artifactsubmission.FieldValidatorUserID:
		return m.ValidatorUserID()
	case artifactsubmission.FieldDocumentID:
		return m.DocumentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtifactSubmissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artifactsubmission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case artifactsubmission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case artifactsubmission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case artifactsubmission.FieldValidationCaseID:
		return m.OldValidationCaseID(ctx)
	case artifactsubmission.FieldValidatorUserID:
		return m.OldValidatorUserID(ctx)
	case artifactsubmission.FieldDocumentID:
		return m.OldDocumentID(ctx)
	}
	return nil, fmt.Errorf("unknown ArtifactSubmission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactSubmissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artifactsubmission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case artifactsubmission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case artifactsubmission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case artifactsubmission.FieldValidationCaseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationCaseID(v)
		return nil
	case artifactsubmission.FieldValidatorUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidatorUserID(v)
		return nil
	case artifactsubmission.FieldDocumentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentID(v)
		return nil
	}
	return fmt.Errorf("unknown ArtifactSubmission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtifactSubmissionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtifactSubmissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtifactSubmissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ArtifactSubmission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtifactSubmissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(artifactsubmission.FieldDeletedAt) {
		fields = append(fields, artifactsubmission.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtifactSubmissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtifactSubmissionMutation) ClearField(name string) error {
	switch name {
	case artifactsubmission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ArtifactSubmission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtifactSubmissionMutation) ResetField(name string) error {
	switch name {
	case artifactsubmission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case artifactsubmission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case artifactsubmission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case artifactsubmission.FieldValidationCaseID:
		m.ResetValidationCaseID()
		return nil
	case artifactsubmission.FieldValidatorUserID:
		m.ResetValidatorUserID()
		return nil
	case artifactsubmission.FieldDocumentID:
		m.ResetDocumentID()
		return nil
	}
	return fmt.Errorf("unknown ArtifactSubmission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtifactSubmissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.validation_case != nil {
		edges = append(edges, artifactsubmission.EdgeValidationCase)
	}
	if m.validator_user != nil {
		edges = append(edges, artifactsubmission.EdgeValidatorUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtifactSubmissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artifactsubmission.EdgeValidationCase:
		if id := m.validation_case; id != nil {
			return []ent.Value{*id}
		}
	case artifactsubmission.EdgeValidatorUser:
		if id := m.validator_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtifactSubmissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtifactSubmissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtifactSubmissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvalidation_case {
		edges = append(edges, artifactsubmission.EdgeValidationCase)
	}
	if m.clearedvalidator_user {
		edges = append(edges, artifactsubmission.EdgeValidatorUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtifactSubmissionMutation) EdgeCleared(name string) bool {
	switch name {
	case artifactsubmission.EdgeValidationCase:
		return m.clearedvalidation_case
	case artifactsubmission.EdgeValidatorUser:
		return m.clearedvalidator_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtifactSubmissionMutation) ClearEdge(name string) error {
	switch name {
	case artifactsubmission.EdgeValidationCase:
		m.ClearValidationCase()
		return nil
	case artifactsubmission.EdgeValidatorUser:
		m.ClearValidatorUser()
		return nil
	}
	return fmt.Errorf("unknown ArtifactSubmission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtifactSubmissionMutation) ResetEdge(name string) error {
	switch name {
	case artifactsubmission.EdgeValidationCase:
		m.ResetValidationCase()
		return nil
	case artifactsubmission.EdgeValidatorUser:
		m.ResetValidatorUser()
		return nil
	}
	return fmt.Errorf("unknown ArtifactSubmission edge %s", name)
}

// BackupCodeMutation represents an operation that mutates the BackupCode nodes in the graph.
type BackupCodeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	code_hash     *string
	used_at       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*BackupCode, error)
	predicates    []predicate.BackupCode
}

var _ ent.Mutation = (*BackupCodeMutation)(nil)

// backupcodeOption allows management of the mutation configuration using functional options.
type backupcodeOption func(*BackupCodeMutation)

// newBackupCodeMutation creates new mutation for the BackupCode entity.
func newBackupCodeMutation(c config, op Op, opts ...backupcodeOption) *BackupCodeMutation {
	m := &BackupCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeBackupCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBackupCodeID sets the ID field of the mutation.
func withBackupCodeID(id int) backupcodeOption {
	return func(m *BackupCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *BackupCode
		)
		m.oldValue = func(ctx context.Context) (*BackupCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BackupCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBackupCode sets the old BackupCode of the mutation.
func withBackupCode(node *BackupCode) backupcodeOption {
	return func(m *BackupCodeMutation) {
		m.oldValue = func(context.Context) (*BackupCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BackupCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BackupCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BackupCodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BackupCodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BackupCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BackupCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BackupCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BackupCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BackupCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BackupCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BackupCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BackupCodeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BackupCodeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BackupCodeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[backupcode.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BackupCodeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[backupcode.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BackupCodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, backupcode.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *BackupCodeMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BackupCodeMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BackupCodeMutation) ResetUserID() {
	m.user = nil
}

// SetCodeHash sets the "code_hash" field.
func (m *BackupCodeMutation) SetCodeHash(s string) {
	m.code_hash = &s
}

// CodeHash returns the value of the "code_hash" field in the mutation.
func (m *BackupCodeMutation) CodeHash() (r string, exists bool) {
	v := m.code_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeHash returns the old "code_hash" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldCodeHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeHash: %w", err)
	}
	return oldValue.CodeHash, nil
}

// ResetCodeHash resets all changes to the "code_hash" field.
func (m *BackupCodeMutation) ResetCodeHash() {
	m.code_hash = nil
}

// SetUsedAt sets the "used_at" field.
func (m *BackupCodeMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *BackupCodeMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *BackupCodeMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[backupcode.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *BackupCodeMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[backupcode.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *BackupCodeMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, backupcode.FieldUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *BackupCodeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[backupcode.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BackupCodeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BackupCodeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BackupCodeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the BackupCodeMutation builder.
func (m *BackupCodeMutation) Where(ps ...predicate.BackupCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BackupCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BackupCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BackupCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BackupCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BackupCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BackupCode).
func (m *BackupCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BackupCodeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, backupcode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backupcode.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, backupcode.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, backupcode.FieldUserID)
	}
	if m.code_hash != nil {
		fields = append(fields, backupcode.FieldCodeHash)
	}
	if m.used_at != nil {
		fields = append(fields, backupcode.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BackupCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backupcode.FieldCreatedAt:
		return m.CreatedAt()
	case backupcode.FieldUpdatedAt:
		return m.UpdatedAt()
	case backupcode.FieldDeletedAt:
		return m.DeletedAt()
	case backupcode.FieldUserID:
		return m.UserID()
	case backupcode.FieldCodeHash:
		return m.CodeHash()
	case backupcode.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BackupCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backupcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backupcode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case backupcode.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case backupcode.FieldUserID:
		return m.OldUserID(ctx)
	case backupcode.FieldCodeHash:
		return m.OldCodeHash(ctx)
	case backupcode.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BackupCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backupcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backupcode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case backupcode.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case backupcode.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case backupcode.FieldCodeHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeHash(v)
		return nil
	case backupcode.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BackupCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BackupCodeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BackupCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BackupCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BackupCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(backupcode.FieldDeletedAt) {
		fields = append(fields, backupcode.FieldDeletedAt)
	}
	if m.FieldCleared(backupcode.FieldUsedAt) {
		fields = append(fields, backupcode.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BackupCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BackupCodeMutation) ClearField(name string) error {
	switch name {
	case backupcode.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case backupcode.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown BackupCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BackupCodeMutation) ResetField(name string) error {
	switch name {
	case backupcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backupcode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case backupcode.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case backupcode.FieldUserID:
		m.ResetUserID()
		return nil
	case backupcode.FieldCodeHash:
		m.ResetCodeHash()
		return nil
	case backupcode.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown BackupCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BackupCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, backupcode.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BackupCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case backupcode.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BackupCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BackupCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BackupCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, backupcode.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BackupCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case backupcode.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BackupCodeMutation) ClearEdge(name string) error {
	switch name {
	case backupcode.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown BackupCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BackupCodeMutation) ResetEdge(name string) error {
	switch name {
	case backupcode.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown BackupCode edge %s", name)
}

// BadgeMutation represents an operation that mutates the Badge nodes in the graph.
type BadgeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	slug                 *string
	description          *string
	icon_type            *string
	color                *string
	clearedFields        map[string]struct{}
	user_badges          map[int]struct{}
	removeduser_badges   map[int]struct{}
	cleareduser_badges   bool
	primary_users        map[int]struct{}
	removedprimary_users map[int]struct{}
	clearedprimary_users bool
	done                 bool
	oldValue             func(context.Context) (*Badge, error)
	predicates           []predicate.Badge
}

var _ ent.Mutation = (*BadgeMutation)(nil)

// badgeOption allows management of the mutation configuration using functional options.
type badgeOption func(*BadgeMutation)

// newBadgeMutation creates new mutation for the Badge entity.
func newBadgeMutation(c config, op Op, opts ...badgeOption) *BadgeMutation {
	m := &BadgeMutation{
		config:        c,
		op:            op,
		typ:           TypeBadge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBadgeID sets the ID field of the mutation.
func withBadgeID(id int) badgeOption {
	return func(m *BadgeMutation) {
		var (
			err   error
			once  sync.Once
			value *Badge
		)
		m.oldValue = func(ctx context.Context) (*Badge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Badge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBadge sets the old Badge of the mutation.
func withBadge(node *Badge) badgeOption {
	return func(m *BadgeMutation) {
		m.oldValue = func(context.Context) (*Badge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BadgeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BadgeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BadgeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BadgeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Badge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BadgeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BadgeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BadgeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BadgeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BadgeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BadgeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BadgeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BadgeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BadgeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[badge.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BadgeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[badge.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BadgeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, badge.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BadgeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BadgeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BadgeMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *BadgeMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *BadgeMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *BadgeMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *BadgeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BadgeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BadgeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[badge.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BadgeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[badge.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BadgeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, badge.FieldDescription)
}

// SetIconType sets the "icon_type" field.
func (m *BadgeMutation) SetIconType(s string) {
	m.icon_type = &s
}

// IconType returns the value of the "icon_type" field in the mutation.
func (m *BadgeMutation) IconType() (r string, exists bool) {
	v := m.icon_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIconType returns the old "icon_type" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldIconType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconType: %w", err)
	}
	return oldValue.IconType, nil
}

// ResetIconType resets all changes to the "icon_type" field.
func (m *BadgeMutation) ResetIconType() {
	m.icon_type = nil
}

// SetColor sets the "color" field.
func (m *BadgeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *BadgeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *BadgeMutation) ResetColor() {
	m.color = nil
}

// AddUserBadgeIDs adds the "user_badges" edge to the UserBadge entity by ids.
func (m *BadgeMutation) AddUserBadgeIDs(ids ...int) {
	if m.user_badges == nil {
		m.user_badges = make(map[int]struct{})
	}
	for i := range ids {
		m.user_badges[ids[i]] = struct{}{}
	}
}

// ClearUserBadges clears the "user_badges" edge to the UserBadge entity.
func (m *BadgeMutation) ClearUserBadges() {
	m.cleareduser_badges = true
}

// UserBadgesCleared reports if the "user_badges" edge to the UserBadge entity was cleared.
func (m *BadgeMutation) UserBadgesCleared() bool {
	return m.cleareduser_badges
}

// RemoveUserBadgeIDs removes the "user_badges" edge to the UserBadge entity by IDs.
func (m *BadgeMutation) RemoveUserBadgeIDs(ids ...int) {
	if m.removeduser_badges == nil {
		m.removeduser_badges = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_badges, ids[i])
		m.removeduser_badges[ids[i]] = struct{}{}
	}
}

// RemovedUserBadges returns the removed IDs of the "user_badges" edge to the UserBadge entity.
func (m *BadgeMutation) RemovedUserBadgesIDs() (ids []int) {
	for id := range m.removeduser_badges {
		ids = append(ids, id)
	}
	return
}

// UserBadgesIDs returns the "user_badges" edge IDs in the mutation.
func (m *BadgeMutation) UserBadgesIDs() (ids []int) {
	for id := range m.user_badges {
		ids = append(ids, id)
	}
	return
}

// ResetUserBadges resets all changes to the "user_badges" edge.
func (m *BadgeMutation) ResetUserBadges() {
	m.user_badges = nil
	m.cleareduser_badges = false
	m.removeduser_badges = nil
}

// AddPrimaryUserIDs adds the "primary_users" edge to the User entity by ids.
func (m *BadgeMutation) AddPrimaryUserIDs(ids ...int) {
	if m.primary_users == nil {
		m.primary_users = make(map[int]struct{})
	}
	for i := range ids {
		m.primary_users[ids[i]] = struct{}{}
	}
}

// ClearPrimaryUsers clears the "primary_users" edge to the User entity.
func (m *BadgeMutation) ClearPrimaryUsers() {
	m.clearedprimary_users = true
}

// PrimaryUsersCleared reports if the "primary_users" edge to the User entity was cleared.
func (m *BadgeMutation) PrimaryUsersCleared() bool {
	return m.clearedprimary_users
}

// RemovePrimaryUserIDs removes the "primary_users" edge to the User entity by IDs.
func (m *BadgeMutation) RemovePrimaryUserIDs(ids ...int) {
	if m.removedprimary_users == nil {
		m.removedprimary_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.primary_users, ids[i])
		m.removedprimary_users[ids[i]] = struct{}{}
	}
}

// RemovedPrimaryUsers returns the removed IDs of the "primary_users" edge to the User entity.
func (m *BadgeMutation) RemovedPrimaryUsersIDs() (ids []int) {
	for id := range m.removedprimary_users {
		ids = append(ids, id)
	}
	return
}

// PrimaryUsersIDs returns the "primary_users" edge IDs in the mutation.
func (m *BadgeMutation) PrimaryUsersIDs() (ids []int) {
	for id := range m.primary_users {
		ids = append(ids, id)
	}
	return
}

// ResetPrimaryUsers resets all changes to the "primary_users" edge.
func (m *BadgeMutation) ResetPrimaryUsers() {
	m.primary_users = nil
	m.clearedprimary_users = false
	m.removedprimary_users = nil
}

// Where appends a list predicates to the BadgeMutation builder.
func (m *BadgeMutation) Where(ps ...predicate.Badge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BadgeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BadgeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Badge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BadgeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BadgeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Badge).
func (m *BadgeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BadgeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, badge.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, badge.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, badge.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, badge.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, badge.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, badge.FieldDescription)
	}
	if m.icon_type != nil {
		fields = append(fields, badge.FieldIconType)
	}
	if m.color != nil {
		fields = append(fields, badge.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BadgeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case badge.FieldCreatedAt:
		return m.CreatedAt()
	case badge.FieldUpdatedAt:
		return m.UpdatedAt()
	case badge.FieldDeletedAt:
		return m.DeletedAt()
	case badge.FieldName:
		return m.Name()
	case badge.FieldSlug:
		return m.Slug()
	case badge.FieldDescription:
		return m.Description()
	case badge.FieldIconType:
		return m.IconType()
	case badge.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BadgeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case badge.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case badge.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case badge.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case badge.FieldName:
		return m.OldName(ctx)
	case badge.FieldSlug:
		return m.OldSlug(ctx)
	case badge.FieldDescription:
		return m.OldDescription(ctx)
	case badge.FieldIconType:
		return m.OldIconType(ctx)
	case badge.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Badge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BadgeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case badge.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case badge.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case badge.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case badge.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case badge.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case badge.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case badge.FieldIconType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconType(v)
		return nil
	case badge.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Badge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BadgeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BadgeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BadgeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Badge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BadgeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(badge.FieldDeletedAt) {
		fields = append(fields, badge.FieldDeletedAt)
	}
	if m.FieldCleared(badge.FieldDescription) {
		fields = append(fields, badge.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BadgeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BadgeMutation) ClearField(name string) error {
	switch name {
	case badge.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case badge.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Badge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BadgeMutation) ResetField(name string) error {
	switch name {
	case badge.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case badge.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case badge.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case badge.FieldName:
		m.ResetName()
		return nil
	case badge.FieldSlug:
		m.ResetSlug()
		return nil
	case badge.FieldDescription:
		m.ResetDescription()
		return nil
	case badge.FieldIconType:
		m.ResetIconType()
		return nil
	case badge.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Badge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BadgeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_badges != nil {
		edges = append(edges, badge.EdgeUserBadges)
	}
	if m.primary_users != nil {
		edges = append(edges, badge.EdgePrimaryUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BadgeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case badge.EdgeUserBadges:
		ids := make([]ent.Value, 0, len(m.user_badges))
		for id := range m.user_badges {
			ids = append(ids, id)
		}
		return ids
	case badge.EdgePrimaryUsers:
		ids := make([]ent.Value, 0, len(m.primary_users))
		for id := range m.primary_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BadgeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_badges != nil {
		edges = append(edges, badge.EdgeUserBadges)
	}
	if m.removedprimary_users != nil {
		edges = append(edges, badge.EdgePrimaryUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BadgeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case badge.EdgeUserBadges:
		ids := make([]ent.Value, 0, len(m.removeduser_badges))
		for id := range m.removeduser_badges {
			ids = append(ids, id)
		}
		return ids
	case badge.EdgePrimaryUsers:
		ids := make([]ent.Value, 0, len(m.removedprimary_users))
		for id := range m.removedprimary_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BadgeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_badges {
		edges = append(edges, badge.EdgeUserBadges)
	}
	if m.clearedprimary_users {
		edges = append(edges, badge.EdgePrimaryUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BadgeMutation) EdgeCleared(name string) bool {
	switch name {
	case badge.EdgeUserBadges:
		return m.cleareduser_badges
	case badge.EdgePrimaryUsers:
		return m.clearedprimary_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BadgeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Badge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BadgeMutation) ResetEdge(name string) error {
	switch name {
	case badge.EdgeUserBadges:
		m.ResetUserBadges()
		return nil
	case badge.EdgePrimaryUsers:
		m.ResetPrimaryUsers()
		return nil
	}
	return fmt.Errorf("unknown Badge edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	slug                    *string
	name                    *string
	description             *string
	clearedFields           map[string]struct{}
	validation_cases        map[int]struct{}
	removedvalidation_cases map[int]struct{}
	clearedvalidation_cases bool
	done                    bool
	oldValue                func(context.Context) (*Category, error)
	predicates              []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[category.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[category.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, category.FieldDeletedAt)
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// AddValidationCaseIDs adds the "validation_cases" edge to the ValidationCase entity by ids.
func (m *CategoryMutation) AddValidationCaseIDs(ids ...int) {
	if m.validation_cases == nil {
		m.validation_cases = make(map[int]struct{})
	}
	for i := range ids {
		m.validation_cases[ids[i]] = struct{}{}
	}
}

// ClearValidationCases clears the "validation_cases" edge to the ValidationCase entity.
func (m *CategoryMutation) ClearValidationCases() {
	m.clearedvalidation_cases = true
}

// ValidationCasesCleared reports if the "validation_cases" edge to the ValidationCase entity was cleared.
func (m *CategoryMutation) ValidationCasesCleared() bool {
	return m.clearedvalidation_cases
}

// RemoveValidationCaseIDs removes the "validation_cases" edge to the ValidationCase entity by IDs.
func (m *CategoryMutation) RemoveValidationCaseIDs(ids ...int) {
	if m.removedvalidation_cases == nil {
		m.removedvalidation_cases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.validation_cases, ids[i])
		m.removedvalidation_cases[ids[i]] = struct{}{}
	}
}

// RemovedValidationCases returns the removed IDs of the "validation_cases" edge to the ValidationCase entity.
func (m *CategoryMutation) RemovedValidationCasesIDs() (ids []int) {
	for id := range m.removedvalidation_cases {
		ids = append(ids, id)
	}
	return
}

// ValidationCasesIDs returns the "validation_cases" edge IDs in the mutation.
func (m *CategoryMutation) ValidationCasesIDs() (ids []int) {
	for id := range m.validation_cases {
		ids = append(ids, id)
	}
	return
}

// ResetValidationCases resets all changes to the "validation_cases" edge.
func (m *CategoryMutation) ResetValidationCases() {
	m.validation_cases = nil
	m.clearedvalidation_cases = false
	m.removedvalidation_cases = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldDeletedAt:
		return m.DeletedAt()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldName:
		return m.Name()
	case category.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldDeletedAt) {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.validation_cases != nil {
		edges = append(edges, category.EdgeValidationCases)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeValidationCases:
		ids := make([]ent.Value, 0, len(m.validation_cases))
		for id := range m.validation_cases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvalidation_cases != nil {
		edges = append(edges, category.EdgeValidationCases)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeValidationCases:
		ids := make([]ent.Value, 0, len(m.removedvalidation_cases))
		for id := range m.removedvalidation_cases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvalidation_cases {
		edges = append(edges, category.EdgeValidationCases)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeValidationCases:
		return m.clearedvalidation_cases
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeValidationCases:
		m.ResetValidationCases()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// ChainCursorMutation represents an operation that mutates the ChainCursor nodes in the graph.
type ChainCursorMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	chain_id          *uint64
	addchain_id       *int64
	last_processed    *uint64
	addlast_processed *int64
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ChainCursor, error)
	predicates        []predicate.ChainCursor
}

var _ ent.Mutation = (*ChainCursorMutation)(nil)

// chaincursorOption allows management of the mutation configuration using functional options.
type chaincursorOption func(*ChainCursorMutation)

// newChainCursorMutation creates new mutation for the ChainCursor entity.
func newChainCursorMutation(c config, op Op, opts ...chaincursorOption) *ChainCursorMutation {
	m := &ChainCursorMutation{
		config:        c,
		op:            op,
		typ:           TypeChainCursor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChainCursorID sets the ID field of the mutation.
func withChainCursorID(id int) chaincursorOption {
	return func(m *ChainCursorMutation) {
		var (
			err   error
			once  sync.Once
			value *ChainCursor
		)
		m.oldValue = func(ctx context.Context) (*ChainCursor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChainCursor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChainCursor sets the old ChainCursor of the mutation.
func withChainCursor(node *ChainCursor) chaincursorOption {
	return func(m *ChainCursorMutation) {
		m.oldValue = func(context.Context) (*ChainCursor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChainCursorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChainCursorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChainCursorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChainCursorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChainCursor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ChainCursorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChainCursorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ChainCursor entity.
// If the ChainCursor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainCursorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChainCursorMutation) ResetName() {
	m.name = nil
}

// SetChainID sets the "chain_id" field.
func (m *ChainCursorMutation) SetChainID(u uint64) {
	m.chain_id = &u
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *ChainCursorMutation) ChainID() (r uint64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the ChainCursor entity.
// If the ChainCursor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainCursorMutation) OldChainID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds u to the "chain_id" field.
func (m *ChainCursorMutation) AddChainID(u int64) {
	if m.addchain_id != nil {
		*m.addchain_id += u
	} else {
		m.addchain_id = &u
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *ChainCursorMutation) AddedChainID() (r int64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *ChainCursorMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
}

// SetLastProcessed sets the "last_processed" field.
func (m *ChainCursorMutation) SetLastProcessed(u uint64) {
	m.last_processed = &u
	m.addlast_processed = nil
}

// LastProcessed returns the value of the "last_processed" field in the mutation.
func (m *ChainCursorMutation) LastProcessed() (r uint64, exists bool) {
	v := m.last_processed
	if v == nil {
		return
	}
	return *v, true
}

// OldLastProcessed returns the old "last_processed" field's value of the ChainCursor entity.
// If the ChainCursor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainCursorMutation) OldLastProcessed(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastProcessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastProcessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastProcessed: %w", err)
	}
	return oldValue.LastProcessed, nil
}

// AddLastProcessed adds u to the "last_processed" field.
func (m *ChainCursorMutation) AddLastProcessed(u int64) {
	if m.addlast_processed != nil {
		*m.addlast_processed += u
	} else {
		m.addlast_processed = &u
	}
}

// AddedLastProcessed returns the value that was added to the "last_processed" field in this mutation.
func (m *ChainCursorMutation) AddedLastProcessed() (r int64, exists bool) {
	v := m.addlast_processed
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastProcessed resets all changes to the "last_processed" field.
func (m *ChainCursorMutation) ResetLastProcessed() {
	m.last_processed = nil
	m.addlast_processed = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChainCursorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChainCursorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChainCursor entity.
// If the ChainCursor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainCursorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChainCursorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChainCursorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChainCursorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChainCursor entity.
// If the ChainCursor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainCursorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChainCursorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ChainCursorMutation builder.
func (m *ChainCursorMutation) Where(ps ...predicate.ChainCursor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChainCursorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChainCursorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChainCursor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChainCursorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChainCursorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChainCursor).
func (m *ChainCursorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChainCursorMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, chaincursor.FieldName)
	}
	if m.chain_id != nil {
		fields = append(fields, chaincursor.FieldChainID)
	}
	if m.last_processed != nil {
		fields = append(fields, chaincursor.FieldLastProcessed)
	}
	if m.created_at != nil {
		fields = append(fields, chaincursor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, chaincursor.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChainCursorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chaincursor.FieldName:
		return m.Name()
	case chaincursor.FieldChainID:
		return m.ChainID()
	case chaincursor.FieldLastProcessed:
		return m.LastProcessed()
	case chaincursor.FieldCreatedAt:
		return m.CreatedAt()
	case chaincursor.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChainCursorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chaincursor.FieldName:
		return m.OldName(ctx)
	case chaincursor.FieldChainID:
		return m.OldChainID(ctx)
	case chaincursor.FieldLastProcessed:
		return m.OldLastProcessed(ctx)
	case chaincursor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chaincursor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ChainCursor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChainCursorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chaincursor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case chaincursor.FieldChainID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case chaincursor.FieldLastProcessed:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastProcessed(v)
		return nil
	case chaincursor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chaincursor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChainCursor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChainCursorMutation) AddedFields() []string {
	var fields []string
	if m.addchain_id != nil {
		fields = append(fields, chaincursor.FieldChainID)
	}
	if m.addlast_processed != nil {
		fields = append(fields, chaincursor.FieldLastProcessed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChainCursorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chaincursor.FieldChainID:
		return m.AddedChainID()
	case chaincursor.FieldLastProcessed:
		return m.AddedLastProcessed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChainCursorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chaincursor.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	case chaincursor.FieldLastProcessed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastProcessed(v)
		return nil
	}
	return fmt.Errorf("unknown ChainCursor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChainCursorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChainCursorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChainCursorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChainCursor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChainCursorMutation) ResetField(name string) error {
	switch name {
	case chaincursor.FieldName:
		m.ResetName()
		return nil
	case chaincursor.FieldChainID:
		m.ResetChainID()
		return nil
	case chaincursor.FieldLastProcessed:
		m.ResetLastProcessed()
		return nil
	case chaincursor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chaincursor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ChainCursor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChainCursorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChainCursorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChainCursorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChainCursorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChainCursorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChainCursorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChainCursorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ChainCursor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChainCursorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ChainCursor edge %s", name)
}

// ConsultationRequestMutation represents an operation that mutates the ConsultationRequest nodes in the graph.
type ConsultationRequestMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	status                 *string
	workflow_cycle         *int
	addworkflow_cycle      *int
	approved_at            *time.Time
	rejected_at            *time.Time
	expires_at             *time.Time
	owner_response_due_at  *time.Time
	reminder_count         *int
	addreminder_count      *int
	auto_closed_reason     *string
	clearedFields          map[string]struct{}
	validation_case        *int
	clearedvalidation_case bool
	validator_user         *int
	clearedvalidator_user  bool
	done                   bool
	oldValue               func(context.Context) (*ConsultationRequest, error)
	predicates             []predicate.ConsultationRequest
}

var _ ent.Mutation = (*ConsultationRequestMutation)(nil)

// consultationrequestOption allows management of the mutation configuration using functional options.
type consultationrequestOption func(*ConsultationRequestMutation)

// newConsultationRequestMutation creates new mutation for the ConsultationRequest entity.
func newConsultationRequestMutation(c config, op Op, opts ...consultationrequestOption) *ConsultationRequestMutation {
	m := &ConsultationRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeConsultationRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConsultationRequestID sets the ID field of the mutation.
func withConsultationRequestID(id int) consultationrequestOption {
	return func(m *ConsultationRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *ConsultationRequest
		)
		m.oldValue = func(ctx context.Context) (*ConsultationRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConsultationRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConsultationRequest sets the old ConsultationRequest of the mutation.
func withConsultationRequest(node *ConsultationRequest) consultationrequestOption {
	return func(m *ConsultationRequestMutation) {
		m.oldValue = func(context.Context) (*ConsultationRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConsultationRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConsultationRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConsultationRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConsultationRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConsultationRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConsultationRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConsultationRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConsultationRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConsultationRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConsultationRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConsultationRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ConsultationRequestMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ConsultationRequestMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ConsultationRequestMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[consultationrequest.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ConsultationRequestMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[consultationrequest.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ConsultationRequestMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, consultationrequest.FieldDeletedAt)
}

// SetValidationCaseID sets the "validation_case_id" field.
func (m *ConsultationRequestMutation) SetValidationCaseID(i int) {
	m.validation_case = &i
}

// ValidationCaseID returns the value of the "validation_case_id" field in the mutation.
func (m *ConsultationRequestMutation) ValidationCaseID() (r int, exists bool) {
	v := m.validation_case
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationCaseID returns the old "validation_case_id" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldValidationCaseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationCaseID: %w", err)
	}
	return oldValue.ValidationCaseID, nil
}

// ResetValidationCaseID resets all changes to the "validation_case_id" field.
func (m *ConsultationRequestMutation) ResetValidationCaseID() {
	m.validation_case = nil
}

// SetValidatorUserID sets the "validator_user_id" field.
func (m *ConsultationRequestMutation) SetValidatorUserID(i int) {
	m.validator_user = &i
}

// ValidatorUserID returns the value of the "validator_user_id" field in the mutation.
func (m *ConsultationRequestMutation) ValidatorUserID() (r int, exists bool) {
	v := m.validator_user
	if v == nil {
		return
	}
	return *v, true
}

// OldValidatorUserID returns the old "validator_user_id" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldValidatorUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidatorUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidatorUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidatorUserID: %w", err)
	}
	return oldValue.ValidatorUserID, nil
}

// ResetValidatorUserID resets all changes to the "validator_user_id" field.
func (m *ConsultationRequestMutation) ResetValidatorUserID() {
	m.validator_user = nil
}

// SetStatus sets the "status" field.
func (m *ConsultationRequestMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ConsultationRequestMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ConsultationRequestMutation) ResetStatus() {
	m.status = nil
}

// SetWorkflowCycle sets the "workflow_cycle" field.
func (m *ConsultationRequestMutation) SetWorkflowCycle(i int) {
	m.workflow_cycle = &i
	m.addworkflow_cycle = nil
}

// WorkflowCycle returns the value of the "workflow_cycle" field in the mutation.
func (m *ConsultationRequestMutation) WorkflowCycle() (r int, exists bool) {
	v := m.workflow_cycle
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowCycle returns the old "workflow_cycle" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldWorkflowCycle(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowCycle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowCycle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowCycle: %w", err)
	}
	return oldValue.WorkflowCycle, nil
}

// AddWorkflowCycle adds i to the "workflow_cycle" field.
func (m *ConsultationRequestMutation) AddWorkflowCycle(i int) {
	if m.addworkflow_cycle != nil {
		*m.addworkflow_cycle += i
	} else {
		m.addworkflow_cycle = &i
	}
}

// AddedWorkflowCycle returns the value that was added to the "workflow_cycle" field in this mutation.
func (m *ConsultationRequestMutation) AddedWorkflowCycle() (r int, exists bool) {
	v := m.addworkflow_cycle
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorkflowCycle resets all changes to the "workflow_cycle" field.
func (m *ConsultationRequestMutation) ResetWorkflowCycle() {
	m.workflow_cycle = nil
	m.addworkflow_cycle = nil
}

// SetApprovedAt sets the "approved_at" field.
func (m *ConsultationRequestMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *ConsultationRequestMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldApprovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *ConsultationRequestMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[consultationrequest.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *ConsultationRequestMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[consultationrequest.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *ConsultationRequestMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, consultationrequest.FieldApprovedAt)
}

// SetRejectedAt sets the "rejected_at" field.
func (m *ConsultationRequestMutation) SetRejectedAt(t time.Time) {
	m.rejected_at = &t
}

// RejectedAt returns the value of the "rejected_at" field in the mutation.
func (m *ConsultationRequestMutation) RejectedAt() (r time.Time, exists bool) {
	v := m.rejected_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectedAt returns the old "rejected_at" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldRejectedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectedAt: %w", err)
	}
	return oldValue.RejectedAt, nil
}

// ClearRejectedAt clears the value of the "rejected_at" field.
func (m *ConsultationRequestMutation) ClearRejectedAt() {
	m.rejected_at = nil
	m.clearedFields[consultationrequest.FieldRejectedAt] = struct{}{}
}

// RejectedAtCleared returns if the "rejected_at" field was cleared in this mutation.
func (m *ConsultationRequestMutation) RejectedAtCleared() bool {
	_, ok := m.clearedFields[consultationrequest.FieldRejectedAt]
	return ok
}

// ResetRejectedAt resets all changes to the "rejected_at" field.
func (m *ConsultationRequestMutation) ResetRejectedAt() {
	m.rejected_at = nil
	delete(m.clearedFields, consultationrequest.FieldRejectedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *ConsultationRequestMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ConsultationRequestMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ConsultationRequestMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[consultationrequest.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ConsultationRequestMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[consultationrequest.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ConsultationRequestMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, consultationrequest.FieldExpiresAt)
}

// SetOwnerResponseDueAt sets the "owner_response_due_at" field.
func (m *ConsultationRequestMutation) SetOwnerResponseDueAt(t time.Time) {
	m.owner_response_due_at = &t
}

// OwnerResponseDueAt returns the value of the "owner_response_due_at" field in the mutation.
func (m *ConsultationRequestMutation) OwnerResponseDueAt() (r time.Time, exists bool) {
	v := m.owner_response_due_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerResponseDueAt returns the old "owner_response_due_at" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldOwnerResponseDueAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerResponseDueAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerResponseDueAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerResponseDueAt: %w", err)
	}
	return oldValue.OwnerResponseDueAt, nil
}

// ClearOwnerResponseDueAt clears the value of the "owner_response_due_at" field.
func (m *ConsultationRequestMutation) ClearOwnerResponseDueAt() {
	m.owner_response_due_at = nil
	m.clearedFields[consultationrequest.FieldOwnerResponseDueAt] = struct{}{}
}

// OwnerResponseDueAtCleared returns if the "owner_response_due_at" field was cleared in this mutation.
func (m *ConsultationRequestMutation) OwnerResponseDueAtCleared() bool {
	_, ok := m.clearedFields[consultationrequest.FieldOwnerResponseDueAt]
	return ok
}

// ResetOwnerResponseDueAt resets all changes to the "owner_response_due_at" field.
func (m *ConsultationRequestMutation) ResetOwnerResponseDueAt() {
	m.owner_response_due_at = nil
	delete(m.clearedFields, consultationrequest.FieldOwnerResponseDueAt)
}

// SetReminderCount sets the "reminder_count" field.
func (m *ConsultationRequestMutation) SetReminderCount(i int) {
	m.reminder_count = &i
	m.addreminder_count = nil
}

// ReminderCount returns the value of the "reminder_count" field in the mutation.
func (m *ConsultationRequestMutation) ReminderCount() (r int, exists bool) {
	v := m.reminder_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReminderCount returns the old "reminder_count" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldReminderCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReminderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReminderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReminderCount: %w", err)
	}
	return oldValue.ReminderCount, nil
}

// AddReminderCount adds i to the "reminder_count" field.
func (m *ConsultationRequestMutation) AddReminderCount(i int) {
	if m.addreminder_count != nil {
		*m.addreminder_count += i
	} else {
		m.addreminder_count = &i
	}
}

// AddedReminderCount returns the value that was added to the "reminder_count" field in this mutation.
func (m *ConsultationRequestMutation) AddedReminderCount() (r int, exists bool) {
	v := m.addreminder_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReminderCount resets all changes to the "reminder_count" field.
func (m *ConsultationRequestMutation) ResetReminderCount() {
	m.reminder_count = nil
	m.addreminder_count = nil
}

// SetAutoClosedReason sets the "auto_closed_reason" field.
func (m *ConsultationRequestMutation) SetAutoClosedReason(s string) {
	m.auto_closed_reason = &s
}

// AutoClosedReason returns the value of the "auto_closed_reason" field in the mutation.
func (m *ConsultationRequestMutation) AutoClosedReason() (r string, exists bool) {
	v := m.auto_closed_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoClosedReason returns the old "auto_closed_reason" field's value of the ConsultationRequest entity.
// If the ConsultationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsultationRequestMutation) OldAutoClosedReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoClosedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoClosedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoClosedReason: %w", err)
	}
	return oldValue.AutoClosedReason, nil
}

// ClearAutoClosedReason clears the value of the "auto_closed_reason" field.
func (m *ConsultationRequestMutation) ClearAutoClosedReason() {
	m.auto_closed_reason = nil
	m.clearedFields[consultationrequest.FieldAutoClosedReason] = struct{}{}
}

// AutoClosedReasonCleared returns if the "auto_closed_reason" field was cleared in this mutation.
func (m *ConsultationRequestMutation) AutoClosedReasonCleared() bool {
	_, ok := m.clearedFields[consultationrequest.FieldAutoClosedReason]
	return ok
}

// ResetAutoClosedReason resets all changes to the "auto_closed_reason" field.
func (m *ConsultationRequestMutation) ResetAutoClosedReason() {
	m.auto_closed_reason = nil
	delete(m.clearedFields, consultationrequest.FieldAutoClosedReason)
}

// ClearValidationCase clears the "validation_case" edge to the ValidationCase entity.
func (m *ConsultationRequestMutation) ClearValidationCase() {
	m.clearedvalidation_case = true
	m.clearedFields[consultationrequest.FieldValidationCaseID] = struct{}{}
}

// ValidationCaseCleared reports if the "validation_case" edge to the ValidationCase entity was cleared.
func (m *ConsultationRequestMutation) ValidationCaseCleared() bool {
	return m.clearedvalidation_case
}

// ValidationCaseIDs returns the "validation_case" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValidationCaseID instead. It exists only for internal usage by the builders.
func (m *ConsultationRequestMutation) ValidationCaseIDs() (ids []int) {
	if id := m.validation_case; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValidationCase resets all changes to the "validation_case" edge.
func (m *ConsultationRequestMutation) ResetValidationCase() {
	m.validation_case = nil
	m.clearedvalidation_case = false
}

// ClearValidatorUser clears the "validator_user" edge to the User entity.
func (m *ConsultationRequestMutation) ClearValidatorUser() {
	m.clearedvalidator_user = true
	m.clearedFields[consultationrequest.FieldValidatorUserID] = struct{}{}
}

// ValidatorUserCleared reports if the "validator_user" edge to the User entity was cleared.
func (m *ConsultationRequestMutation) ValidatorUserCleared() bool {
	return m.clearedvalidator_user
}

// ValidatorUserIDs returns the "validator_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValidatorUserID instead. It exists only for internal usage by the builders.
func (m *ConsultationRequestMutation) ValidatorUserIDs() (ids []int) {
	if id := m.validator_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValidatorUser resets all changes to the "validator_user" edge.
func (m *ConsultationRequestMutation) ResetValidatorUser() {
	m.validator_user = nil
	m.clearedvalidator_user = false
}

// Where appends a list predicates to the ConsultationRequestMutation builder.
func (m *ConsultationRequestMutation) Where(ps ...predicate.ConsultationRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConsultationRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConsultationRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConsultationRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConsultationRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConsultationRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConsultationRequest).
func (m *ConsultationRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConsultationRequestMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, consultationrequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, consultationrequest.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, consultationrequest.FieldDeletedAt)
	}
	if m.validation_case != nil {
		fields = append(fields, consultationrequest.FieldValidationCaseID)
	}
	if m.validator_user != nil {
		fields = append(fields, consultationrequest.FieldValidatorUserID)
	}
	if m.status != nil {
		fields = append(fields, consultationrequest.FieldStatus)
	}
	if m.workflow_cycle != nil {
		fields = append(fields, consultationrequest.FieldWorkflowCycle)
	}
	if m.approved_at != nil {
		fields = append(fields, consultationrequest.FieldApprovedAt)
	}
	if m.rejected_at != nil {
		fields = append(fields, consultationrequest.FieldRejectedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, consultationrequest.FieldExpiresAt)
	}
	if m.owner_response_due_at != nil {
		fields = append(fields, consultationrequest.FieldOwnerResponseDueAt)
	}
	if m.reminder_count != nil {
		fields = append(fields, consultationrequest.FieldReminderCount)
	}
	if m.auto_closed_reason != nil {
		fields = append(fields, consultationrequest.FieldAutoClosedReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConsultationRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case consultationrequest.FieldCreatedAt:
		return m.CreatedAt()
	case consultationrequest.FieldUpdatedAt:
		return m.UpdatedAt()
	case consultationrequest.FieldDeletedAt:
		return m.DeletedAt()
	case consultationrequest.FieldValidationCaseID:
		return m.ValidationCaseID()
	case consultationrequest.FieldValidatorUserID:
		return m.ValidatorUserID()
	case consultationrequest.FieldStatus:
		return m.Status()
	case consultationrequest.FieldWorkflowCycle:
		return m.WorkflowCycle()
	case consultationrequest.FieldApprovedAt:
		return m.ApprovedAt()
	case consultationrequest.FieldRejectedAt:
		return m.RejectedAt()
	case consultationrequest.FieldExpiresAt:
		return m.ExpiresAt()
	case consultationrequest.FieldOwnerResponseDueAt:
		return m.OwnerResponseDueAt()
	case consultationrequest.FieldReminderCount:
		return m.ReminderCount()
	case consultationrequest.FieldAutoClosedReason:
		return m.AutoClosedReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConsultationRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case consultationrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case consultationrequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case consultationrequest.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case consultationrequest.FieldValidationCaseID:
		return m.OldValidationCaseID(ctx)
	case consultationrequest.FieldValidatorUserID:
		return m.OldValidatorUserID(ctx)
	case consultationrequest.FieldStatus:
		return m.OldStatus(ctx)
	case consultationrequest.FieldWorkflowCycle:
		return m.OldWorkflowCycle(ctx)
	case consultationrequest.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case consultationrequest.FieldRejectedAt:
		return m.OldRejectedAt(ctx)
	case consultationrequest.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case consultationrequest.FieldOwnerResponseDueAt:
		return m.OldOwnerResponseDueAt(ctx)
	case consultationrequest.FieldReminderCount:
		return m.OldReminderCount(ctx)
	case consultationrequest.FieldAutoClosedReason:
		return m.OldAutoClosedReason(ctx)
	}
	return nil, fmt.Errorf("unknown ConsultationRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsultationRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case consultationrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case consultationrequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case consultationrequest.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case consultationrequest.FieldValidationCaseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationCaseID(v)
		return nil
	case consultationrequest.FieldValidatorUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidatorUserID(v)
		return nil
	case consultationrequest.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case consultationrequest.FieldWorkflowCycle:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowCycle(v)
		return nil
	case consultationrequest.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case consultationrequest.FieldRejectedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectedAt(v)
		return nil
	case consultationrequest.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case consultationrequest.FieldOwnerResponseDueAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerResponseDueAt(v)
		return nil
	case consultationrequest.FieldReminderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReminderCount(v)
		return nil
	case consultationrequest.FieldAutoClosedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoClosedReason(v)
		return nil
	}
	return fmt.Errorf("unknown ConsultationRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConsultationRequestMutation) AddedFields() []string {
	var fields []string
	if m.addworkflow_cycle != nil {
		fields = append(fields, consultationrequest.FieldWorkflowCycle)
	}
	if m.addreminder_count != nil {
		fields = append(fields, consultationrequest.FieldReminderCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConsultationRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case consultationrequest.FieldWorkflowCycle:
		return m.AddedWorkflowCycle()
	case consultationrequest.FieldReminderCount:
		return m.AddedReminderCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsultationRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case consultationrequest.FieldWorkflowCycle:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkflowCycle(v)
		return nil
	case consultationrequest.FieldReminderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReminderCount(v)
		return nil
	}
	return fmt.Errorf("unknown ConsultationRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConsultationRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(consultationrequest.FieldDeletedAt) {
		fields = append(fields, consultationrequest.FieldDeletedAt)
	}
	if m.FieldCleared(consultationrequest.FieldApprovedAt) {
		fields = append(fields, consultationrequest.FieldApprovedAt)
	}
	if m.FieldCleared(consultationrequest.FieldRejectedAt) {
		fields = append(fields, consultationrequest.FieldRejectedAt)
	}
	if m.FieldCleared(consultationrequest.FieldExpiresAt) {
		fields = append(fields, consultationrequest.FieldExpiresAt)
	}
	if m.FieldCleared(consultationrequest.FieldOwnerResponseDueAt) {
		fields = append(fields, consultationrequest.FieldOwnerResponseDueAt)
	}
	if m.FieldCleared(consultationrequest.FieldAutoClosedReason) {
		fields = append(fields, consultationrequest.FieldAutoClosedReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConsultationRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConsultationRequestMutation) ClearField(name string) error {
	switch name {
	case consultationrequest.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case consultationrequest.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case consultationrequest.FieldRejectedAt:
		m.ClearRejectedAt()
		return nil
	case consultationrequest.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case consultationrequest.FieldOwnerResponseDueAt:
		m.ClearOwnerResponseDueAt()
		return nil
	case consultationrequest.FieldAutoClosedReason:
		m.ClearAutoClosedReason()
		return nil
	}
	return fmt.Errorf("unknown ConsultationRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConsultationRequestMutation) ResetField(name string) error {
	switch name {
	case consultationrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case consultationrequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case consultationrequest.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case consultationrequest.FieldValidationCaseID:
		m.ResetValidationCaseID()
		return nil
	case consultationrequest.FieldValidatorUserID:
		m.ResetValidatorUserID()
		return nil
	case consultationrequest.FieldStatus:
		m.ResetStatus()
		return nil
	case consultationrequest.FieldWorkflowCycle:
		m.ResetWorkflowCycle()
		return nil
	case consultationrequest.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case consultationrequest.FieldRejectedAt:
		m.ResetRejectedAt()
		return nil
	case consultationrequest.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case consultationrequest.FieldOwnerResponseDueAt:
		m.ResetOwnerResponseDueAt()
		return nil
	case consultationrequest.FieldReminderCount:
		m.ResetReminderCount()
		return nil
	case consultationrequest.FieldAutoClosedReason:
		m.ResetAutoClosedReason()
		return nil
	}
	return fmt.Errorf("unknown ConsultationRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConsultationRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.validation_case != nil {
		edges = append(edges, consultationrequest.EdgeValidationCase)
	}
	if m.validator_user != nil {
		edges = append(edges, consultationrequest.EdgeValidatorUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConsultationRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case consultationrequest.EdgeValidationCase:
		if id := m.validation_case; id != nil {
			return []ent.Value{*id}
		}
	case consultationrequest.EdgeValidatorUser:
		if id := m.validator_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConsultationRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConsultationRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConsultationRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvalidation_case {
		edges = append(edges, consultationrequest.EdgeValidationCase)
	}
	if m.clearedvalidator_user {
		edges = append(edges, consultationrequest.EdgeValidatorUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConsultationRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case consultationrequest.EdgeValidationCase:
		return m.clearedvalidation_case
	case consultationrequest.EdgeValidatorUser:
		return m.clearedvalidator_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConsultationRequestMutation) ClearEdge(name string) error {
	switch name {
	case consultationrequest.EdgeValidationCase:
		m.ClearValidationCase()
		return nil
	case consultationrequest.EdgeValidatorUser:
		m.ClearValidatorUser()
		return nil
	}
	return fmt.Errorf("unknown ConsultationRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConsultationRequestMutation) ResetEdge(name string) error {
	switch name {
	case consultationrequest.EdgeValidationCase:
		m.ResetValidationCase()
		return nil
	case consultationrequest.EdgeValidatorUser:
		m.ResetValidatorUser()
		return nil
	}
	return fmt.Errorf("unknown ConsultationRequest edge %s", name)
}

// CredentialMutation represents an operation that mutates the Credential nodes in the graph.
type CredentialMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	platform      *string
	description   *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Credential, error)
	predicates    []predicate.Credential
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// credentialOption allows management of the mutation configuration using functional options.
type credentialOption func(*CredentialMutation)

// newCredentialMutation creates new mutation for the Credential entity.
func newCredentialMutation(c config, op Op, opts ...credentialOption) *CredentialMutation {
	m := &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialID sets the ID field of the mutation.
func withCredentialID(id int) credentialOption {
	return func(m *CredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *Credential
		)
		m.oldValue = func(ctx context.Context) (*Credential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredential sets the old Credential of the mutation.
func withCredential(node *Credential) credentialOption {
	return func(m *CredentialMutation) {
		m.oldValue = func(context.Context) (*Credential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CredentialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CredentialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CredentialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CredentialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CredentialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CredentialMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CredentialMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CredentialMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[credential.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CredentialMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[credential.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CredentialMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, credential.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *CredentialMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CredentialMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CredentialMutation) ResetUserID() {
	m.user = nil
}

// SetPlatform sets the "platform" field.
func (m *CredentialMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *CredentialMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ClearPlatform clears the value of the "platform" field.
func (m *CredentialMutation) ClearPlatform() {
	m.platform = nil
	m.clearedFields[credential.FieldPlatform] = struct{}{}
}

// PlatformCleared returns if the "platform" field was cleared in this mutation.
func (m *CredentialMutation) PlatformCleared() bool {
	_, ok := m.clearedFields[credential.FieldPlatform]
	return ok
}

// ResetPlatform resets all changes to the "platform" field.
func (m *CredentialMutation) ResetPlatform() {
	m.platform = nil
	delete(m.clearedFields, credential.FieldPlatform)
}

// SetDescription sets the "description" field.
func (m *CredentialMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CredentialMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CredentialMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[credential.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CredentialMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[credential.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CredentialMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, credential.FieldDescription)
}

// ClearUser clears the "user" edge to the User entity.
func (m *CredentialMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[credential.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CredentialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CredentialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CredentialMutation builder.
func (m *CredentialMutation) Where(ps ...predicate.Credential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, credential.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, credential.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, credential.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, credential.FieldUserID)
	}
	if m.platform != nil {
		fields = append(fields, credential.FieldPlatform)
	}
	if m.description != nil {
		fields = append(fields, credential.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldCreatedAt:
		return m.CreatedAt()
	case credential.FieldUpdatedAt:
		return m.UpdatedAt()
	case credential.FieldDeletedAt:
		return m.DeletedAt()
	case credential.FieldUserID:
		return m.UserID()
	case credential.FieldPlatform:
		return m.Platform()
	case credential.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case credential.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case credential.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case credential.FieldUserID:
		return m.OldUserID(ctx)
	case credential.FieldPlatform:
		return m.OldPlatform(ctx)
	case credential.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Credential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case credential.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case credential.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case credential.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case credential.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case credential.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credential.FieldDeletedAt) {
		fields = append(fields, credential.FieldDeletedAt)
	}
	if m.FieldCleared(credential.FieldPlatform) {
		fields = append(fields, credential.FieldPlatform)
	}
	if m.FieldCleared(credential.FieldDescription) {
		fields = append(fields, credential.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	switch name {
	case credential.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case credential.FieldPlatform:
		m.ClearPlatform()
		return nil
	case credential.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case credential.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case credential.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case credential.FieldUserID:
		m.ResetUserID()
		return nil
	case credential.FieldPlatform:
		m.ResetPlatform()
		return nil
	case credential.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, credential.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, credential.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case credential.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	switch name {
	case credential.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	switch name {
	case credential.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Credential edge %s", name)
}

// DeviceFingerprintMutation represents an operation that mutates the DeviceFingerprint nodes in the graph.
type DeviceFingerprintMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	fingerprint_hash *string
	ip_address       *string
	user_agent       *string
	account_count    *int
	addaccount_count *int
	last_seen_at     *time.Time
	blocked          *bool
	block_reason     *string
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*DeviceFingerprint, error)
	predicates       []predicate.DeviceFingerprint
}

var _ ent.Mutation = (*DeviceFingerprintMutation)(nil)

// devicefingerprintOption allows management of the mutation configuration using functional options.
type devicefingerprintOption func(*DeviceFingerprintMutation)

// newDeviceFingerprintMutation creates new mutation for the DeviceFingerprint entity.
func newDeviceFingerprintMutation(c config, op Op, opts ...devicefingerprintOption) *DeviceFingerprintMutation {
	m := &DeviceFingerprintMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceFingerprint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceFingerprintID sets the ID field of the mutation.
func withDeviceFingerprintID(id int) devicefingerprintOption {
	return func(m *DeviceFingerprintMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceFingerprint
		)
		m.oldValue = func(ctx context.Context) (*DeviceFingerprint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceFingerprint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceFingerprint sets the old DeviceFingerprint of the mutation.
func withDeviceFingerprint(node *DeviceFingerprint) devicefingerprintOption {
	return func(m *DeviceFingerprintMutation) {
		m.oldValue = func(context.Context) (*DeviceFingerprint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceFingerprintMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceFingerprintMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceFingerprintMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceFingerprintMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceFingerprint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceFingerprintMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceFingerprintMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceFingerprintMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceFingerprintMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceFingerprintMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceFingerprintMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceFingerprintMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceFingerprintMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DeviceFingerprintMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[devicefingerprint.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DeviceFingerprintMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[devicefingerprint.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceFingerprintMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, devicefingerprint.FieldDeletedAt)
}

// SetFingerprintHash sets the "fingerprint_hash" field.
func (m *DeviceFingerprintMutation) SetFingerprintHash(s string) {
	m.fingerprint_hash = &s
}

// FingerprintHash returns the value of the "fingerprint_hash" field in the mutation.
func (m *DeviceFingerprintMutation) FingerprintHash() (r string, exists bool) {
	v := m.fingerprint_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprintHash returns the old "fingerprint_hash" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldFingerprintHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprintHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprintHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprintHash: %w", err)
	}
	return oldValue.FingerprintHash, nil
}

// ResetFingerprintHash resets all changes to the "fingerprint_hash" field.
func (m *DeviceFingerprintMutation) ResetFingerprintHash() {
	m.fingerprint_hash = nil
}

// SetUserID sets the "user_id" field.
func (m *DeviceFingerprintMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DeviceFingerprintMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *DeviceFingerprintMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[devicefingerprint.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *DeviceFingerprintMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[devicefingerprint.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DeviceFingerprintMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, devicefingerprint.FieldUserID)
}

// SetIPAddress sets the "ip_address" field.
func (m *DeviceFingerprintMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *DeviceFingerprintMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *DeviceFingerprintMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[devicefingerprint.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *DeviceFingerprintMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[devicefingerprint.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *DeviceFingerprintMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, devicefingerprint.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *DeviceFingerprintMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *DeviceFingerprintMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *DeviceFingerprintMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[devicefingerprint.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *DeviceFingerprintMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[devicefingerprint.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *DeviceFingerprintMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, devicefingerprint.FieldUserAgent)
}

// SetAccountCount sets the "account_count" field.
func (m *DeviceFingerprintMutation) SetAccountCount(i int) {
	m.account_count = &i
	m.addaccount_count = nil
}

// AccountCount returns the value of the "account_count" field in the mutation.
func (m *DeviceFingerprintMutation) AccountCount() (r int, exists bool) {
	v := m.account_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountCount returns the old "account_count" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldAccountCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountCount: %w", err)
	}
	return oldValue.AccountCount, nil
}

// AddAccountCount adds i to the "account_count" field.
func (m *DeviceFingerprintMutation) AddAccountCount(i int) {
	if m.addaccount_count != nil {
		*m.addaccount_count += i
	} else {
		m.addaccount_count = &i
	}
}

// AddedAccountCount returns the value that was added to the "account_count" field in this mutation.
func (m *DeviceFingerprintMutation) AddedAccountCount() (r int, exists bool) {
	v := m.addaccount_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountCount resets all changes to the "account_count" field.
func (m *DeviceFingerprintMutation) ResetAccountCount() {
	m.account_count = nil
	m.addaccount_count = nil
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *DeviceFingerprintMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *DeviceFingerprintMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldLastSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *DeviceFingerprintMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
}

// SetBlocked sets the "blocked" field.
func (m *DeviceFingerprintMutation) SetBlocked(b bool) {
	m.blocked = &b
}

// Blocked returns the value of the "blocked" field in the mutation.
func (m *DeviceFingerprintMutation) Blocked() (r bool, exists bool) {
	v := m.blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldBlocked returns the old "blocked" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldBlocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlocked: %w", err)
	}
	return oldValue.Blocked, nil
}

// ResetBlocked resets all changes to the "blocked" field.
func (m *DeviceFingerprintMutation) ResetBlocked() {
	m.blocked = nil
}

// SetBlockReason sets the "block_reason" field.
func (m *DeviceFingerprintMutation) SetBlockReason(s string) {
	m.block_reason = &s
}

// BlockReason returns the value of the "block_reason" field in the mutation.
func (m *DeviceFingerprintMutation) BlockReason() (r string, exists bool) {
	v := m.block_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockReason returns the old "block_reason" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldBlockReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockReason: %w", err)
	}
	return oldValue.BlockReason, nil
}

// ClearBlockReason clears the value of the "block_reason" field.
func (m *DeviceFingerprintMutation) ClearBlockReason() {
	m.block_reason = nil
	m.clearedFields[devicefingerprint.FieldBlockReason] = struct{}{}
}

// BlockReasonCleared returns if the "block_reason" field was cleared in this mutation.
func (m *DeviceFingerprintMutation) BlockReasonCleared() bool {
	_, ok := m.clearedFields[devicefingerprint.FieldBlockReason]
	return ok
}

// ResetBlockReason resets all changes to the "block_reason" field.
func (m *DeviceFingerprintMutation) ResetBlockReason() {
	m.block_reason = nil
	delete(m.clearedFields, devicefingerprint.FieldBlockReason)
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeviceFingerprintMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[devicefingerprint.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeviceFingerprintMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeviceFingerprintMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeviceFingerprintMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the DeviceFingerprintMutation builder.
func (m *DeviceFingerprintMutation) Where(ps ...predicate.DeviceFingerprint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceFingerprintMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceFingerprintMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceFingerprint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceFingerprintMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceFingerprintMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceFingerprint).
func (m *DeviceFingerprintMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceFingerprintMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, devicefingerprint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicefingerprint.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, devicefingerprint.FieldDeletedAt)
	}
	if m.fingerprint_hash != nil {
		fields = append(fields, devicefingerprint.FieldFingerprintHash)
	}
	if m.user != nil {
		fields = append(fields, devicefingerprint.FieldUserID)
	}
	if m.ip_address != nil {
		fields = append(fields, devicefingerprint.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, devicefingerprint.FieldUserAgent)
	}
	if m.account_count != nil {
		fields = append(fields, devicefingerprint.FieldAccountCount)
	}
	if m.last_seen_at != nil {
		fields = append(fields, devicefingerprint.FieldLastSeenAt)
	}
	if m.blocked != nil {
		fields = append(fields, devicefingerprint.FieldBlocked)
	}
	if m.block_reason != nil {
		fields = append(fields, devicefingerprint.FieldBlockReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceFingerprintMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicefingerprint.FieldCreatedAt:
		return m.CreatedAt()
	case devicefingerprint.FieldUpdatedAt:
		return m.UpdatedAt()
	case devicefingerprint.FieldDeletedAt:
		return m.DeletedAt()
	case devicefingerprint.FieldFingerprintHash:
		return m.FingerprintHash()
	case devicefingerprint.FieldUserID:
		return m.UserID()
	case devicefingerprint.FieldIPAddress:
		return m.IPAddress()
	case devicefingerprint.FieldUserAgent:
		return m.UserAgent()
	case devicefingerprint.FieldAccountCount:
		return m.AccountCount()
	case devicefingerprint.FieldLastSeenAt:
		return m.LastSeenAt()
	case devicefingerprint.FieldBlocked:
		return m.Blocked()
	case devicefingerprint.FieldBlockReason:
		return m.BlockReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceFingerprintMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicefingerprint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicefingerprint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case devicefingerprint.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case devicefingerprint.FieldFingerprintHash:
		return m.OldFingerprintHash(ctx)
	case devicefingerprint.FieldUserID:
		return m.OldUserID(ctx)
	case devicefingerprint.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case devicefingerprint.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case devicefingerprint.FieldAccountCount:
		return m.OldAccountCount(ctx)
	case devicefingerprint.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	case devicefingerprint.FieldBlocked:
		return m.OldBlocked(ctx)
	case devicefingerprint.FieldBlockReason:
		return m.OldBlockReason(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceFingerprint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceFingerprintMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicefingerprint.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicefingerprint.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case devicefingerprint.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case devicefingerprint.FieldFingerprintHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprintHash(v)
		return nil
	case devicefingerprint.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case devicefingerprint.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case devicefingerprint.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case devicefingerprint.FieldAccountCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountCount(v)
		return nil
	case devicefingerprint.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	case devicefingerprint.FieldBlocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlocked(v)
		return nil
	case devicefingerprint.FieldBlockReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockReason(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceFingerprintMutation) AddedFields() []string {
	var fields []string
	if m.addaccount_count != nil {
		fields = append(fields, devicefingerprint.FieldAccountCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceFingerprintMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case devicefingerprint.FieldAccountCount:
		return m.AddedAccountCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceFingerprintMutation) AddField(name string, value ent.Value) error {
	switch name {
	case devicefingerprint.FieldAccountCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountCount(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceFingerprintMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devicefingerprint.FieldDeletedAt) {
		fields = append(fields, devicefingerprint.FieldDeletedAt)
	}
	if m.FieldCleared(devicefingerprint.FieldUserID) {
		fields = append(fields, devicefingerprint.FieldUserID)
	}
	if m.FieldCleared(devicefingerprint.FieldIPAddress) {
		fields = append(fields, devicefingerprint.FieldIPAddress)
	}
	if m.FieldCleared(devicefingerprint.FieldUserAgent) {
		fields = append(fields, devicefingerprint.FieldUserAgent)
	}
	if m.FieldCleared(devicefingerprint.FieldBlockReason) {
		fields = append(fields, devicefingerprint.FieldBlockReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceFingerprintMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceFingerprintMutation) ClearField(name string) error {
	switch name {
	case devicefingerprint.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case devicefingerprint.FieldUserID:
		m.ClearUserID()
		return nil
	case devicefingerprint.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case devicefingerprint.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case devicefingerprint.FieldBlockReason:
		m.ClearBlockReason()
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceFingerprintMutation) ResetField(name string) error {
	switch name {
	case devicefingerprint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicefingerprint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case devicefingerprint.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case devicefingerprint.FieldFingerprintHash:
		m.ResetFingerprintHash()
		return nil
	case devicefingerprint.FieldUserID:
		m.ResetUserID()
		return nil
	case devicefingerprint.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case devicefingerprint.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case devicefingerprint.FieldAccountCount:
		m.ResetAccountCount()
		return nil
	case devicefingerprint.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	case devicefingerprint.FieldBlocked:
		m.ResetBlocked()
		return nil
	case devicefingerprint.FieldBlockReason:
		m.ResetBlockReason()
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceFingerprintMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, devicefingerprint.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceFingerprintMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicefingerprint.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceFingerprintMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceFingerprintMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceFingerprintMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, devicefingerprint.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceFingerprintMutation) EdgeCleared(name string) bool {
	switch name {
	case devicefingerprint.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceFingerprintMutation) ClearEdge(name string) error {
	switch name {
	case devicefingerprint.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceFingerprintMutation) ResetEdge(name string) error {
	switch name {
	case devicefingerprint.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint edge %s", name)
}

// DeviceUserMappingMutation represents an operation that mutates the DeviceUserMapping nodes in the graph.
type DeviceUserMappingMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	fingerprint_hash *string
	first_seen_at    *time.Time
	last_seen_at     *time.Time
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*DeviceUserMapping, error)
	predicates       []predicate.DeviceUserMapping
}

var _ ent.Mutation = (*DeviceUserMappingMutation)(nil)

// deviceusermappingOption allows management of the mutation configuration using functional options.
type deviceusermappingOption func(*DeviceUserMappingMutation)

// newDeviceUserMappingMutation creates new mutation for the DeviceUserMapping entity.
func newDeviceUserMappingMutation(c config, op Op, opts ...deviceusermappingOption) *DeviceUserMappingMutation {
	m := &DeviceUserMappingMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceUserMapping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceUserMappingID sets the ID field of the mutation.
func withDeviceUserMappingID(id int) deviceusermappingOption {
	return func(m *DeviceUserMappingMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceUserMapping
		)
		m.oldValue = func(ctx context.Context) (*DeviceUserMapping, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceUserMapping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceUserMapping sets the old DeviceUserMapping of the mutation.
func withDeviceUserMapping(node *DeviceUserMapping) deviceusermappingOption {
	return func(m *DeviceUserMappingMutation) {
		m.oldValue = func(context.Context) (*DeviceUserMapping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceUserMappingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceUserMappingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceUserMappingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceUserMappingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceUserMapping.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceUserMappingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceUserMappingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceUserMappingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceUserMappingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceUserMappingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceUserMappingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceUserMappingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceUserMappingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DeviceUserMappingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[deviceusermapping.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DeviceUserMappingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[deviceusermapping.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceUserMappingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, deviceusermapping.FieldDeletedAt)
}

// SetFingerprintHash sets the "fingerprint_hash" field.
func (m *DeviceUserMappingMutation) SetFingerprintHash(s string) {
	m.fingerprint_hash = &s
}

// FingerprintHash returns the value of the "fingerprint_hash" field in the mutation.
func (m *DeviceUserMappingMutation) FingerprintHash() (r string, exists bool) {
	v := m.fingerprint_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprintHash returns the old "fingerprint_hash" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldFingerprintHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprintHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprintHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprintHash: %w", err)
	}
	return oldValue.FingerprintHash, nil
}

// ResetFingerprintHash resets all changes to the "fingerprint_hash" field.
func (m *DeviceUserMappingMutation) ResetFingerprintHash() {
	m.fingerprint_hash = nil
}

// SetUserID sets the "user_id" field.
func (m *DeviceUserMappingMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DeviceUserMappingMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DeviceUserMappingMutation) ResetUserID() {
	m.user = nil
}

// SetFirstSeenAt sets the "first_seen_at" field.
func (m *DeviceUserMappingMutation) SetFirstSeenAt(t time.Time) {
	m.first_seen_at = &t
}

// FirstSeenAt returns the value of the "first_seen_at" field in the mutation.
func (m *DeviceUserMappingMutation) FirstSeenAt() (r time.Time, exists bool) {
	v := m.first_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstSeenAt returns the old "first_seen_at" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldFirstSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstSeenAt: %w", err)
	}
	return oldValue.FirstSeenAt, nil
}

// ResetFirstSeenAt resets all changes to the "first_seen_at" field.
func (m *DeviceUserMappingMutation) ResetFirstSeenAt() {
	m.first_seen_at = nil
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *DeviceUserMappingMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *DeviceUserMappingMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldLastSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *DeviceUserMappingMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeviceUserMappingMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[deviceusermapping.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeviceUserMappingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeviceUserMappingMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeviceUserMappingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the DeviceUserMappingMutation builder.
func (m *DeviceUserMappingMutation) Where(ps ...predicate.DeviceUserMapping) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceUserMappingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceUserMappingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceUserMapping, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceUserMappingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceUserMappingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceUserMapping).
func (m *DeviceUserMappingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceUserMappingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, deviceusermapping.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceusermapping.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, deviceusermapping.FieldDeletedAt)
	}
	if m.fingerprint_hash != nil {
		fields = append(fields, deviceusermapping.FieldFingerprintHash)
	}
	if m.user != nil {
		fields = append(fields, deviceusermapping.FieldUserID)
	}
	if m.first_seen_at != nil {
		fields = append(fields, deviceusermapping.FieldFirstSeenAt)
	}
	if m.last_seen_at != nil {
		fields = append(fields, deviceusermapping.FieldLastSeenAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceUserMappingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceusermapping.FieldCreatedAt:
		return m.CreatedAt()
	case deviceusermapping.FieldUpdatedAt:
		return m.UpdatedAt()
	case deviceusermapping.FieldDeletedAt:
		return m.DeletedAt()
	case deviceusermapping.FieldFingerprintHash:
		return m.FingerprintHash()
	case deviceusermapping.FieldUserID:
		return m.UserID()
	case deviceusermapping.FieldFirstSeenAt:
		return m.FirstSeenAt()
	case deviceusermapping.FieldLastSeenAt:
		return m.LastSeenAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceUserMappingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceusermapping.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceusermapping.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deviceusermapping.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case deviceusermapping.FieldFingerprintHash:
		return m.OldFingerprintHash(ctx)
	case deviceusermapping.FieldUserID:
		return m.OldUserID(ctx)
	case deviceusermapping.FieldFirstSeenAt:
		return m.OldFirstSeenAt(ctx)
	case deviceusermapping.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceUserMapping field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceUserMappingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceusermapping.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceusermapping.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deviceusermapping.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case deviceusermapping.FieldFingerprintHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprintHash(v)
		return nil
	case deviceusermapping.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case deviceusermapping.FieldFirstSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstSeenAt(v)
		return nil
	case deviceusermapping.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceUserMapping field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceUserMappingMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceUserMappingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceUserMappingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceUserMapping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceUserMappingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceusermapping.FieldDeletedAt) {
		fields = append(fields, deviceusermapping.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceUserMappingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceUserMappingMutation) ClearField(name string) error {
	switch name {
	case deviceusermapping.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceUserMapping nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceUserMappingMutation) ResetField(name string) error {
	switch name {
	case deviceusermapping.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceusermapping.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deviceusermapping.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case deviceusermapping.FieldFingerprintHash:
		m.ResetFingerprintHash()
		return nil
	case deviceusermapping.FieldUserID:
		m.ResetUserID()
		return nil
	case deviceusermapping.FieldFirstSeenAt:
		m.ResetFirstSeenAt()
		return nil
	case deviceusermapping.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceUserMapping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceUserMappingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, deviceusermapping.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceUserMappingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceusermapping.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceUserMappingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceUserMappingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceUserMappingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, deviceusermapping.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceUserMappingMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceusermapping.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceUserMappingMutation) ClearEdge(name string) error {
	switch name {
	case deviceusermapping.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown DeviceUserMapping unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceUserMappingMutation) ResetEdge(name string) error {
	switch name {
	case deviceusermapping.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown DeviceUserMapping edge %s", name)
}

// EmailVerificationTokenMutation represents an operation that mutates the EmailVerificationToken nodes in the graph.
type EmailVerificationTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token_hash    *string
	expires_at    *time.Time
	used_at       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*EmailVerificationToken, error)
	predicates    []predicate.EmailVerificationToken
}

var _ ent.Mutation = (*EmailVerificationTokenMutation)(nil)

// emailverificationtokenOption allows management of the mutation configuration using functional options.
type emailverificationtokenOption func(*EmailVerificationTokenMutation)

// newEmailVerificationTokenMutation creates new mutation for the EmailVerificationToken entity.
func newEmailVerificationTokenMutation(c config, op Op, opts ...emailverificationtokenOption) *EmailVerificationTokenMutation {
	m := &EmailVerificationTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailVerificationToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailVerificationTokenID sets the ID field of the mutation.
func withEmailVerificationTokenID(id int) emailverificationtokenOption {
	return func(m *EmailVerificationTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailVerificationToken
		)
		m.oldValue = func(ctx context.Context) (*EmailVerificationToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailVerificationToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailVerificationToken sets the old EmailVerificationToken of the mutation.
func withEmailVerificationToken(node *EmailVerificationToken) emailverificationtokenOption {
	return func(m *EmailVerificationTokenMutation) {
		m.oldValue = func(context.Context) (*EmailVerificationToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailVerificationTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailVerificationTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailVerificationTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailVerificationTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailVerificationToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailVerificationTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailVerificationTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailVerificationTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailVerificationTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailVerificationTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailVerificationTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmailVerificationTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmailVerificationTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmailVerificationTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[emailverificationtoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmailVerificationTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[emailverificationtoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmailVerificationTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, emailverificationtoken.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *EmailVerificationTokenMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EmailVerificationTokenMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EmailVerificationTokenMutation) ResetUserID() {
	m.user = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *EmailVerificationTokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *EmailVerificationTokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *EmailVerificationTokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *EmailVerificationTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *EmailVerificationTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *EmailVerificationTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsedAt sets the "used_at" field.
func (m *EmailVerificationTokenMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *EmailVerificationTokenMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *EmailVerificationTokenMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[emailverificationtoken.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *EmailVerificationTokenMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[emailverificationtoken.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *EmailVerificationTokenMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, emailverificationtoken.FieldUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *EmailVerificationTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[emailverificationtoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EmailVerificationTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EmailVerificationTokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EmailVerificationTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the EmailVerificationTokenMutation builder.
func (m *EmailVerificationTokenMutation) Where(ps ...predicate.EmailVerificationToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailVerificationTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailVerificationTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailVerificationToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailVerificationTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailVerificationTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailVerificationToken).
func (m *EmailVerificationTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailVerificationTokenMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, emailverificationtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailverificationtoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, emailverificationtoken.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, emailverificationtoken.FieldUserID)
	}
	if m.token_hash != nil {
		fields = append(fields, emailverificationtoken.FieldTokenHash)
	}
	if m.expires_at != nil {
		fields = append(fields, emailverificationtoken.FieldExpiresAt)
	}
	if m.used_at != nil {
		fields = append(fields, emailverificationtoken.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailVerificationTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		return m.CreatedAt()
	case emailverificationtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailverificationtoken.FieldDeletedAt:
		return m.DeletedAt()
	case emailverificationtoken.FieldUserID:
		return m.UserID()
	case emailverificationtoken.FieldTokenHash:
		return m.TokenHash()
	case emailverificationtoken.FieldExpiresAt:
		return m.ExpiresAt()
	case emailverificationtoken.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailVerificationTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailverificationtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailverificationtoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case emailverificationtoken.FieldUserID:
		return m.OldUserID(ctx)
	case emailverificationtoken.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case emailverificationtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case emailverificationtoken.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailVerificationToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailVerificationTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailverificationtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailverificationtoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case emailverificationtoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case emailverificationtoken.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case emailverificationtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case emailverificationtoken.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailVerificationTokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailVerificationTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailVerificationTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailVerificationToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailVerificationTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailverificationtoken.FieldDeletedAt) {
		fields = append(fields, emailverificationtoken.FieldDeletedAt)
	}
	if m.FieldCleared(emailverificationtoken.FieldUsedAt) {
		fields = append(fields, emailverificationtoken.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailVerificationTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailVerificationTokenMutation) ClearField(name string) error {
	switch name {
	case emailverificationtoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case emailverificationtoken.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailVerificationTokenMutation) ResetField(name string) error {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailverificationtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailverificationtoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case emailverificationtoken.FieldUserID:
		m.ResetUserID()
		return nil
	case emailverificationtoken.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case emailverificationtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case emailverificationtoken.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailVerificationTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, emailverificationtoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailVerificationTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailverificationtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailVerificationTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailVerificationTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailVerificationTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, emailverificationtoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailVerificationTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case emailverificationtoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailVerificationTokenMutation) ClearEdge(name string) error {
	switch name {
	case emailverificationtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailVerificationTokenMutation) ResetEdge(name string) error {
	switch name {
	case emailverificationtoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken edge %s", name)
}

// EndorsementMutation represents an operation that mutates the Endorsement nodes in the graph.
type EndorsementMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	certified_artifact_document_id *string
	stance                         *string
	note                           *string
	clearedFields                  map[string]struct{}
	validation_case                *int
	clearedvalidation_case         bool
	validator_user                 *int
	clearedvalidator_user          bool
	done                           bool
	oldValue                       func(context.Context) (*Endorsement, error)
	predicates                     []predicate.Endorsement
}

var _ ent.Mutation = (*EndorsementMutation)(nil)

// endorsementOption allows management of the mutation configuration using functional options.
type endorsementOption func(*EndorsementMutation)

// newEndorsementMutation creates new mutation for the Endorsement entity.
func newEndorsementMutation(c config, op Op, opts ...endorsementOption) *EndorsementMutation {
	m := &EndorsementMutation{
		config:        c,
		op:            op,
		typ:           TypeEndorsement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEndorsementID sets the ID field of the mutation.
func withEndorsementID(id int) endorsementOption {
	return func(m *EndorsementMutation) {
		var (
			err   error
			once  sync.Once
			value *Endorsement
		)
		m.oldValue = func(ctx context.Context) (*Endorsement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Endorsement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEndorsement sets the old Endorsement of the mutation.
func withEndorsement(node *Endorsement) endorsementOption {
	return func(m *EndorsementMutation) {
		m.oldValue = func(context.Context) (*Endorsement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EndorsementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EndorsementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EndorsementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EndorsementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Endorsement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EndorsementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EndorsementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Endorsement entity.
// If the Endorsement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndorsementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EndorsementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EndorsementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EndorsementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Endorsement entity.
// If the Endorsement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndorsementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EndorsementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EndorsementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EndorsementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Endorsement entity.
// If the Endorsement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndorsementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EndorsementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[endorsement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EndorsementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[endorsement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EndorsementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, endorsement.FieldDeletedAt)
}

// SetValidationCaseID sets the "validation_case_id" field.
func (m *EndorsementMutation) SetValidationCaseID(i int) {
	m.validation_case = &i
}

// ValidationCaseID returns the value of the "validation_case_id" field in the mutation.
func (m *EndorsementMutation) ValidationCaseID() (r int, exists bool) {
	v := m.validation_case
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationCaseID returns the old "validation_case_id" field's value of the Endorsement entity.
// If the Endorsement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndorsementMutation) OldValidationCaseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationCaseID: %w", err)
	}
	return oldValue.ValidationCaseID, nil
}

// ResetValidationCaseID resets all changes to the "validation_case_id" field.
func (m *EndorsementMutation) ResetValidationCaseID() {
	m.validation_case = nil
}

// SetValidatorUserID sets the "validator_user_id" field.
func (m *EndorsementMutation) SetValidatorUserID(i int) {
	m.validator_user = &i
}

// ValidatorUserID returns the value of the "validator_user_id" field in the mutation.
func (m *EndorsementMutation) ValidatorUserID() (r int, exists bool) {
	v := m.validator_user
	if v == nil {
		return
	}
	return *v, true
}

// OldValidatorUserID returns the old "validator_user_id" field's value of the Endorsement entity.
// If the Endorsement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndorsementMutation) OldValidatorUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidatorUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidatorUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidatorUserID: %w", err)
	}
	return oldValue.ValidatorUserID, nil
}

// ResetValidatorUserID resets all changes to the "validator_user_id" field.
func (m *EndorsementMutation) ResetValidatorUserID() {
	m.validator_user = nil
}

// SetCertifiedArtifactDocumentID sets the "certified_artifact_document_id" field.
func (m *EndorsementMutation) SetCertifiedArtifactDocumentID(s string) {
	m.certified_artifact_document_id = &s
}

// CertifiedArtifactDocumentID returns the value of the "certified_artifact_document_id" field in the mutation.
func (m *EndorsementMutation) CertifiedArtifactDocumentID() (r string, exists bool) {
	v := m.certified_artifact_document_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCertifiedArtifactDocumentID returns the old "certified_artifact_document_id" field's value of the Endorsement entity.
// If the Endorsement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndorsementMutation) OldCertifiedArtifactDocumentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertifiedArtifactDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertifiedArtifactDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertifiedArtifactDocumentID: %w", err)
	}
	return oldValue.CertifiedArtifactDocumentID, nil
}

// ClearCertifiedArtifactDocumentID clears the value of the "certified_artifact_document_id" field.
func (m *EndorsementMutation) ClearCertifiedArtifactDocumentID() {
	m.certified_artifact_document_id = nil
	m.clearedFields[endorsement.FieldCertifiedArtifactDocumentID] = struct{}{}
}

// CertifiedArtifactDocumentIDCleared returns if the "certified_artifact_document_id" field was cleared in this mutation.
func (m *EndorsementMutation) CertifiedArtifactDocumentIDCleared() bool {
	_, ok := m.clearedFields[endorsement.FieldCertifiedArtifactDocumentID]
	return ok
}

// ResetCertifiedArtifactDocumentID resets all changes to the "certified_artifact_document_id" field.
func (m *EndorsementMutation) ResetCertifiedArtifactDocumentID() {
	m.certified_artifact_document_id = nil
	delete(m.clearedFields, endorsement.FieldCertifiedArtifactDocumentID)
}

// SetStance sets the "stance" field.
func (m *EndorsementMutation) SetStance(s string) {
	m.stance = &s
}

// Stance returns the value of the "stance" field in the mutation.
func (m *EndorsementMutation) Stance() (r string, exists bool) {
	v := m.stance
	if v == nil {
		return
	}
	return *v, true
}

// OldStance returns the old "stance" field's value of the Endorsement entity.
// If the Endorsement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndorsementMutation) OldStance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStance: %w", err)
	}
	return oldValue.Stance, nil
}

// ClearStance clears the value of the "stance" field.
func (m *EndorsementMutation) ClearStance() {
	m.stance = nil
	m.clearedFields[endorsement.FieldStance] = struct{}{}
}

// StanceCleared returns if the "stance" field was cleared in this mutation.
func (m *EndorsementMutation) StanceCleared() bool {
	_, ok := m.clearedFields[endorsement.FieldStance]
	return ok
}

// ResetStance resets all changes to the "stance" field.
func (m *EndorsementMutation) ResetStance() {
	m.stance = nil
	delete(m.clearedFields, endorsement.FieldStance)
}

// SetNote sets the "note" field.
func (m *EndorsementMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *EndorsementMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Endorsement entity.
// If the Endorsement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EndorsementMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *EndorsementMutation) ClearNote() {
	m.note = nil
	m.clearedFields[endorsement.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *EndorsementMutation) NoteCleared() bool {
	_, ok := m.clearedFields[endorsement.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *EndorsementMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, endorsement.FieldNote)
}

// ClearValidationCase clears the "validation_case" edge to the ValidationCase entity.
func (m *EndorsementMutation) ClearValidationCase() {
	m.clearedvalidation_case = true
	m.clearedFields[endorsement.FieldValidationCaseID] = struct{}{}
}

// ValidationCaseCleared reports if the "validation_case" edge to the ValidationCase entity was cleared.
func (m *EndorsementMutation) ValidationCaseCleared() bool {
	return m.clearedvalidation_case
}

// ValidationCaseIDs returns the "validation_case" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValidationCaseID instead. It exists only for internal usage by the builders.
func (m *EndorsementMutation) ValidationCaseIDs() (ids []int) {
	if id := m.validation_case; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValidationCase resets all changes to the "validation_case" edge.
func (m *EndorsementMutation) ResetValidationCase() {
	m.validation_case = nil
	m.clearedvalidation_case = false
}

// ClearValidatorUser clears the "validator_user" edge to the User entity.
func (m *EndorsementMutation) ClearValidatorUser() {
	m.clearedvalidator_user = true
	m.clearedFields[endorsement.FieldValidatorUserID] = struct{}{}
}

// ValidatorUserCleared reports if the "validator_user" edge to the User entity was cleared.
func (m *EndorsementMutation) ValidatorUserCleared() bool {
	return m.clearedvalidator_user
}

// ValidatorUserIDs returns the "validator_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValidatorUserID instead. It exists only for internal usage by the builders.
func (m *EndorsementMutation) ValidatorUserIDs() (ids []int) {
	if id := m.validator_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValidatorUser resets all changes to the "validator_user" edge.
func (m *EndorsementMutation) ResetValidatorUser() {
	m.validator_user = nil
	m.clearedvalidator_user = false
}

// Where appends a list predicates to the EndorsementMutation builder.
func (m *EndorsementMutation) Where(ps ...predicate.Endorsement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EndorsementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EndorsementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Endorsement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EndorsementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EndorsementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Endorsement).
func (m *EndorsementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EndorsementMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, endorsement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, endorsement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, endorsement.FieldDeletedAt)
	}
	if m.validation_case != nil {
		fields = append(fields, endorsement.FieldValidationCaseID)
	}
	if m.validator_user != nil {
		fields = append(fields, endorsement.FieldValidatorUserID)
	}
	if m.certified_artifact_document_id != nil {
		fields = append(fields, endorsement.FieldCertifiedArtifactDocumentID)
	}
	if m.stance != nil {
		fields = append(fields, endorsement.FieldStance)
	}
	if m.note != nil {
		fields = append(fields, endorsement.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EndorsementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case endorsement.FieldCreatedAt:
		return m.CreatedAt()
	case endorsement.FieldUpdatedAt:
		return m.UpdatedAt()
	case endorsement.FieldDeletedAt:
		return m.DeletedAt()
	case endorsement.FieldValidationCaseID:
		return m.ValidationCaseID()
	case endorsement.FieldValidatorUserID:
		return m.ValidatorUserID()
	case endorsement.FieldCertifiedArtifactDocumentID:
		return m.CertifiedArtifactDocumentID()
	case endorsement.FieldStance:
		return m.Stance()
	case endorsement.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EndorsementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case endorsement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case endorsement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case endorsement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case endorsement.FieldValidationCaseID:
		return m.OldValidationCaseID(ctx)
	case endorsement.FieldValidatorUserID:
		return m.OldValidatorUserID(ctx)
	case endorsement.FieldCertifiedArtifactDocumentID:
		return m.OldCertifiedArtifactDocumentID(ctx)
	case endorsement.FieldStance:
		return m.OldStance(ctx)
	case endorsement.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown Endorsement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EndorsementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case endorsement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case endorsement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case endorsement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case endorsement.FieldValidationCaseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationCaseID(v)
		return nil
	case endorsement.FieldValidatorUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidatorUserID(v)
		return nil
	case endorsement.FieldCertifiedArtifactDocumentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertifiedArtifactDocumentID(v)
		return nil
	case endorsement.FieldStance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStance(v)
		return nil
	case endorsement.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown Endorsement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EndorsementMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EndorsementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EndorsementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Endorsement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EndorsementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(endorsement.FieldDeletedAt) {
		fields = append(fields, endorsement.FieldDeletedAt)
	}
	if m.FieldCleared(endorsement.FieldCertifiedArtifactDocumentID) {
		fields = append(fields, endorsement.FieldCertifiedArtifactDocumentID)
	}
	if m.FieldCleared(endorsement.FieldStance) {
		fields = append(fields, endorsement.FieldStance)
	}
	if m.FieldCleared(endorsement.FieldNote) {
		fields = append(fields, endorsement.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EndorsementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EndorsementMutation) ClearField(name string) error {
	switch name {
	case endorsement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case endorsement.FieldCertifiedArtifactDocumentID:
		m.ClearCertifiedArtifactDocumentID()
		return nil
	case endorsement.FieldStance:
		m.ClearStance()
		return nil
	case endorsement.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown Endorsement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EndorsementMutation) ResetField(name string) error {
	switch name {
	case endorsement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case endorsement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case endorsement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case endorsement.FieldValidationCaseID:
		m.ResetValidationCaseID()
		return nil
	case endorsement.FieldValidatorUserID:
		m.ResetValidatorUserID()
		return nil
	case endorsement.FieldCertifiedArtifactDocumentID:
		m.ResetCertifiedArtifactDocumentID()
		return nil
	case endorsement.FieldStance:
		m.ResetStance()
		return nil
	case endorsement.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown Endorsement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EndorsementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.validation_case != nil {
		edges = append(edges, endorsement.EdgeValidationCase)
	}
	if m.validator_user != nil {
		edges = append(edges, endorsement.EdgeValidatorUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EndorsementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case endorsement.EdgeValidationCase:
		if id := m.validation_case; id != nil {
			return []ent.Value{*id}
		}
	case endorsement.EdgeValidatorUser:
		if id := m.validator_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EndorsementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EndorsementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EndorsementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvalidation_case {
		edges = append(edges, endorsement.EdgeValidationCase)
	}
	if m.clearedvalidator_user {
		edges = append(edges, endorsement.EdgeValidatorUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EndorsementMutation) EdgeCleared(name string) bool {
	switch name {
	case endorsement.EdgeValidationCase:
		return m.clearedvalidation_case
	case endorsement.EdgeValidatorUser:
		return m.clearedvalidator_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EndorsementMutation) ClearEdge(name string) error {
	switch name {
	case endorsement.EdgeValidationCase:
		m.ClearValidationCase()
		return nil
	case endorsement.EdgeValidatorUser:
		m.ClearValidatorUser()
		return nil
	}
	return fmt.Errorf("unknown Endorsement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EndorsementMutation) ResetEdge(name string) error {
	switch name {
	case endorsement.EdgeValidationCase:
		m.ResetValidationCase()
		return nil
	case endorsement.EdgeValidatorUser:
		m.ResetValidatorUser()
		return nil
	}
	return fmt.Errorf("unknown Endorsement edge %s", name)
}

// FinalOfferMutation represents an operation that mutates the FinalOffer nodes in the graph.
type FinalOfferMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	submission_key         *string
	workflow_cycle         *int
	addworkflow_cycle      *int
	amount                 *int64
	addamount              *int64
	hold_hours             *int
	addhold_hours          *int
	terms                  *string
	status                 *string
	accepted_at            *time.Time
	rejected_at            *time.Time
	clearedFields          map[string]struct{}
	validation_case        *int
	clearedvalidation_case bool
	validator_user         *int
	clearedvalidator_user  bool
	done                   bool
	oldValue               func(context.Context) (*FinalOffer, error)
	predicates             []predicate.FinalOffer
}

var _ ent.Mutation = (*FinalOfferMutation)(nil)

// finalofferOption allows management of the mutation configuration using functional options.
type finalofferOption func(*FinalOfferMutation)

// newFinalOfferMutation creates new mutation for the FinalOffer entity.
func newFinalOfferMutation(c config, op Op, opts ...finalofferOption) *FinalOfferMutation {
	m := &FinalOfferMutation{
		config:        c,
		op:            op,
		typ:           TypeFinalOffer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFinalOfferID sets the ID field of the mutation.
func withFinalOfferID(id int) finalofferOption {
	return func(m *FinalOfferMutation) {
		var (
			err   error
			once  sync.Once
			value *FinalOffer
		)
		m.oldValue = func(ctx context.Context) (*FinalOffer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FinalOffer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFinalOffer sets the old FinalOffer of the mutation.
func withFinalOffer(node *FinalOffer) finalofferOption {
	return func(m *FinalOfferMutation) {
		m.oldValue = func(context.Context) (*FinalOffer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FinalOfferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FinalOfferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FinalOfferMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FinalOfferMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FinalOffer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FinalOfferMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FinalOfferMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FinalOfferMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FinalOfferMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FinalOfferMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FinalOfferMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FinalOfferMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FinalOfferMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FinalOfferMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[finaloffer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FinalOfferMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[finaloffer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FinalOfferMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, finaloffer.FieldDeletedAt)
}

// SetValidationCaseID sets the "validation_case_id" field.
func (m *FinalOfferMutation) SetValidationCaseID(i int) {
	m.validation_case = &i
}

// ValidationCaseID returns the value of the "validation_case_id" field in the mutation.
func (m *FinalOfferMutation) ValidationCaseID() (r int, exists bool) {
	v := m.validation_case
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationCaseID returns the old "validation_case_id" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldValidationCaseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationCaseID: %w", err)
	}
	return oldValue.ValidationCaseID, nil
}

// ResetValidationCaseID resets all changes to the "validation_case_id" field.
func (m *FinalOfferMutation) ResetValidationCaseID() {
	m.validation_case = nil
}

// SetValidatorUserID sets the "validator_user_id" field.
func (m *FinalOfferMutation) SetValidatorUserID(i int) {
	m.validator_user = &i
}

// ValidatorUserID returns the value of the "validator_user_id" field in the mutation.
func (m *FinalOfferMutation) ValidatorUserID() (r int, exists bool) {
	v := m.validator_user
	if v == nil {
		return
	}
	return *v, true
}

// OldValidatorUserID returns the old "validator_user_id" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldValidatorUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidatorUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidatorUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidatorUserID: %w", err)
	}
	return oldValue.ValidatorUserID, nil
}

// ResetValidatorUserID resets all changes to the "validator_user_id" field.
func (m *FinalOfferMutation) ResetValidatorUserID() {
	m.validator_user = nil
}

// SetSubmissionKey sets the "submission_key" field.
func (m *FinalOfferMutation) SetSubmissionKey(s string) {
	m.submission_key = &s
}

// SubmissionKey returns the value of the "submission_key" field in the mutation.
func (m *FinalOfferMutation) SubmissionKey() (r string, exists bool) {
	v := m.submission_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmissionKey returns the old "submission_key" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldSubmissionKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmissionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmissionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmissionKey: %w", err)
	}
	return oldValue.SubmissionKey, nil
}

// ClearSubmissionKey clears the value of the "submission_key" field.
func (m *FinalOfferMutation) ClearSubmissionKey() {
	m.submission_key = nil
	m.clearedFields[finaloffer.FieldSubmissionKey] = struct{}{}
}

// SubmissionKeyCleared returns if the "submission_key" field was cleared in this mutation.
func (m *FinalOfferMutation) SubmissionKeyCleared() bool {
	_, ok := m.clearedFields[finaloffer.FieldSubmissionKey]
	return ok
}

// ResetSubmissionKey resets all changes to the "submission_key" field.
func (m *FinalOfferMutation) ResetSubmissionKey() {
	m.submission_key = nil
	delete(m.clearedFields, finaloffer.FieldSubmissionKey)
}

// SetWorkflowCycle sets the "workflow_cycle" field.
func (m *FinalOfferMutation) SetWorkflowCycle(i int) {
	m.workflow_cycle = &i
	m.addworkflow_cycle = nil
}

// WorkflowCycle returns the value of the "workflow_cycle" field in the mutation.
func (m *FinalOfferMutation) WorkflowCycle() (r int, exists bool) {
	v := m.workflow_cycle
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowCycle returns the old "workflow_cycle" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldWorkflowCycle(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowCycle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowCycle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowCycle: %w", err)
	}
	return oldValue.WorkflowCycle, nil
}

// AddWorkflowCycle adds i to the "workflow_cycle" field.
func (m *FinalOfferMutation) AddWorkflowCycle(i int) {
	if m.addworkflow_cycle != nil {
		*m.addworkflow_cycle += i
	} else {
		m.addworkflow_cycle = &i
	}
}

// AddedWorkflowCycle returns the value that was added to the "workflow_cycle" field in this mutation.
func (m *FinalOfferMutation) AddedWorkflowCycle() (r int, exists bool) {
	v := m.addworkflow_cycle
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorkflowCycle resets all changes to the "workflow_cycle" field.
func (m *FinalOfferMutation) ResetWorkflowCycle() {
	m.workflow_cycle = nil
	m.addworkflow_cycle = nil
}

// SetAmount sets the "amount" field.
func (m *FinalOfferMutation) SetAmount(i int64) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *FinalOfferMutation) Amount() (r int64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *FinalOfferMutation) AddAmount(i int64) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *FinalOfferMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *FinalOfferMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetHoldHours sets the "hold_hours" field.
func (m *FinalOfferMutation) SetHoldHours(i int) {
	m.hold_hours = &i
	m.addhold_hours = nil
}

// HoldHours returns the value of the "hold_hours" field in the mutation.
func (m *FinalOfferMutation) HoldHours() (r int, exists bool) {
	v := m.hold_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldHoldHours returns the old "hold_hours" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldHoldHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHoldHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHoldHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHoldHours: %w", err)
	}
	return oldValue.HoldHours, nil
}

// AddHoldHours adds i to the "hold_hours" field.
func (m *FinalOfferMutation) AddHoldHours(i int) {
	if m.addhold_hours != nil {
		*m.addhold_hours += i
	} else {
		m.addhold_hours = &i
	}
}

// AddedHoldHours returns the value that was added to the "hold_hours" field in this mutation.
func (m *FinalOfferMutation) AddedHoldHours() (r int, exists bool) {
	v := m.addhold_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetHoldHours resets all changes to the "hold_hours" field.
func (m *FinalOfferMutation) ResetHoldHours() {
	m.hold_hours = nil
	m.addhold_hours = nil
}

// SetTerms sets the "terms" field.
func (m *FinalOfferMutation) SetTerms(s string) {
	m.terms = &s
}

// Terms returns the value of the "terms" field in the mutation.
func (m *FinalOfferMutation) Terms() (r string, exists bool) {
	v := m.terms
	if v == nil {
		return
	}
	return *v, true
}

// OldTerms returns the old "terms" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldTerms(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTerms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerms: %w", err)
	}
	return oldValue.Terms, nil
}

// ClearTerms clears the value of the "terms" field.
func (m *FinalOfferMutation) ClearTerms() {
	m.terms = nil
	m.clearedFields[finaloffer.FieldTerms] = struct{}{}
}

// TermsCleared returns if the "terms" field was cleared in this mutation.
func (m *FinalOfferMutation) TermsCleared() bool {
	_, ok := m.clearedFields[finaloffer.FieldTerms]
	return ok
}

// ResetTerms resets all changes to the "terms" field.
func (m *FinalOfferMutation) ResetTerms() {
	m.terms = nil
	delete(m.clearedFields, finaloffer.FieldTerms)
}

// SetStatus sets the "status" field.
func (m *FinalOfferMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *FinalOfferMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FinalOfferMutation) ResetStatus() {
	m.status = nil
}

// SetAcceptedAt sets the "accepted_at" field.
func (m *FinalOfferMutation) SetAcceptedAt(t time.Time) {
	m.accepted_at = &t
}

// AcceptedAt returns the value of the "accepted_at" field in the mutation.
func (m *FinalOfferMutation) AcceptedAt() (r time.Time, exists bool) {
	v := m.accepted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedAt returns the old "accepted_at" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldAcceptedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedAt: %w", err)
	}
	return oldValue.AcceptedAt, nil
}

// ClearAcceptedAt clears the value of the "accepted_at" field.
func (m *FinalOfferMutation) ClearAcceptedAt() {
	m.accepted_at = nil
	m.clearedFields[finaloffer.FieldAcceptedAt] = struct{}{}
}

// AcceptedAtCleared returns if the "accepted_at" field was cleared in this mutation.
func (m *FinalOfferMutation) AcceptedAtCleared() bool {
	_, ok := m.clearedFields[finaloffer.FieldAcceptedAt]
	return ok
}

// ResetAcceptedAt resets all changes to the "accepted_at" field.
func (m *FinalOfferMutation) ResetAcceptedAt() {
	m.accepted_at = nil
	delete(m.clearedFields, finaloffer.FieldAcceptedAt)
}

// SetRejectedAt sets the "rejected_at" field.
func (m *FinalOfferMutation) SetRejectedAt(t time.Time) {
	m.rejected_at = &t
}

// RejectedAt returns the value of the "rejected_at" field in the mutation.
func (m *FinalOfferMutation) RejectedAt() (r time.Time, exists bool) {
	v := m.rejected_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectedAt returns the old "rejected_at" field's value of the FinalOffer entity.
// If the FinalOffer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FinalOfferMutation) OldRejectedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectedAt: %w", err)
	}
	return oldValue.RejectedAt, nil
}

// ClearRejectedAt clears the value of the "rejected_at" field.
func (m *FinalOfferMutation) ClearRejectedAt() {
	m.rejected_at = nil
	m.clearedFields[finaloffer.FieldRejectedAt] = struct{}{}
}

// RejectedAtCleared returns if the "rejected_at" field was cleared in this mutation.
func (m *FinalOfferMutation) RejectedAtCleared() bool {
	_, ok := m.clearedFields[finaloffer.FieldRejectedAt]
	return ok
}

// ResetRejectedAt resets all changes to the "rejected_at" field.
func (m *FinalOfferMutation) ResetRejectedAt() {
	m.rejected_at = nil
	delete(m.clearedFields, finaloffer.FieldRejectedAt)
}

// ClearValidationCase clears the "validation_case" edge to the ValidationCase entity.
func (m *FinalOfferMutation) ClearValidationCase() {
	m.clearedvalidation_case = true
	m.clearedFields[finaloffer.FieldValidationCaseID] = struct{}{}
}

// ValidationCaseCleared reports if the "validation_case" edge to the ValidationCase entity was cleared.
func (m *FinalOfferMutation) ValidationCaseCleared() bool {
	return m.clearedvalidation_case
}

// ValidationCaseIDs returns the "validation_case" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValidationCaseID instead. It exists only for internal usage by the builders.
func (m *FinalOfferMutation) ValidationCaseIDs() (ids []int) {
	if id := m.validation_case; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValidationCase resets all changes to the "validation_case" edge.
func (m *FinalOfferMutation) ResetValidationCase() {
	m.validation_case = nil
	m.clearedvalidation_case = false
}

// ClearValidatorUser clears the "validator_user" edge to the User entity.
func (m *FinalOfferMutation) ClearValidatorUser() {
	m.clearedvalidator_user = true
	m.clearedFields[finaloffer.FieldValidatorUserID] = struct{}{}
}

// ValidatorUserCleared reports if the "validator_user" edge to the User entity was cleared.
func (m *FinalOfferMutation) ValidatorUserCleared() bool {
	return m.clearedvalidator_user
}

// ValidatorUserIDs returns the "validator_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValidatorUserID instead. It exists only for internal usage by the builders.
func (m *FinalOfferMutation) ValidatorUserIDs() (ids []int) {
	if id := m.validator_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValidatorUser resets all changes to the "validator_user" edge.
func (m *FinalOfferMutation) ResetValidatorUser() {
	m.validator_user = nil
	m.clearedvalidator_user = false
}

// Where appends a list predicates to the FinalOfferMutation builder.
func (m *FinalOfferMutation) Where(ps ...predicate.FinalOffer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FinalOfferMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FinalOfferMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FinalOffer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FinalOfferMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FinalOfferMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FinalOffer).
func (m *FinalOfferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FinalOfferMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, finaloffer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, finaloffer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, finaloffer.FieldDeletedAt)
	}
	if m.validation_case != nil {
		fields = append(fields, finaloffer.FieldValidationCaseID)
	}
	if m.validator_user != nil {
		fields = append(fields, finaloffer.FieldValidatorUserID)
	}
	if m.submission_key != nil {
		fields = append(fields, finaloffer.FieldSubmissionKey)
	}
	if m.workflow_cycle != nil {
		fields = append(fields, finaloffer.FieldWorkflowCycle)
	}
	if m.amount != nil {
		fields = append(fields, finaloffer.FieldAmount)
	}
	if m.hold_hours != nil {
		fields = append(fields, finaloffer.FieldHoldHours)
	}
	if m.terms != nil {
		fields = append(fields, finaloffer.FieldTerms)
	}
	if m.status != nil {
		fields = append(fields, finaloffer.FieldStatus)
	}
	if m.accepted_at != nil {
		fields = append(fields, finaloffer.FieldAcceptedAt)
	}
	if m.rejected_at != nil {
		fields = append(fields, finaloffer.FieldRejectedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FinalOfferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case finaloffer.FieldCreatedAt:
		return m.CreatedAt()
	case finaloffer.FieldUpdatedAt:
		return m.UpdatedAt()
	case finaloffer.FieldDeletedAt:
		return m.DeletedAt()
	case finaloffer.FieldValidationCaseID:
		return m.ValidationCaseID()
	case finaloffer.FieldValidatorUserID:
		return m.ValidatorUserID()
	case finaloffer.FieldSubmissionKey:
		return m.SubmissionKey()
	case finaloffer.FieldWorkflowCycle:
		return m.WorkflowCycle()
	case finaloffer.FieldAmount:
		return m.Amount()
	case finaloffer.FieldHoldHours:
		return m.HoldHours()
	case finaloffer.FieldTerms:
		return m.Terms()
	case finaloffer.FieldStatus:
		return m.Status()
	case finaloffer.FieldAcceptedAt:
		return m.AcceptedAt()
	case finaloffer.FieldRejectedAt:
		return m.RejectedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FinalOfferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case finaloffer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case finaloffer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case finaloffer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case finaloffer.FieldValidationCaseID:
		return m.OldValidationCaseID(ctx)
	case finaloffer.FieldValidatorUserID:
		return m.OldValidatorUserID(ctx)
	case finaloffer.FieldSubmissionKey:
		return m.OldSubmissionKey(ctx)
	case finaloffer.FieldWorkflowCycle:
		return m.OldWorkflowCycle(ctx)
	case finaloffer.FieldAmount:
		return m.OldAmount(ctx)
	case finaloffer.FieldHoldHours:
		return m.OldHoldHours(ctx)
	case finaloffer.FieldTerms:
		return m.OldTerms(ctx)
	case finaloffer.FieldStatus:
		return m.OldStatus(ctx)
	case finaloffer.FieldAcceptedAt:
		return m.OldAcceptedAt(ctx)
	case finaloffer.FieldRejectedAt:
		return m.OldRejectedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FinalOffer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FinalOfferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case finaloffer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case finaloffer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case finaloffer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case finaloffer.FieldValidationCaseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationCaseID(v)
		return nil
	case finaloffer.FieldValidatorUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidatorUserID(v)
		return nil
	case finaloffer.FieldSubmissionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmissionKey(v)
		return nil
	case finaloffer.FieldWorkflowCycle:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowCycle(v)
		return nil
	case finaloffer.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case finaloffer.FieldHoldHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHoldHours(v)
		return nil
	case finaloffer.FieldTerms:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerms(v)
		return nil
	case finaloffer.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case finaloffer.FieldAcceptedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedAt(v)
		return nil
	case finaloffer.FieldRejectedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FinalOffer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FinalOfferMutation) AddedFields() []string {
	var fields []string
	if m.addworkflow_cycle != nil {
		fields = append(fields, finaloffer.FieldWorkflowCycle)
	}
	if m.addamount != nil {
		fields = append(fields, finaloffer.FieldAmount)
	}
	if m.addhold_hours != nil {
		fields = append(fields, finaloffer.FieldHoldHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FinalOfferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case finaloffer.FieldWorkflowCycle:
		return m.AddedWorkflowCycle()
	case finaloffer.FieldAmount:
		return m.AddedAmount()
	case finaloffer.FieldHoldHours:
		return m.AddedHoldHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FinalOfferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case finaloffer.FieldWorkflowCycle:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkflowCycle(v)
		return nil
	case finaloffer.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case finaloffer.FieldHoldHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHoldHours(v)
		return nil
	}
	return fmt.Errorf("unknown FinalOffer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FinalOfferMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(finaloffer.FieldDeletedAt) {
		fields = append(fields, finaloffer.FieldDeletedAt)
	}
	if m.FieldCleared(finaloffer.FieldSubmissionKey) {
		fields = append(fields, finaloffer.FieldSubmissionKey)
	}
	if m.FieldCleared(finaloffer.FieldTerms) {
		fields = append(fields, finaloffer.FieldTerms)
	}
	if m.FieldCleared(finaloffer.FieldAcceptedAt) {
		fields = append(fields, finaloffer.FieldAcceptedAt)
	}
	if m.FieldCleared(finaloffer.FieldRejectedAt) {
		fields = append(fields, finaloffer.FieldRejectedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FinalOfferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FinalOfferMutation) ClearField(name string) error {
	switch name {
	case finaloffer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case finaloffer.FieldSubmissionKey:
		m.ClearSubmissionKey()
		return nil
	case finaloffer.FieldTerms:
		m.ClearTerms()
		return nil
	case finaloffer.FieldAcceptedAt:
		m.ClearAcceptedAt()
		return nil
	case finaloffer.FieldRejectedAt:
		m.ClearRejectedAt()
		return nil
	}
	return fmt.Errorf("unknown FinalOffer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FinalOfferMutation) ResetField(name string) error {
	switch name {
	case finaloffer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case finaloffer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case finaloffer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case finaloffer.FieldValidationCaseID:
		m.ResetValidationCaseID()
		return nil
	case finaloffer.FieldValidatorUserID:
		m.ResetValidatorUserID()
		return nil
	case finaloffer.FieldSubmissionKey:
		m.ResetSubmissionKey()
		return nil
	case finaloffer.FieldWorkflowCycle:
		m.ResetWorkflowCycle()
		return nil
	case finaloffer.FieldAmount:
		m.ResetAmount()
		return nil
	case finaloffer.FieldHoldHours:
		m.ResetHoldHours()
		return nil
	case finaloffer.FieldTerms:
		m.ResetTerms()
		return nil
	case finaloffer.FieldStatus:
		m.ResetStatus()
		return nil
	case finaloffer.FieldAcceptedAt:
		m.ResetAcceptedAt()
		return nil
	case finaloffer.FieldRejectedAt:
		m.ResetRejectedAt()
		return nil
	}
	return fmt.Errorf("unknown FinalOffer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FinalOfferMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.validation_case != nil {
		edges = append(edges, finaloffer.EdgeValidationCase)
	}
	if m.validator_user != nil {
		edges = append(edges, finaloffer.EdgeValidatorUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FinalOfferMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case finaloffer.EdgeValidationCase:
		if id := m.validation_case; id != nil {
			return []ent.Value{*id}
		}
	case finaloffer.EdgeValidatorUser:
		if id := m.validator_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FinalOfferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FinalOfferMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FinalOfferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvalidation_case {
		edges = append(edges, finaloffer.EdgeValidationCase)
	}
	if m.clearedvalidator_user {
		edges = append(edges, finaloffer.EdgeValidatorUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FinalOfferMutation) EdgeCleared(name string) bool {
	switch name {
	case finaloffer.EdgeValidationCase:
		return m.clearedvalidation_case
	case finaloffer.EdgeValidatorUser:
		return m.clearedvalidator_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FinalOfferMutation) ClearEdge(name string) error {
	switch name {
	case finaloffer.EdgeValidationCase:
		m.ClearValidationCase()
		return nil
	case finaloffer.EdgeValidatorUser:
		m.ClearValidatorUser()
		return nil
	}
	return fmt.Errorf("unknown FinalOffer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FinalOfferMutation) ResetEdge(name string) error {
	switch name {
	case finaloffer.EdgeValidationCase:
		m.ResetValidationCase()
		return nil
	case finaloffer.EdgeValidatorUser:
		m.ResetValidatorUser()
		return nil
	}
	return fmt.Errorf("unknown FinalOffer edge %s", name)
}

// IPGeoCacheMutation represents an operation that mutates the IPGeoCache nodes in the graph.
type IPGeoCacheMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	ip_address    *string
	country_code  *string
	country_name  *string
	city          *string
	latitude      *float64
	addlatitude   *float64
	longitude     *float64
	addlongitude  *float64
	cached_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*IPGeoCache, error)
	predicates    []predicate.IPGeoCache
}

var _ ent.Mutation = (*IPGeoCacheMutation)(nil)

// ipgeocacheOption allows management of the mutation configuration using functional options.
type ipgeocacheOption func(*IPGeoCacheMutation)

// newIPGeoCacheMutation creates new mutation for the IPGeoCache entity.
func newIPGeoCacheMutation(c config, op Op, opts ...ipgeocacheOption) *IPGeoCacheMutation {
	m := &IPGeoCacheMutation{
		config:        c,
		op:            op,
		typ:           TypeIPGeoCache,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIPGeoCacheID sets the ID field of the mutation.
func withIPGeoCacheID(id int) ipgeocacheOption {
	return func(m *IPGeoCacheMutation) {
		var (
			err   error
			once  sync.Once
			value *IPGeoCache
		)
		m.oldValue = func(ctx context.Context) (*IPGeoCache, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IPGeoCache.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIPGeoCache sets the old IPGeoCache of the mutation.
func withIPGeoCache(node *IPGeoCache) ipgeocacheOption {
	return func(m *IPGeoCacheMutation) {
		m.oldValue = func(context.Context) (*IPGeoCache, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IPGeoCacheMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IPGeoCacheMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IPGeoCacheMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IPGeoCacheMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IPGeoCache.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IPGeoCacheMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IPGeoCacheMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IPGeoCache entity.
// If the IPGeoCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPGeoCacheMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IPGeoCacheMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IPGeoCacheMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IPGeoCacheMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IPGeoCache entity.
// If the IPGeoCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPGeoCacheMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IPGeoCacheMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IPGeoCacheMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IPGeoCacheMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the IPGeoCache entity.
// If the IPGeoCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPGeoCacheMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *IPGeoCacheMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[ipgeocache.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *IPGeoCacheMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[ipgeocache.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IPGeoCacheMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, ipgeocache.FieldDeletedAt)
}

// SetIPAddress sets the "ip_address" field.
func (m *IPGeoCacheMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *IPGeoCacheMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the IPGeoCache entity.
// If the IPGeoCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPGeoCacheMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *IPGeoCacheMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetCountryCode sets the "country_code" field.
func (m *IPGeoCacheMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *IPGeoCacheMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the IPGeoCache entity.
// If the IPGeoCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPGeoCacheMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ClearCountryCode clears the value of the "country_code" field.
func (m *IPGeoCacheMutation) ClearCountryCode() {
	m.country_code = nil
	m.clearedFields[ipgeocache.FieldCountryCode] = struct{}{}
}

// CountryCodeCleared returns if the "country_code" field was cleared in this mutation.
func (m *IPGeoCacheMutation) CountryCodeCleared() bool {
	_, ok := m.clearedFields[ipgeocache.FieldCountryCode]
	return ok
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *IPGeoCacheMutation) ResetCountryCode() {
	m.country_code = nil
	delete(m.clearedFields, ipgeocache.FieldCountryCode)
}

// SetCountryName sets the "country_name" field.
func (m *IPGeoCacheMutation) SetCountryName(s string) {
	m.country_name = &s
}

// CountryName returns the value of the "country_name" field in the mutation.
func (m *IPGeoCacheMutation) CountryName() (r string, exists bool) {
	v := m.country_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryName returns the old "country_name" field's value of the IPGeoCache entity.
// If the IPGeoCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPGeoCacheMutation) OldCountryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryName: %w", err)
	}
	return oldValue.CountryName, nil
}

// ClearCountryName clears the value of the "country_name" field.
func (m *IPGeoCacheMutation) ClearCountryName() {
	m.country_name = nil
	m.clearedFields[ipgeocache.FieldCountryName] = struct{}{}
}

// CountryNameCleared returns if the "country_name" field was cleared in this mutation.
func (m *IPGeoCacheMutation) CountryNameCleared() bool {
	_, ok := m.clearedFields[ipgeocache.FieldCountryName]
	return ok
}

// ResetCountryName resets all changes to the "country_name" field.
func (m *IPGeoCacheMutation) ResetCountryName() {
	m.country_name = nil
	delete(m.clearedFields, ipgeocache.FieldCountryName)
}

// SetCity sets the "city" field.
func (m *IPGeoCacheMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *IPGeoCacheMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the IPGeoCache entity.
// If the IPGeoCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPGeoCacheMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *IPGeoCacheMutation) ClearCity() {
	m.city = nil
	m.clearedFields[ipgeocache.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *IPGeoCacheMutation) CityCleared() bool {
	_, ok := m.clearedFields[ipgeocache.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *IPGeoCacheMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, ipgeocache.FieldCity)
}

// SetLatitude sets the "latitude" field.
func (m *IPGeoCacheMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *IPGeoCacheMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the IPGeoCache entity.
// If the IPGeoCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPGeoCacheMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *IPGeoCacheMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *IPGeoCacheMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *IPGeoCacheMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[ipgeocache.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *IPGeoCacheMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[ipgeocache.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *IPGeoCacheMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, ipgeocache.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *IPGeoCacheMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *IPGeoCacheMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the IPGeoCache entity.
// If the IPGeoCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPGeoCacheMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *IPGeoCacheMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *IPGeoCacheMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *IPGeoCacheMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[ipgeocache.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *IPGeoCacheMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[ipgeocache.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *IPGeoCacheMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, ipgeocache.FieldLongitude)
}

// SetCachedAt sets the "cached_at" field.
func (m *IPGeoCacheMutation) SetCachedAt(t time.Time) {
	m.cached_at = &t
}

// CachedAt returns the value of the "cached_at" field in the mutation.
func (m *IPGeoCacheMutation) CachedAt() (r time.Time, exists bool) {
	v := m.cached_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCachedAt returns the old "cached_at" field's value of the IPGeoCache entity.
// If the IPGeoCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPGeoCacheMutation) OldCachedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCachedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCachedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCachedAt: %w", err)
	}
	return oldValue.CachedAt, nil
}

// ResetCachedAt resets all changes to the "cached_at" field.
func (m *IPGeoCacheMutation) ResetCachedAt() {
	m.cached_at = nil
}

// Where appends a list predicates to the IPGeoCacheMutation builder.
func (m *IPGeoCacheMutation) Where(ps ...predicate.IPGeoCache) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IPGeoCacheMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IPGeoCacheMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IPGeoCache, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IPGeoCacheMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IPGeoCacheMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IPGeoCache).
func (m *IPGeoCacheMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IPGeoCacheMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, ipgeocache.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ipgeocache.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, ipgeocache.FieldDeletedAt)
	}
	if m.ip_address != nil {
		fields = append(fields, ipgeocache.FieldIPAddress)
	}
	if m.country_code != nil {
		fields = append(fields, ipgeocache.FieldCountryCode)
	}
	if m.country_name != nil {
		fields = append(fields, ipgeocache.FieldCountryName)
	}
	if m.city != nil {
		fields = append(fields, ipgeocache.FieldCity)
	}
	if m.latitude != nil {
		fields = append(fields, ipgeocache.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, ipgeocache.FieldLongitude)
	}
	if m.cached_at != nil {
		fields = append(fields, ipgeocache.FieldCachedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IPGeoCacheMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ipgeocache.FieldCreatedAt:
		return m.CreatedAt()
	case ipgeocache.FieldUpdatedAt:
		return m.UpdatedAt()
	case ipgeocache.FieldDeletedAt:
		return m.DeletedAt()
	case ipgeocache.FieldIPAddress:
		return m.IPAddress()
	case ipgeocache.FieldCountryCode:
		return m.CountryCode()
	case ipgeocache.FieldCountryName:
		return m.CountryName()
	case ipgeocache.FieldCity:
		return m.City()
	case ipgeocache.FieldLatitude:
		return m.Latitude()
	case ipgeocache.FieldLongitude:
		return m.Longitude()
	case ipgeocache.FieldCachedAt:
		return m.CachedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IPGeoCacheMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ipgeocache.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ipgeocache.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ipgeocache.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ipgeocache.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case ipgeocache.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case ipgeocache.FieldCountryName:
		return m.OldCountryName(ctx)
	case ipgeocache.FieldCity:
		return m.OldCity(ctx)
	case ipgeocache.FieldLatitude:
		return m.OldLatitude(ctx)
	case ipgeocache.FieldLongitude:
		return m.OldLongitude(ctx)
	case ipgeocache.FieldCachedAt:
		return m.OldCachedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IPGeoCache field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPGeoCacheMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ipgeocache.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ipgeocache.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ipgeocache.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ipgeocache.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case ipgeocache.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case ipgeocache.FieldCountryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryName(v)
		return nil
	case ipgeocache.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case ipgeocache.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case ipgeocache.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case ipgeocache.FieldCachedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCachedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IPGeoCache field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IPGeoCacheMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, ipgeocache.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, ipgeocache.FieldLongitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IPGeoCacheMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ipgeocache.FieldLatitude:
		return m.AddedLatitude()
	case ipgeocache.FieldLongitude:
		return m.AddedLongitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPGeoCacheMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ipgeocache.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case ipgeocache.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown IPGeoCache numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IPGeoCacheMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ipgeocache.FieldDeletedAt) {
		fields = append(fields, ipgeocache.FieldDeletedAt)
	}
	if m.FieldCleared(ipgeocache.FieldCountryCode) {
		fields = append(fields, ipgeocache.FieldCountryCode)
	}
	if m.FieldCleared(ipgeocache.FieldCountryName) {
		fields = append(fields, ipgeocache.FieldCountryName)
	}
	if m.FieldCleared(ipgeocache.FieldCity) {
		fields = append(fields, ipgeocache.FieldCity)
	}
	if m.FieldCleared(ipgeocache.FieldLatitude) {
		fields = append(fields, ipgeocache.FieldLatitude)
	}
	if m.FieldCleared(ipgeocache.FieldLongitude) {
		fields = append(fields, ipgeocache.FieldLongitude)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IPGeoCacheMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IPGeoCacheMutation) ClearField(name string) error {
	switch name {
	case ipgeocache.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case ipgeocache.FieldCountryCode:
		m.ClearCountryCode()
		return nil
	case ipgeocache.FieldCountryName:
		m.ClearCountryName()
		return nil
	case ipgeocache.FieldCity:
		m.ClearCity()
		return nil
	case ipgeocache.FieldLatitude:
		m.ClearLatitude()
		return nil
	case ipgeocache.FieldLongitude:
		m.ClearLongitude()
		return nil
	}
	return fmt.Errorf("unknown IPGeoCache nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IPGeoCacheMutation) ResetField(name string) error {
	switch name {
	case ipgeocache.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ipgeocache.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ipgeocache.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ipgeocache.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case ipgeocache.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case ipgeocache.FieldCountryName:
		m.ResetCountryName()
		return nil
	case ipgeocache.FieldCity:
		m.ResetCity()
		return nil
	case ipgeocache.FieldLatitude:
		m.ResetLatitude()
		return nil
	case ipgeocache.FieldLongitude:
		m.ResetLongitude()
		return nil
	case ipgeocache.FieldCachedAt:
		m.ResetCachedAt()
		return nil
	}
	return fmt.Errorf("unknown IPGeoCache field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IPGeoCacheMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IPGeoCacheMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IPGeoCacheMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IPGeoCacheMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IPGeoCacheMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IPGeoCacheMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IPGeoCacheMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IPGeoCache unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IPGeoCacheMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IPGeoCache edge %s", name)
}

// PasskeyMutation represents an operation that mutates the Passkey nodes in the graph.
type PasskeyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	credential_id    *[]byte
	public_key       *[]byte
	attestation_type *string
	aaguid           *[]byte
	sign_count       *uint32
	addsign_count    *int32
	backup_eligible  *bool
	backup_state     *bool
	name             *string
	last_used_at     *time.Time
	transports       *[]string
	appendtransports []string
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Passkey, error)
	predicates       []predicate.Passkey
}

var _ ent.Mutation = (*PasskeyMutation)(nil)

// passkeyOption allows management of the mutation configuration using functional options.
type passkeyOption func(*PasskeyMutation)

// newPasskeyMutation creates new mutation for the Passkey entity.
func newPasskeyMutation(c config, op Op, opts ...passkeyOption) *PasskeyMutation {
	m := &PasskeyMutation{
		config:        c,
		op:            op,
		typ:           TypePasskey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasskeyID sets the ID field of the mutation.
func withPasskeyID(id int) passkeyOption {
	return func(m *PasskeyMutation) {
		var (
			err   error
			once  sync.Once
			value *Passkey
		)
		m.oldValue = func(ctx context.Context) (*Passkey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Passkey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasskey sets the old Passkey of the mutation.
func withPasskey(node *Passkey) passkeyOption {
	return func(m *PasskeyMutation) {
		m.oldValue = func(context.Context) (*Passkey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasskeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasskeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasskeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasskeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Passkey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PasskeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasskeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasskeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PasskeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PasskeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PasskeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PasskeyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PasskeyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PasskeyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[passkey.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PasskeyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[passkey.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PasskeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, passkey.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *PasskeyMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasskeyMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasskeyMutation) ResetUserID() {
	m.user = nil
}

// SetCredentialID sets the "credential_id" field.
func (m *PasskeyMutation) SetCredentialID(b []byte) {
	m.credential_id = &b
}

// CredentialID returns the value of the "credential_id" field in the mutation.
func (m *PasskeyMutation) CredentialID() (r []byte, exists bool) {
	v := m.credential_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialID returns the old "credential_id" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldCredentialID(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialID: %w", err)
	}
	return oldValue.CredentialID, nil
}

// ResetCredentialID resets all changes to the "credential_id" field.
func (m *PasskeyMutation) ResetCredentialID() {
	m.credential_id = nil
}

// SetPublicKey sets the "public_key" field.
func (m *PasskeyMutation) SetPublicKey(b []byte) {
	m.public_key = &b
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *PasskeyMutation) PublicKey() (r []byte, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *PasskeyMutation) ResetPublicKey() {
	m.public_key = nil
}

// SetAttestationType sets the "attestation_type" field.
func (m *PasskeyMutation) SetAttestationType(s string) {
	m.attestation_type = &s
}

// AttestationType returns the value of the "attestation_type" field in the mutation.
func (m *PasskeyMutation) AttestationType() (r string, exists bool) {
	v := m.attestation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestationType returns the old "attestation_type" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldAttestationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestationType: %w", err)
	}
	return oldValue.AttestationType, nil
}

// ResetAttestationType resets all changes to the "attestation_type" field.
func (m *PasskeyMutation) ResetAttestationType() {
	m.attestation_type = nil
}

// SetAaguid sets the "aaguid" field.
func (m *PasskeyMutation) SetAaguid(b []byte) {
	m.aaguid = &b
}

// Aaguid returns the value of the "aaguid" field in the mutation.
func (m *PasskeyMutation) Aaguid() (r []byte, exists bool) {
	v := m.aaguid
	if v == nil {
		return
	}
	return *v, true
}

// OldAaguid returns the old "aaguid" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldAaguid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAaguid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAaguid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAaguid: %w", err)
	}
	return oldValue.Aaguid, nil
}

// ClearAaguid clears the value of the "aaguid" field.
func (m *PasskeyMutation) ClearAaguid() {
	m.aaguid = nil
	m.clearedFields[passkey.FieldAaguid] = struct{}{}
}

// AaguidCleared returns if the "aaguid" field was cleared in this mutation.
func (m *PasskeyMutation) AaguidCleared() bool {
	_, ok := m.clearedFields[passkey.FieldAaguid]
	return ok
}

// ResetAaguid resets all changes to the "aaguid" field.
func (m *PasskeyMutation) ResetAaguid() {
	m.aaguid = nil
	delete(m.clearedFields, passkey.FieldAaguid)
}

// SetSignCount sets the "sign_count" field.
func (m *PasskeyMutation) SetSignCount(u uint32) {
	m.sign_count = &u
	m.addsign_count = nil
}

// SignCount returns the value of the "sign_count" field in the mutation.
func (m *PasskeyMutation) SignCount() (r uint32, exists bool) {
	v := m.sign_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSignCount returns the old "sign_count" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldSignCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignCount: %w", err)
	}
	return oldValue.SignCount, nil
}

// AddSignCount adds u to the "sign_count" field.
func (m *PasskeyMutation) AddSignCount(u int32) {
	if m.addsign_count != nil {
		*m.addsign_count += u
	} else {
		m.addsign_count = &u
	}
}

// AddedSignCount returns the value that was added to the "sign_count" field in this mutation.
func (m *PasskeyMutation) AddedSignCount() (r int32, exists bool) {
	v := m.addsign_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSignCount resets all changes to the "sign_count" field.
func (m *PasskeyMutation) ResetSignCount() {
	m.sign_count = nil
	m.addsign_count = nil
}

// SetBackupEligible sets the "backup_eligible" field.
func (m *PasskeyMutation) SetBackupEligible(b bool) {
	m.backup_eligible = &b
}

// BackupEligible returns the value of the "backup_eligible" field in the mutation.
func (m *PasskeyMutation) BackupEligible() (r bool, exists bool) {
	v := m.backup_eligible
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupEligible returns the old "backup_eligible" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldBackupEligible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupEligible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupEligible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupEligible: %w", err)
	}
	return oldValue.BackupEligible, nil
}

// ResetBackupEligible resets all changes to the "backup_eligible" field.
func (m *PasskeyMutation) ResetBackupEligible() {
	m.backup_eligible = nil
}

// SetBackupState sets the "backup_state" field.
func (m *PasskeyMutation) SetBackupState(b bool) {
	m.backup_state = &b
}

// BackupState returns the value of the "backup_state" field in the mutation.
func (m *PasskeyMutation) BackupState() (r bool, exists bool) {
	v := m.backup_state
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupState returns the old "backup_state" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldBackupState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupState: %w", err)
	}
	return oldValue.BackupState, nil
}

// ResetBackupState resets all changes to the "backup_state" field.
func (m *PasskeyMutation) ResetBackupState() {
	m.backup_state = nil
}

// SetName sets the "name" field.
func (m *PasskeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PasskeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PasskeyMutation) ResetName() {
	m.name = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *PasskeyMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *PasskeyMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *PasskeyMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[passkey.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *PasskeyMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[passkey.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *PasskeyMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, passkey.FieldLastUsedAt)
}

// SetTransports sets the "transports" field.
func (m *PasskeyMutation) SetTransports(s []string) {
	m.transports = &s
	m.appendtransports = nil
}

// Transports returns the value of the "transports" field in the mutation.
func (m *PasskeyMutation) Transports() (r []string, exists bool) {
	v := m.transports
	if v == nil {
		return
	}
	return *v, true
}

// OldTransports returns the old "transports" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldTransports(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransports is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransports requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransports: %w", err)
	}
	return oldValue.Transports, nil
}

// AppendTransports adds s to the "transports" field.
func (m *PasskeyMutation) AppendTransports(s []string) {
	m.appendtransports = append(m.appendtransports, s...)
}

// AppendedTransports returns the list of values that were appended to the "transports" field in this mutation.
func (m *PasskeyMutation) AppendedTransports() ([]string, bool) {
	if len(m.appendtransports) == 0 {
		return nil, false
	}
	return m.appendtransports, true
}

// ClearTransports clears the value of the "transports" field.
func (m *PasskeyMutation) ClearTransports() {
	m.transports = nil
	m.appendtransports = nil
	m.clearedFields[passkey.FieldTransports] = struct{}{}
}

// TransportsCleared returns if the "transports" field was cleared in this mutation.
func (m *PasskeyMutation) TransportsCleared() bool {
	_, ok := m.clearedFields[passkey.FieldTransports]
	return ok
}

// ResetTransports resets all changes to the "transports" field.
func (m *PasskeyMutation) ResetTransports() {
	m.transports = nil
	m.appendtransports = nil
	delete(m.clearedFields, passkey.FieldTransports)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasskeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[passkey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasskeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasskeyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasskeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasskeyMutation builder.
func (m *PasskeyMutation) Where(ps ...predicate.Passkey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasskeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasskeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Passkey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasskeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasskeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Passkey).
func (m *PasskeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasskeyMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, passkey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, passkey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, passkey.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, passkey.FieldUserID)
	}
	if m.credential_id != nil {
		fields = append(fields, passkey.FieldCredentialID)
	}
	if m.public_key != nil {
		fields = append(fields, passkey.FieldPublicKey)
	}
	if m.attestation_type != nil {
		fields = append(fields, passkey.FieldAttestationType)
	}
	if m.aaguid != nil {
		fields = append(fields, passkey.FieldAaguid)
	}
	if m.sign_count != nil {
		fields = append(fields, passkey.FieldSignCount)
	}
	if m.backup_eligible != nil {
		fields = append(fields, passkey.FieldBackupEligible)
	}
	if m.backup_state != nil {
		fields = append(fields, passkey.FieldBackupState)
	}
	if m.name != nil {
		fields = append(fields, passkey.FieldName)
	}
	if m.last_used_at != nil {
		fields = append(fields, passkey.FieldLastUsedAt)
	}
	if m.transports != nil {
		fields = append(fields, passkey.FieldTransports)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasskeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passkey.FieldCreatedAt:
		return m.CreatedAt()
	case passkey.FieldUpdatedAt:
		return m.UpdatedAt()
	case passkey.FieldDeletedAt:
		return m.DeletedAt()
	case passkey.FieldUserID:
		return m.UserID()
	case passkey.FieldCredentialID:
		return m.CredentialID()
	case passkey.FieldPublicKey:
		return m.PublicKey()
	case passkey.FieldAttestationType:
		return m.AttestationType()
	case passkey.FieldAaguid:
		return m.Aaguid()
	case passkey.FieldSignCount:
		return m.SignCount()
	case passkey.FieldBackupEligible:
		return m.BackupEligible()
	case passkey.FieldBackupState:
		return m.BackupState()
	case passkey.FieldName:
		return m.Name()
	case passkey.FieldLastUsedAt:
		return m.LastUsedAt()
	case passkey.FieldTransports:
		return m.Transports()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasskeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passkey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case passkey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case passkey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case passkey.FieldUserID:
		return m.OldUserID(ctx)
	case passkey.FieldCredentialID:
		return m.OldCredentialID(ctx)
	case passkey.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case passkey.FieldAttestationType:
		return m.OldAttestationType(ctx)
	case passkey.FieldAaguid:
		return m.OldAaguid(ctx)
	case passkey.FieldSignCount:
		return m.OldSignCount(ctx)
	case passkey.FieldBackupEligible:
		return m.OldBackupEligible(ctx)
	case passkey.FieldBackupState:
		return m.OldBackupState(ctx)
	case passkey.FieldName:
		return m.OldName(ctx)
	case passkey.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case passkey.FieldTransports:
		return m.OldTransports(ctx)
	}
	return nil, fmt.Errorf("unknown Passkey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasskeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passkey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case passkey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case passkey.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case passkey.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case passkey.FieldCredentialID:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialID(v)
		return nil
	case passkey.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case passkey.FieldAttestationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestationType(v)
		return nil
	case passkey.FieldAaguid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAaguid(v)
		return nil
	case passkey.FieldSignCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignCount(v)
		return nil
	case passkey.FieldBackupEligible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupEligible(v)
		return nil
	case passkey.FieldBackupState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupState(v)
		return nil
	case passkey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case passkey.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case passkey.FieldTransports:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransports(v)
		return nil
	}
	return fmt.Errorf("unknown Passkey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasskeyMutation) AddedFields() []string {
	var fields []string
	if m.addsign_count != nil {
		fields = append(fields, passkey.FieldSignCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasskeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case passkey.FieldSignCount:
		return m.AddedSignCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasskeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case passkey.FieldSignCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignCount(v)
		return nil
	}
	return fmt.Errorf("unknown Passkey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasskeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passkey.FieldDeletedAt) {
		fields = append(fields, passkey.FieldDeletedAt)
	}
	if m.FieldCleared(passkey.FieldAaguid) {
		fields = append(fields, passkey.FieldAaguid)
	}
	if m.FieldCleared(passkey.FieldLastUsedAt) {
		fields = append(fields, passkey.FieldLastUsedAt)
	}
	if m.FieldCleared(passkey.FieldTransports) {
		fields = append(fields, passkey.FieldTransports)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasskeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasskeyMutation) ClearField(name string) error {
	switch name {
	case passkey.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case passkey.FieldAaguid:
		m.ClearAaguid()
		return nil
	case passkey.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case passkey.FieldTransports:
		m.ClearTransports()
		return nil
	}
	return fmt.Errorf("unknown Passkey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasskeyMutation) ResetField(name string) error {
	switch name {
	case passkey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case passkey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case passkey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case passkey.FieldUserID:
		m.ResetUserID()
		return nil
	case passkey.FieldCredentialID:
		m.ResetCredentialID()
		return nil
	case passkey.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case passkey.FieldAttestationType:
		m.ResetAttestationType()
		return nil
	case passkey.FieldAaguid:
		m.ResetAaguid()
		return nil
	case passkey.FieldSignCount:
		m.ResetSignCount()
		return nil
	case passkey.FieldBackupEligible:
		m.ResetBackupEligible()
		return nil
	case passkey.FieldBackupState:
		m.ResetBackupState()
		return nil
	case passkey.FieldName:
		m.ResetName()
		return nil
	case passkey.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case passkey.FieldTransports:
		m.ResetTransports()
		return nil
	}
	return fmt.Errorf("unknown Passkey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasskeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passkey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasskeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passkey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasskeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasskeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasskeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passkey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasskeyMutation) EdgeCleared(name string) bool {
	switch name {
	case passkey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasskeyMutation) ClearEdge(name string) error {
	switch name {
	case passkey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Passkey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasskeyMutation) ResetEdge(name string) error {
	switch name {
	case passkey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Passkey edge %s", name)
}

// PasswordResetTokenMutation represents an operation that mutates the PasswordResetToken nodes in the graph.
type PasswordResetTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token_hash    *string
	expires_at    *time.Time
	used_at       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*PasswordResetToken, error)
	predicates    []predicate.PasswordResetToken
}

var _ ent.Mutation = (*PasswordResetTokenMutation)(nil)

// passwordresettokenOption allows management of the mutation configuration using functional options.
type passwordresettokenOption func(*PasswordResetTokenMutation)

// newPasswordResetTokenMutation creates new mutation for the PasswordResetToken entity.
func newPasswordResetTokenMutation(c config, op Op, opts ...passwordresettokenOption) *PasswordResetTokenMutation {
	m := &PasswordResetTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePasswordResetToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordResetTokenID sets the ID field of the mutation.
func withPasswordResetTokenID(id int) passwordresettokenOption {
	return func(m *PasswordResetTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PasswordResetToken
		)
		m.oldValue = func(ctx context.Context) (*PasswordResetToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PasswordResetToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasswordResetToken sets the old PasswordResetToken of the mutation.
func withPasswordResetToken(node *PasswordResetToken) passwordresettokenOption {
	return func(m *PasswordResetTokenMutation) {
		m.oldValue = func(context.Context) (*PasswordResetToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordResetTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordResetTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordResetTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordResetTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PasswordResetToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PasswordResetTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasswordResetTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasswordResetTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PasswordResetTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PasswordResetTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PasswordResetTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PasswordResetTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PasswordResetTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PasswordResetTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[passwordresettoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PasswordResetTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[passwordresettoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PasswordResetTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, passwordresettoken.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *PasswordResetTokenMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasswordResetTokenMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasswordResetTokenMutation) ResetUserID() {
	m.user = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *PasswordResetTokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *PasswordResetTokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *PasswordResetTokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *PasswordResetTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PasswordResetTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PasswordResetTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsedAt sets the "used_at" field.
func (m *PasswordResetTokenMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *PasswordResetTokenMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *PasswordResetTokenMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[passwordresettoken.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *PasswordResetTokenMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[passwordresettoken.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *PasswordResetTokenMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, passwordresettoken.FieldUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasswordResetTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[passwordresettoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasswordResetTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasswordResetTokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasswordResetTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasswordResetTokenMutation builder.
func (m *PasswordResetTokenMutation) Where(ps ...predicate.PasswordResetToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordResetTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordResetTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PasswordResetToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordResetTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordResetTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PasswordResetToken).
func (m *PasswordResetTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordResetTokenMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, passwordresettoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, passwordresettoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, passwordresettoken.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, passwordresettoken.FieldUserID)
	}
	if m.token_hash != nil {
		fields = append(fields, passwordresettoken.FieldTokenHash)
	}
	if m.expires_at != nil {
		fields = append(fields, passwordresettoken.FieldExpiresAt)
	}
	if m.used_at != nil {
		fields = append(fields, passwordresettoken.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordResetTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		return m.CreatedAt()
	case passwordresettoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case passwordresettoken.FieldDeletedAt:
		return m.DeletedAt()
	case passwordresettoken.FieldUserID:
		return m.UserID()
	case passwordresettoken.FieldTokenHash:
		return m.TokenHash()
	case passwordresettoken.FieldExpiresAt:
		return m.ExpiresAt()
	case passwordresettoken.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordResetTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case passwordresettoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case passwordresettoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case passwordresettoken.FieldUserID:
		return m.OldUserID(ctx)
	case passwordresettoken.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case passwordresettoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case passwordresettoken.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case passwordresettoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case passwordresettoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case passwordresettoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case passwordresettoken.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case passwordresettoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case passwordresettoken.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordResetTokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordResetTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PasswordResetToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordResetTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passwordresettoken.FieldDeletedAt) {
		fields = append(fields, passwordresettoken.FieldDeletedAt)
	}
	if m.FieldCleared(passwordresettoken.FieldUsedAt) {
		fields = append(fields, passwordresettoken.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordResetTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordResetTokenMutation) ClearField(name string) error {
	switch name {
	case passwordresettoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case passwordresettoken.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordResetTokenMutation) ResetField(name string) error {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case passwordresettoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case passwordresettoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case passwordresettoken.FieldUserID:
		m.ResetUserID()
		return nil
	case passwordresettoken.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case passwordresettoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case passwordresettoken.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordResetTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passwordresettoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordResetTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passwordresettoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordResetTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordResetTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordResetTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passwordresettoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordResetTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case passwordresettoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordResetTokenMutation) ClearEdge(name string) error {
	switch name {
	case passwordresettoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordResetTokenMutation) ResetEdge(name string) error {
	switch name {
	case passwordresettoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken edge %s", name)
}

// SecurityEventMutation represents an operation that mutates the SecurityEvent nodes in the graph.
type SecurityEventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	email         *string
	event_type    *string
	ip_address    *string
	user_agent    *string
	success       *bool
	details       *string
	severity      *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*SecurityEvent, error)
	predicates    []predicate.SecurityEvent
}

var _ ent.Mutation = (*SecurityEventMutation)(nil)

// securityeventOption allows management of the mutation configuration using functional options.
type securityeventOption func(*SecurityEventMutation)

// newSecurityEventMutation creates new mutation for the SecurityEvent entity.
func newSecurityEventMutation(c config, op Op, opts ...securityeventOption) *SecurityEventMutation {
	m := &SecurityEventMutation{
		config:        c,
		op:            op,
		typ:           TypeSecurityEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecurityEventID sets the ID field of the mutation.
func withSecurityEventID(id int) securityeventOption {
	return func(m *SecurityEventMutation) {
		var (
			err   error
			once  sync.Once
			value *SecurityEvent
		)
		m.oldValue = func(ctx context.Context) (*SecurityEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SecurityEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecurityEvent sets the old SecurityEvent of the mutation.
func withSecurityEvent(node *SecurityEvent) securityeventOption {
	return func(m *SecurityEventMutation) {
		m.oldValue = func(context.Context) (*SecurityEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecurityEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecurityEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SecurityEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SecurityEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SecurityEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SecurityEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SecurityEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SecurityEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SecurityEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SecurityEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SecurityEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SecurityEventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SecurityEventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SecurityEventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[securityevent.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SecurityEventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SecurityEventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, securityevent.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *SecurityEventMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SecurityEventMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldUserID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *SecurityEventMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[securityevent.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SecurityEventMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SecurityEventMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, securityevent.FieldUserID)
}

// SetEmail sets the "email" field.
func (m *SecurityEventMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SecurityEventMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *SecurityEventMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[securityevent.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *SecurityEventMutation) EmailCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *SecurityEventMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, securityevent.FieldEmail)
}

// SetEventType sets the "event_type" field.
func (m *SecurityEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *SecurityEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *SecurityEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *SecurityEventMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SecurityEventMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SecurityEventMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[securityevent.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SecurityEventMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SecurityEventMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, securityevent.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *SecurityEventMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SecurityEventMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SecurityEventMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[securityevent.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SecurityEventMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SecurityEventMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, securityevent.FieldUserAgent)
}

// SetSuccess sets the "success" field.
func (m *SecurityEventMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *SecurityEventMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *SecurityEventMutation) ResetSuccess() {
	m.success = nil
}

// SetDetails sets the "details" field.
func (m *SecurityEventMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *SecurityEventMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *SecurityEventMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[securityevent.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *SecurityEventMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *SecurityEventMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, securityevent.FieldDetails)
}

// SetSeverity sets the "severity" field.
func (m *SecurityEventMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *SecurityEventMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ClearSeverity clears the value of the "severity" field.
func (m *SecurityEventMutation) ClearSeverity() {
	m.severity = nil
	m.clearedFields[securityevent.FieldSeverity] = struct{}{}
}

// SeverityCleared returns if the "severity" field was cleared in this mutation.
func (m *SecurityEventMutation) SeverityCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldSeverity]
	return ok
}

// ResetSeverity resets all changes to the "severity" field.
func (m *SecurityEventMutation) ResetSeverity() {
	m.severity = nil
	delete(m.clearedFields, securityevent.FieldSeverity)
}

// ClearUser clears the "user" edge to the User entity.
func (m *SecurityEventMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[securityevent.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SecurityEventMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SecurityEventMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SecurityEventMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SecurityEventMutation builder.
func (m *SecurityEventMutation) Where(ps ...predicate.SecurityEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SecurityEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SecurityEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SecurityEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SecurityEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SecurityEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SecurityEvent).
func (m *SecurityEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecurityEventMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, securityevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, securityevent.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, securityevent.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, securityevent.FieldUserID)
	}
	if m.email != nil {
		fields = append(fields, securityevent.FieldEmail)
	}
	if m.event_type != nil {
		fields = append(fields, securityevent.FieldEventType)
	}
	if m.ip_address != nil {
		fields = append(fields, securityevent.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, securityevent.FieldUserAgent)
	}
	if m.success != nil {
		fields = append(fields, securityevent.FieldSuccess)
	}
	if m.details != nil {
		fields = append(fields, securityevent.FieldDetails)
	}
	if m.severity != nil {
		fields = append(fields, securityevent.FieldSeverity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecurityEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case securityevent.FieldCreatedAt:
		return m.CreatedAt()
	case securityevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case securityevent.FieldDeletedAt:
		return m.DeletedAt()
	case securityevent.FieldUserID:
		return m.UserID()
	case securityevent.FieldEmail:
		return m.Email()
	case securityevent.FieldEventType:
		return m.EventType()
	case securityevent.FieldIPAddress:
		return m.IPAddress()
	case securityevent.FieldUserAgent:
		return m.UserAgent()
	case securityevent.FieldSuccess:
		return m.Success()
	case securityevent.FieldDetails:
		return m.Details()
	case securityevent.FieldSeverity:
		return m.Severity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecurityEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case securityevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case securityevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case securityevent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case securityevent.FieldUserID:
		return m.OldUserID(ctx)
	case securityevent.FieldEmail:
		return m.OldEmail(ctx)
	case securityevent.FieldEventType:
		return m.OldEventType(ctx)
	case securityevent.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case securityevent.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case securityevent.FieldSuccess:
		return m.OldSuccess(ctx)
	case securityevent.FieldDetails:
		return m.OldDetails(ctx)
	case securityevent.FieldSeverity:
		return m.OldSeverity(ctx)
	}
	return nil, fmt.Errorf("unknown SecurityEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case securityevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case securityevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case securityevent.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case securityevent.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case securityevent.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case securityevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case securityevent.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case securityevent.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case securityevent.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case securityevent.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case securityevent.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	}
	return fmt.Errorf("unknown SecurityEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecurityEventMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecurityEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SecurityEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecurityEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(securityevent.FieldDeletedAt) {
		fields = append(fields, securityevent.FieldDeletedAt)
	}
	if m.FieldCleared(securityevent.FieldUserID) {
		fields = append(fields, securityevent.FieldUserID)
	}
	if m.FieldCleared(securityevent.FieldEmail) {
		fields = append(fields, securityevent.FieldEmail)
	}
	if m.FieldCleared(securityevent.FieldIPAddress) {
		fields = append(fields, securityevent.FieldIPAddress)
	}
	if m.FieldCleared(securityevent.FieldUserAgent) {
		fields = append(fields, securityevent.FieldUserAgent)
	}
	if m.FieldCleared(securityevent.FieldDetails) {
		fields = append(fields, securityevent.FieldDetails)
	}
	if m.FieldCleared(securityevent.FieldSeverity) {
		fields = append(fields, securityevent.FieldSeverity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecurityEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecurityEventMutation) ClearField(name string) error {
	switch name {
	case securityevent.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case securityevent.FieldUserID:
		m.ClearUserID()
		return nil
	case securityevent.FieldEmail:
		m.ClearEmail()
		return nil
	case securityevent.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case securityevent.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case securityevent.FieldDetails:
		m.ClearDetails()
		return nil
	case securityevent.FieldSeverity:
		m.ClearSeverity()
		return nil
	}
	return fmt.Errorf("unknown SecurityEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecurityEventMutation) ResetField(name string) error {
	switch name {
	case securityevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case securityevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case securityevent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case securityevent.FieldUserID:
		m.ResetUserID()
		return nil
	case securityevent.FieldEmail:
		m.ResetEmail()
		return nil
	case securityevent.FieldEventType:
		m.ResetEventType()
		return nil
	case securityevent.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case securityevent.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case securityevent.FieldSuccess:
		m.ResetSuccess()
		return nil
	case securityevent.FieldDetails:
		m.ResetDetails()
		return nil
	case securityevent.FieldSeverity:
		m.ResetSeverity()
		return nil
	}
	return fmt.Errorf("unknown SecurityEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecurityEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, securityevent.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecurityEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case securityevent.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecurityEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecurityEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecurityEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, securityevent.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecurityEventMutation) EdgeCleared(name string) bool {
	switch name {
	case securityevent.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecurityEventMutation) ClearEdge(name string) error {
	switch name {
	case securityevent.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SecurityEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecurityEventMutation) ResetEdge(name string) error {
	switch name {
	case securityevent.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SecurityEvent edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	refresh_token_hash *string
	access_token_jti   *string
	ip_address         *string
	user_agent         *string
	expires_at         *time.Time
	last_used_at       *time.Time
	revoked_at         *time.Time
	revoke_reason      *string
	token_family       *string
	is_used            *bool
	clearedFields      map[string]struct{}
	user               *int
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*Session, error)
	predicates         []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id int) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SessionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SessionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SessionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[session.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SessionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SessionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, session.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
}

// SetRefreshTokenHash sets the "refresh_token_hash" field.
func (m *SessionMutation) SetRefreshTokenHash(s string) {
	m.refresh_token_hash = &s
}

// RefreshTokenHash returns the value of the "refresh_token_hash" field in the mutation.
func (m *SessionMutation) RefreshTokenHash() (r string, exists bool) {
	v := m.refresh_token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenHash returns the old "refresh_token_hash" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRefreshTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenHash: %w", err)
	}
	return oldValue.RefreshTokenHash, nil
}

// ResetRefreshTokenHash resets all changes to the "refresh_token_hash" field.
func (m *SessionMutation) ResetRefreshTokenHash() {
	m.refresh_token_hash = nil
}

// SetAccessTokenJti sets the "access_token_jti" field.
func (m *SessionMutation) SetAccessTokenJti(s string) {
	m.access_token_jti = &s
}

// AccessTokenJti returns the value of the "access_token_jti" field in the mutation.
func (m *SessionMutation) AccessTokenJti() (r string, exists bool) {
	v := m.access_token_jti
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessTokenJti returns the old "access_token_jti" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldAccessTokenJti(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessTokenJti is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessTokenJti requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessTokenJti: %w", err)
	}
	return oldValue.AccessTokenJti, nil
}

// ClearAccessTokenJti clears the value of the "access_token_jti" field.
func (m *SessionMutation) ClearAccessTokenJti() {
	m.access_token_jti = nil
	m.clearedFields[session.FieldAccessTokenJti] = struct{}{}
}

// AccessTokenJtiCleared returns if the "access_token_jti" field was cleared in this mutation.
func (m *SessionMutation) AccessTokenJtiCleared() bool {
	_, ok := m.clearedFields[session.FieldAccessTokenJti]
	return ok
}

// ResetAccessTokenJti resets all changes to the "access_token_jti" field.
func (m *SessionMutation) ResetAccessTokenJti() {
	m.access_token_jti = nil
	delete(m.clearedFields, session.FieldAccessTokenJti)
}

// SetIPAddress sets the "ip_address" field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[session.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[session.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, session.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[session.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[session.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, session.FieldUserAgent)
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *SessionMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *SessionMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLastUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *SessionMutation) ResetLastUsedAt() {
	m.last_used_at = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *SessionMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *SessionMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *SessionMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[session.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *SessionMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *SessionMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, session.FieldRevokedAt)
}

// SetRevokeReason sets the "revoke_reason" field.
func (m *SessionMutation) SetRevokeReason(s string) {
	m.revoke_reason = &s
}

// RevokeReason returns the value of the "revoke_reason" field in the mutation.
func (m *SessionMutation) RevokeReason() (r string, exists bool) {
	v := m.revoke_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokeReason returns the old "revoke_reason" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokeReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokeReason: %w", err)
	}
	return oldValue.RevokeReason, nil
}

// ClearRevokeReason clears the value of the "revoke_reason" field.
func (m *SessionMutation) ClearRevokeReason() {
	m.revoke_reason = nil
	m.clearedFields[session.FieldRevokeReason] = struct{}{}
}

// RevokeReasonCleared returns if the "revoke_reason" field was cleared in this mutation.
func (m *SessionMutation) RevokeReasonCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokeReason]
	return ok
}

// ResetRevokeReason resets all changes to the "revoke_reason" field.
func (m *SessionMutation) ResetRevokeReason() {
	m.revoke_reason = nil
	delete(m.clearedFields, session.FieldRevokeReason)
}

// SetTokenFamily sets the "token_family" field.
func (m *SessionMutation) SetTokenFamily(s string) {
	m.token_family = &s
}

// TokenFamily returns the value of the "token_family" field in the mutation.
func (m *SessionMutation) TokenFamily() (r string, exists bool) {
	v := m.token_family
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenFamily returns the old "token_family" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTokenFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenFamily: %w", err)
	}
	return oldValue.TokenFamily, nil
}

// ResetTokenFamily resets all changes to the "token_family" field.
func (m *SessionMutation) ResetTokenFamily() {
	m.token_family = nil
}

// SetIsUsed sets the "is_used" field.
func (m *SessionMutation) SetIsUsed(b bool) {
	m.is_used = &b
}

// IsUsed returns the value of the "is_used" field in the mutation.
func (m *SessionMutation) IsUsed() (r bool, exists bool) {
	v := m.is_used
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUsed returns the old "is_used" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIsUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUsed: %w", err)
	}
	return oldValue.IsUsed, nil
}

// ResetIsUsed resets all changes to the "is_used" field.
func (m *SessionMutation) ResetIsUsed() {
	m.is_used = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, session.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.refresh_token_hash != nil {
		fields = append(fields, session.FieldRefreshTokenHash)
	}
	if m.access_token_jti != nil {
		fields = append(fields, session.FieldAccessTokenJti)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, session.FieldLastUsedAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.revoke_reason != nil {
		fields = append(fields, session.FieldRevokeReason)
	}
	if m.token_family != nil {
		fields = append(fields, session.FieldTokenFamily)
	}
	if m.is_used != nil {
		fields = append(fields, session.FieldIsUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldDeletedAt:
		return m.DeletedAt()
	case session.FieldUserID:
		return m.UserID()
	case session.FieldRefreshTokenHash:
		return m.RefreshTokenHash()
	case session.FieldAccessTokenJti:
		return m.AccessTokenJti()
	case session.FieldIPAddress:
		return m.IPAddress()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldLastUsedAt:
		return m.LastUsedAt()
	case session.FieldRevokedAt:
		return m.RevokedAt()
	case session.FieldRevokeReason:
		return m.RevokeReason()
	case session.FieldTokenFamily:
		return m.TokenFamily()
	case session.FieldIsUsed:
		return m.IsUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldRefreshTokenHash:
		return m.OldRefreshTokenHash(ctx)
	case session.FieldAccessTokenJti:
		return m.OldAccessTokenJti(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case session.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case session.FieldRevokeReason:
		return m.OldRevokeReason(ctx)
	case session.FieldTokenFamily:
		return m.OldTokenFamily(ctx)
	case session.FieldIsUsed:
		return m.OldIsUsed(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case session.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldRefreshTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenHash(v)
		return nil
	case session.FieldAccessTokenJti:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessTokenJti(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case session.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case session.FieldRevokeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokeReason(v)
		return nil
	case session.FieldTokenFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenFamily(v)
		return nil
	case session.FieldIsUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUsed(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldDeletedAt) {
		fields = append(fields, session.FieldDeletedAt)
	}
	if m.FieldCleared(session.FieldAccessTokenJti) {
		fields = append(fields, session.FieldAccessTokenJti)
	}
	if m.FieldCleared(session.FieldIPAddress) {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.FieldCleared(session.FieldUserAgent) {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.FieldCleared(session.FieldRevokedAt) {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.FieldCleared(session.FieldRevokeReason) {
		fields = append(fields, session.FieldRevokeReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case session.FieldAccessTokenJti:
		m.ClearAccessTokenJti()
		return nil
	case session.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case session.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case session.FieldRevokeReason:
		m.ClearRevokeReason()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldRefreshTokenHash:
		m.ResetRefreshTokenHash()
		return nil
	case session.FieldAccessTokenJti:
		m.ResetAccessTokenJti()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case session.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case session.FieldRevokeReason:
		m.ResetRevokeReason()
		return nil
	case session.FieldTokenFamily:
		m.ResetTokenFamily()
		return nil
	case session.FieldIsUsed:
		m.ResetIsUsed()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// SessionLockMutation represents an operation that mutates the SessionLock nodes in the graph.
type SessionLockMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	locked_at     *time.Time
	unlocked_at   *time.Time
	expires_at    *time.Time
	reason        *string
	locked_by     *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*SessionLock, error)
	predicates    []predicate.SessionLock
}

var _ ent.Mutation = (*SessionLockMutation)(nil)

// sessionlockOption allows management of the mutation configuration using functional options.
type sessionlockOption func(*SessionLockMutation)

// newSessionLockMutation creates new mutation for the SessionLock entity.
func newSessionLockMutation(c config, op Op, opts ...sessionlockOption) *SessionLockMutation {
	m := &SessionLockMutation{
		config:        c,
		op:            op,
		typ:           TypeSessionLock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionLockID sets the ID field of the mutation.
func withSessionLockID(id int) sessionlockOption {
	return func(m *SessionLockMutation) {
		var (
			err   error
			once  sync.Once
			value *SessionLock
		)
		m.oldValue = func(ctx context.Context) (*SessionLock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SessionLock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSessionLock sets the old SessionLock of the mutation.
func withSessionLock(node *SessionLock) sessionlockOption {
	return func(m *SessionLockMutation) {
		m.oldValue = func(context.Context) (*SessionLock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionLockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionLockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionLockMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionLockMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SessionLock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionLockMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionLockMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionLockMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionLockMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionLockMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionLockMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SessionLockMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SessionLockMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SessionLockMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sessionlock.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SessionLockMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sessionlock.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SessionLockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sessionlock.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *SessionLockMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionLockMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionLockMutation) ResetUserID() {
	m.user = nil
}

// SetLockedAt sets the "locked_at" field.
func (m *SessionLockMutation) SetLockedAt(t time.Time) {
	m.locked_at = &t
}

// LockedAt returns the value of the "locked_at" field in the mutation.
func (m *SessionLockMutation) LockedAt() (r time.Time, exists bool) {
	v := m.locked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedAt returns the old "locked_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldLockedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedAt: %w", err)
	}
	return oldValue.LockedAt, nil
}

// ResetLockedAt resets all changes to the "locked_at" field.
func (m *SessionLockMutation) ResetLockedAt() {
	m.locked_at = nil
}

// SetUnlockedAt sets the "unlocked_at" field.
func (m *SessionLockMutation) SetUnlockedAt(t time.Time) {
	m.unlocked_at = &t
}

// UnlockedAt returns the value of the "unlocked_at" field in the mutation.
func (m *SessionLockMutation) UnlockedAt() (r time.Time, exists bool) {
	v := m.unlocked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUnlockedAt returns the old "unlocked_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldUnlockedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnlockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnlockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnlockedAt: %w", err)
	}
	return oldValue.UnlockedAt, nil
}

// ClearUnlockedAt clears the value of the "unlocked_at" field.
func (m *SessionLockMutation) ClearUnlockedAt() {
	m.unlocked_at = nil
	m.clearedFields[sessionlock.FieldUnlockedAt] = struct{}{}
}

// UnlockedAtCleared returns if the "unlocked_at" field was cleared in this mutation.
func (m *SessionLockMutation) UnlockedAtCleared() bool {
	_, ok := m.clearedFields[sessionlock.FieldUnlockedAt]
	return ok
}

// ResetUnlockedAt resets all changes to the "unlocked_at" field.
func (m *SessionLockMutation) ResetUnlockedAt() {
	m.unlocked_at = nil
	delete(m.clearedFields, sessionlock.FieldUnlockedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionLockMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionLockMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionLockMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetReason sets the "reason" field.
func (m *SessionLockMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *SessionLockMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *SessionLockMutation) ResetReason() {
	m.reason = nil
}

// SetLockedBy sets the "locked_by" field.
func (m *SessionLockMutation) SetLockedBy(s string) {
	m.locked_by = &s
}

// LockedBy returns the value of the "locked_by" field in the mutation.
func (m *SessionLockMutation) LockedBy() (r string, exists bool) {
	v := m.locked_by
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedBy returns the old "locked_by" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldLockedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedBy: %w", err)
	}
	return oldValue.LockedBy, nil
}

// ClearLockedBy clears the value of the "locked_by" field.
func (m *SessionLockMutation) ClearLockedBy() {
	m.locked_by = nil
	m.clearedFields[sessionlock.FieldLockedBy] = struct{}{}
}

// LockedByCleared returns if the "locked_by" field was cleared in this mutation.
func (m *SessionLockMutation) LockedByCleared() bool {
	_, ok := m.clearedFields[sessionlock.FieldLockedBy]
	return ok
}

// ResetLockedBy resets all changes to the "locked_by" field.
func (m *SessionLockMutation) ResetLockedBy() {
	m.locked_by = nil
	delete(m.clearedFields, sessionlock.FieldLockedBy)
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionLockMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[sessionlock.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionLockMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionLockMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionLockMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionLockMutation builder.
func (m *SessionLockMutation) Where(ps ...predicate.SessionLock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionLockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionLockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SessionLock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionLockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionLockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SessionLock).
func (m *SessionLockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionLockMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, sessionlock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sessionlock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sessionlock.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, sessionlock.FieldUserID)
	}
	if m.locked_at != nil {
		fields = append(fields, sessionlock.FieldLockedAt)
	}
	if m.unlocked_at != nil {
		fields = append(fields, sessionlock.FieldUnlockedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, sessionlock.FieldExpiresAt)
	}
	if m.reason != nil {
		fields = append(fields, sessionlock.FieldReason)
	}
	if m.locked_by != nil {
		fields = append(fields, sessionlock.FieldLockedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionLockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sessionlock.FieldCreatedAt:
		return m.CreatedAt()
	case sessionlock.FieldUpdatedAt:
		return m.UpdatedAt()
	case sessionlock.FieldDeletedAt:
		return m.DeletedAt()
	case sessionlock.FieldUserID:
		return m.UserID()
	case sessionlock.FieldLockedAt:
		return m.LockedAt()
	case sessionlock.FieldUnlockedAt:
		return m.UnlockedAt()
	case sessionlock.FieldExpiresAt:
		return m.ExpiresAt()
	case sessionlock.FieldReason:
		return m.Reason()
	case sessionlock.FieldLockedBy:
		return m.LockedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionLockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sessionlock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sessionlock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sessionlock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case sessionlock.FieldUserID:
		return m.OldUserID(ctx)
	case sessionlock.FieldLockedAt:
		return m.OldLockedAt(ctx)
	case sessionlock.FieldUnlockedAt:
		return m.OldUnlockedAt(ctx)
	case sessionlock.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case sessionlock.FieldReason:
		return m.OldReason(ctx)
	case sessionlock.FieldLockedBy:
		return m.OldLockedBy(ctx)
	}
	return nil, fmt.Errorf("unknown SessionLock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionLockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sessionlock.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sessionlock.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sessionlock.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case sessionlock.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case sessionlock.FieldLockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedAt(v)
		return nil
	case sessionlock.FieldUnlockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnlockedAt(v)
		return nil
	case sessionlock.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case sessionlock.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case sessionlock.FieldLockedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedBy(v)
		return nil
	}
	return fmt.Errorf("unknown SessionLock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionLockMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionLockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionLockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SessionLock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionLockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sessionlock.FieldDeletedAt) {
		fields = append(fields, sessionlock.FieldDeletedAt)
	}
	if m.FieldCleared(sessionlock.FieldUnlockedAt) {
		fields = append(fields, sessionlock.FieldUnlockedAt)
	}
	if m.FieldCleared(sessionlock.FieldLockedBy) {
		fields = append(fields, sessionlock.FieldLockedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionLockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionLockMutation) ClearField(name string) error {
	switch name {
	case sessionlock.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case sessionlock.FieldUnlockedAt:
		m.ClearUnlockedAt()
		return nil
	case sessionlock.FieldLockedBy:
		m.ClearLockedBy()
		return nil
	}
	return fmt.Errorf("unknown SessionLock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionLockMutation) ResetField(name string) error {
	switch name {
	case sessionlock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sessionlock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sessionlock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case sessionlock.FieldUserID:
		m.ResetUserID()
		return nil
	case sessionlock.FieldLockedAt:
		m.ResetLockedAt()
		return nil
	case sessionlock.FieldUnlockedAt:
		m.ResetUnlockedAt()
		return nil
	case sessionlock.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case sessionlock.FieldReason:
		m.ResetReason()
		return nil
	case sessionlock.FieldLockedBy:
		m.ResetLockedBy()
		return nil
	}
	return fmt.Errorf("unknown SessionLock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionLockMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, sessionlock.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionLockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sessionlock.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionLockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionLockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionLockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, sessionlock.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionLockMutation) EdgeCleared(name string) bool {
	switch name {
	case sessionlock.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionLockMutation) ClearEdge(name string) error {
	switch name {
	case sessionlock.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SessionLock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionLockMutation) ResetEdge(name string) error {
	switch name {
	case sessionlock.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SessionLock edge %s", name)
}

// SudoSessionMutation represents an operation that mutates the SudoSession nodes in the graph.
type SudoSessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token_hash    *string
	expires_at    *time.Time
	ip_address    *string
	user_agent    *string
	last_used_at  *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*SudoSession, error)
	predicates    []predicate.SudoSession
}

var _ ent.Mutation = (*SudoSessionMutation)(nil)

// sudosessionOption allows management of the mutation configuration using functional options.
type sudosessionOption func(*SudoSessionMutation)

// newSudoSessionMutation creates new mutation for the SudoSession entity.
func newSudoSessionMutation(c config, op Op, opts ...sudosessionOption) *SudoSessionMutation {
	m := &SudoSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSudoSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSudoSessionID sets the ID field of the mutation.
func withSudoSessionID(id int) sudosessionOption {
	return func(m *SudoSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *SudoSession
		)
		m.oldValue = func(ctx context.Context) (*SudoSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SudoSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSudoSession sets the old SudoSession of the mutation.
func withSudoSession(node *SudoSession) sudosessionOption {
	return func(m *SudoSessionMutation) {
		m.oldValue = func(context.Context) (*SudoSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SudoSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SudoSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SudoSessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SudoSessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SudoSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SudoSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SudoSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SudoSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SudoSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SudoSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SudoSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SudoSessionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SudoSessionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SudoSessionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sudosession.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SudoSessionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sudosession.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SudoSessionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sudosession.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *SudoSessionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SudoSessionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SudoSessionMutation) ResetUserID() {
	m.user = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *SudoSessionMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *SudoSessionMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *SudoSessionMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SudoSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SudoSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SudoSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *SudoSessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SudoSessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SudoSessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[sudosession.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SudoSessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[sudosession.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SudoSessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, sudosession.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *SudoSessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SudoSessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SudoSessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[sudosession.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SudoSessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[sudosession.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SudoSessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, sudosession.FieldUserAgent)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *SudoSessionMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *SudoSessionMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *SudoSessionMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[sudosession.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *SudoSessionMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[sudosession.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *SudoSessionMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, sudosession.FieldLastUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *SudoSessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[sudosession.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SudoSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SudoSessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SudoSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SudoSessionMutation builder.
func (m *SudoSessionMutation) Where(ps ...predicate.SudoSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SudoSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SudoSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SudoSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SudoSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SudoSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SudoSession).
func (m *SudoSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SudoSessionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, sudosession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sudosession.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sudosession.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, sudosession.FieldUserID)
	}
	if m.token_hash != nil {
		fields = append(fields, sudosession.FieldTokenHash)
	}
	if m.expires_at != nil {
		fields = append(fields, sudosession.FieldExpiresAt)
	}
	if m.ip_address != nil {
		fields = append(fields, sudosession.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, sudosession.FieldUserAgent)
	}
	if m.last_used_at != nil {
		fields = append(fields, sudosession.FieldLastUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SudoSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sudosession.FieldCreatedAt:
		return m.CreatedAt()
	case sudosession.FieldUpdatedAt:
		return m.UpdatedAt()
	case sudosession.FieldDeletedAt:
		return m.DeletedAt()
	case sudosession.FieldUserID:
		return m.UserID()
	case sudosession.FieldTokenHash:
		return m.TokenHash()
	case sudosession.FieldExpiresAt:
		return m.ExpiresAt()
	case sudosession.FieldIPAddress:
		return m.IPAddress()
	case sudosession.FieldUserAgent:
		return m.UserAgent()
	case sudosession.FieldLastUsedAt:
		return m.LastUsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SudoSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sudosession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sudosession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sudosession.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case sudosession.FieldUserID:
		return m.OldUserID(ctx)
	case sudosession.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case sudosession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case sudosession.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case sudosession.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case sudosession.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SudoSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SudoSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sudosession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sudosession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sudosession.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case sudosession.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case sudosession.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case sudosession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case sudosession.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case sudosession.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case sudosession.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SudoSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SudoSessionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SudoSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SudoSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SudoSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SudoSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sudosession.FieldDeletedAt) {
		fields = append(fields, sudosession.FieldDeletedAt)
	}
	if m.FieldCleared(sudosession.FieldIPAddress) {
		fields = append(fields, sudosession.FieldIPAddress)
	}
	if m.FieldCleared(sudosession.FieldUserAgent) {
		fields = append(fields, sudosession.FieldUserAgent)
	}
	if m.FieldCleared(sudosession.FieldLastUsedAt) {
		fields = append(fields, sudosession.FieldLastUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SudoSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SudoSessionMutation) ClearField(name string) error {
	switch name {
	case sudosession.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case sudosession.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case sudosession.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case sudosession.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown SudoSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SudoSessionMutation) ResetField(name string) error {
	switch name {
	case sudosession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sudosession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sudosession.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case sudosession.FieldUserID:
		m.ResetUserID()
		return nil
	case sudosession.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case sudosession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case sudosession.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case sudosession.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case sudosession.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown SudoSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SudoSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, sudosession.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SudoSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sudosession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SudoSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SudoSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SudoSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, sudosession.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SudoSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case sudosession.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SudoSessionMutation) ClearEdge(name string) error {
	switch name {
	case sudosession.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SudoSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SudoSessionMutation) ResetEdge(name string) error {
	switch name {
	case sudosession.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SudoSession edge %s", name)
}

// TOTPPendingTokenMutation represents an operation that mutates the TOTPPendingToken nodes in the graph.
type TOTPPendingTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token_hash    *string
	expires_at    *time.Time
	used_at       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*TOTPPendingToken, error)
	predicates    []predicate.TOTPPendingToken
}

var _ ent.Mutation = (*TOTPPendingTokenMutation)(nil)

// totppendingtokenOption allows management of the mutation configuration using functional options.
type totppendingtokenOption func(*TOTPPendingTokenMutation)

// newTOTPPendingTokenMutation creates new mutation for the TOTPPendingToken entity.
func newTOTPPendingTokenMutation(c config, op Op, opts ...totppendingtokenOption) *TOTPPendingTokenMutation {
	m := &TOTPPendingTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeTOTPPendingToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTOTPPendingTokenID sets the ID field of the mutation.
func withTOTPPendingTokenID(id int) totppendingtokenOption {
	return func(m *TOTPPendingTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *TOTPPendingToken
		)
		m.oldValue = func(ctx context.Context) (*TOTPPendingToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TOTPPendingToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTOTPPendingToken sets the old TOTPPendingToken of the mutation.
func withTOTPPendingToken(node *TOTPPendingToken) totppendingtokenOption {
	return func(m *TOTPPendingTokenMutation) {
		m.oldValue = func(context.Context) (*TOTPPendingToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TOTPPendingTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TOTPPendingTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TOTPPendingTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TOTPPendingTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TOTPPendingToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TOTPPendingTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TOTPPendingTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TOTPPendingTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TOTPPendingTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TOTPPendingTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TOTPPendingTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TOTPPendingTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TOTPPendingTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TOTPPendingTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[totppendingtoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TOTPPendingTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[totppendingtoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TOTPPendingTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, totppendingtoken.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *TOTPPendingTokenMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TOTPPendingTokenMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TOTPPendingTokenMutation) ResetUserID() {
	m.user = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *TOTPPendingTokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *TOTPPendingTokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *TOTPPendingTokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *TOTPPendingTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TOTPPendingTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TOTPPendingTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsedAt sets the "used_at" field.
func (m *TOTPPendingTokenMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *TOTPPendingTokenMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *TOTPPendingTokenMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[totppendingtoken.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *TOTPPendingTokenMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[totppendingtoken.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *TOTPPendingTokenMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, totppendingtoken.FieldUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *TOTPPendingTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[totppendingtoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TOTPPendingTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TOTPPendingTokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TOTPPendingTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TOTPPendingTokenMutation builder.
func (m *TOTPPendingTokenMutation) Where(ps ...predicate.TOTPPendingToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TOTPPendingTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TOTPPendingTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TOTPPendingToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TOTPPendingTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TOTPPendingTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TOTPPendingToken).
func (m *TOTPPendingTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TOTPPendingTokenMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, totppendingtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, totppendingtoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, totppendingtoken.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, totppendingtoken.FieldUserID)
	}
	if m.token_hash != nil {
		fields = append(fields, totppendingtoken.FieldTokenHash)
	}
	if m.expires_at != nil {
		fields = append(fields, totppendingtoken.FieldExpiresAt)
	}
	if m.used_at != nil {
		fields = append(fields, totppendingtoken.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TOTPPendingTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case totppendingtoken.FieldCreatedAt:
		return m.CreatedAt()
	case totppendingtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case totppendingtoken.FieldDeletedAt:
		return m.DeletedAt()
	case totppendingtoken.FieldUserID:
		return m.UserID()
	case totppendingtoken.FieldTokenHash:
		return m.TokenHash()
	case totppendingtoken.FieldExpiresAt:
		return m.ExpiresAt()
	case totppendingtoken.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TOTPPendingTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case totppendingtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case totppendingtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case totppendingtoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case totppendingtoken.FieldUserID:
		return m.OldUserID(ctx)
	case totppendingtoken.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case totppendingtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case totppendingtoken.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TOTPPendingToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TOTPPendingTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case totppendingtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case totppendingtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case totppendingtoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case totppendingtoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case totppendingtoken.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case totppendingtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case totppendingtoken.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TOTPPendingToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TOTPPendingTokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TOTPPendingTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TOTPPendingTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TOTPPendingToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TOTPPendingTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(totppendingtoken.FieldDeletedAt) {
		fields = append(fields, totppendingtoken.FieldDeletedAt)
	}
	if m.FieldCleared(totppendingtoken.FieldUsedAt) {
		fields = append(fields, totppendingtoken.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TOTPPendingTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TOTPPendingTokenMutation) ClearField(name string) error {
	switch name {
	case totppendingtoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case totppendingtoken.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown TOTPPendingToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TOTPPendingTokenMutation) ResetField(name string) error {
	switch name {
	case totppendingtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case totppendingtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case totppendingtoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case totppendingtoken.FieldUserID:
		m.ResetUserID()
		return nil
	case totppendingtoken.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case totppendingtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case totppendingtoken.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown TOTPPendingToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TOTPPendingTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, totppendingtoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TOTPPendingTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case totppendingtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TOTPPendingTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TOTPPendingTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TOTPPendingTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, totppendingtoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TOTPPendingTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case totppendingtoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TOTPPendingTokenMutation) ClearEdge(name string) error {
	switch name {
	case totppendingtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TOTPPendingToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TOTPPendingTokenMutation) ResetEdge(name string) error {
	switch name {
	case totppendingtoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TOTPPendingToken edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	slug                    *string
	name                    *string
	description             *string
	color                   *string
	icon                    *string
	is_active               *bool
	_order                  *int
	add_order               *int
	clearedFields           map[string]struct{}
	validation_cases        map[int]struct{}
	removedvalidation_cases map[int]struct{}
	clearedvalidation_cases bool
	done                    bool
	oldValue                func(context.Context) (*Tag, error)
	predicates              []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TagMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tag.FieldDeletedAt)
}

// SetSlug sets the "slug" field.
func (m *TagMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TagMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TagMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tag.FieldDescription)
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *TagMutation) ClearColor() {
	m.color = nil
	m.clearedFields[tag.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *TagMutation) ColorCleared() bool {
	_, ok := m.clearedFields[tag.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, tag.FieldColor)
}

// SetIcon sets the "icon" field.
func (m *TagMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *TagMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *TagMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[tag.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *TagMutation) IconCleared() bool {
	_, ok := m.clearedFields[tag.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *TagMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, tag.FieldIcon)
}

// SetIsActive sets the "is_active" field.
func (m *TagMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TagMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TagMutation) ResetIsActive() {
	m.is_active = nil
}

// SetOrder sets the "order" field.
func (m *TagMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *TagMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *TagMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *TagMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *TagMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// AddValidationCaseIDs adds the "validation_cases" edge to the ValidationCase entity by ids.
func (m *TagMutation) AddValidationCaseIDs(ids ...int) {
	if m.validation_cases == nil {
		m.validation_cases = make(map[int]struct{})
	}
	for i := range ids {
		m.validation_cases[ids[i]] = struct{}{}
	}
}

// ClearValidationCases clears the "validation_cases" edge to the ValidationCase entity.
func (m *TagMutation) ClearValidationCases() {
	m.clearedvalidation_cases = true
}

// ValidationCasesCleared reports if the "validation_cases" edge to the ValidationCase entity was cleared.
func (m *TagMutation) ValidationCasesCleared() bool {
	return m.clearedvalidation_cases
}

// RemoveValidationCaseIDs removes the "validation_cases" edge to the ValidationCase entity by IDs.
func (m *TagMutation) RemoveValidationCaseIDs(ids ...int) {
	if m.removedvalidation_cases == nil {
		m.removedvalidation_cases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.validation_cases, ids[i])
		m.removedvalidation_cases[ids[i]] = struct{}{}
	}
}

// RemovedValidationCases returns the removed IDs of the "validation_cases" edge to the ValidationCase entity.
func (m *TagMutation) RemovedValidationCasesIDs() (ids []int) {
	for id := range m.removedvalidation_cases {
		ids = append(ids, id)
	}
	return
}

// ValidationCasesIDs returns the "validation_cases" edge IDs in the mutation.
func (m *TagMutation) ValidationCasesIDs() (ids []int) {
	for id := range m.validation_cases {
		ids = append(ids, id)
	}
	return
}

// ResetValidationCases resets all changes to the "validation_cases" edge.
func (m *TagMutation) ResetValidationCases() {
	m.validation_cases = nil
	m.clearedvalidation_cases = false
	m.removedvalidation_cases = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tag.FieldDeletedAt)
	}
	if m.slug != nil {
		fields = append(fields, tag.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	if m.icon != nil {
		fields = append(fields, tag.FieldIcon)
	}
	if m.is_active != nil {
		fields = append(fields, tag.FieldIsActive)
	}
	if m._order != nil {
		fields = append(fields, tag.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldDeletedAt:
		return m.DeletedAt()
	case tag.FieldSlug:
		return m.Slug()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldColor:
		return m.Color()
	case tag.FieldIcon:
		return m.Icon()
	case tag.FieldIsActive:
		return m.IsActive()
	case tag.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tag.FieldSlug:
		return m.OldSlug(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	case tag.FieldIcon:
		return m.OldIcon(ctx)
	case tag.FieldIsActive:
		return m.OldIsActive(ctx)
	case tag.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tag.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case tag.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case tag.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case tag.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, tag.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tag.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDeletedAt) {
		fields = append(fields, tag.FieldDeletedAt)
	}
	if m.FieldCleared(tag.FieldDescription) {
		fields = append(fields, tag.FieldDescription)
	}
	if m.FieldCleared(tag.FieldColor) {
		fields = append(fields, tag.FieldColor)
	}
	if m.FieldCleared(tag.FieldIcon) {
		fields = append(fields, tag.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tag.FieldDescription:
		m.ClearDescription()
		return nil
	case tag.FieldColor:
		m.ClearColor()
		return nil
	case tag.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tag.FieldSlug:
		m.ResetSlug()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	case tag.FieldIcon:
		m.ResetIcon()
		return nil
	case tag.FieldIsActive:
		m.ResetIsActive()
		return nil
	case tag.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.validation_cases != nil {
		edges = append(edges, tag.EdgeValidationCases)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeValidationCases:
		ids := make([]ent.Value, 0, len(m.validation_cases))
		for id := range m.validation_cases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvalidation_cases != nil {
		edges = append(edges, tag.EdgeValidationCases)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeValidationCases:
		ids := make([]ent.Value, 0, len(m.removedvalidation_cases))
		for id := range m.removedvalidation_cases {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvalidation_cases {
		edges = append(edges, tag.EdgeValidationCases)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeValidationCases:
		return m.clearedvalidation_cases
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeValidationCases:
		m.ResetValidationCases()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	email                            *string
	username                         *string
	password_hash                    *string
	email_verified                   *bool
	avatar_url                       *string
	full_name                        *string
	bio                              *string
	pronouns                         *string
	company                          *string
	telegram                         *string
	social_accounts                  *map[string]interface{}
	totp_secret                      *string
	totp_enabled                     *bool
	totp_verified                    *bool
	totp_verified_at                 *time.Time
	failed_login_attempts            *int
	addfailed_login_attempts         *int
	last_failed_at                   *time.Time
	last_login_at                    *time.Time
	last_login_ip                    *string
	locked_until                     *time.Time
	lock_reason                      *string
	guarantee_amount                 *int64
	addguarantee_amount              *int64
	clearedFields                    map[string]struct{}
	passkeys                         map[int]struct{}
	removedpasskeys                  map[int]struct{}
	clearedpasskeys                  bool
	sessions                         map[int]struct{}
	removedsessions                  map[int]struct{}
	clearedsessions                  bool
	backup_codes                     map[int]struct{}
	removedbackup_codes              map[int]struct{}
	clearedbackup_codes              bool
	validation_cases                 map[int]struct{}
	removedvalidation_cases          map[int]struct{}
	clearedvalidation_cases          bool
	user_badges                      map[int]struct{}
	removeduser_badges               map[int]struct{}
	cleareduser_badges               bool
	session_locks                    map[int]struct{}
	removedsession_locks             map[int]struct{}
	clearedsession_locks             bool
	email_verification_tokens        map[int]struct{}
	removedemail_verification_tokens map[int]struct{}
	clearedemail_verification_tokens bool
	password_reset_tokens            map[int]struct{}
	removedpassword_reset_tokens     map[int]struct{}
	clearedpassword_reset_tokens     bool
	credentials                      map[int]struct{}
	removedcredentials               map[int]struct{}
	clearedcredentials               bool
	totp_pending_tokens              map[int]struct{}
	removedtotp_pending_tokens       map[int]struct{}
	clearedtotp_pending_tokens       bool
	security_events                  map[int]struct{}
	removedsecurity_events           map[int]struct{}
	clearedsecurity_events           bool
	device_fingerprints              map[int]struct{}
	removeddevice_fingerprints       map[int]struct{}
	cleareddevice_fingerprints       bool
	device_user_mappings             map[int]struct{}
	removeddevice_user_mappings      map[int]struct{}
	cleareddevice_user_mappings      bool
	sudo_sessions                    map[int]struct{}
	removedsudo_sessions             map[int]struct{}
	clearedsudo_sessions             bool
	validation_case_logs             map[int]struct{}
	removedvalidation_case_logs      map[int]struct{}
	clearedvalidation_case_logs      bool
	consultation_requests            map[int]struct{}
	removedconsultation_requests     map[int]struct{}
	clearedconsultation_requests     bool
	final_offers                     map[int]struct{}
	removedfinal_offers              map[int]struct{}
	clearedfinal_offers              bool
	artifact_submissions             map[int]struct{}
	removedartifact_submissions      map[int]struct{}
	clearedartifact_submissions      bool
	endorsements                     map[int]struct{}
	removedendorsements              map[int]struct{}
	clearedendorsements              bool
	primary_badge                    *int
	clearedprimary_badge             bool
	done                             bool
	oldValue                         func(context.Context) (*User, error)
	predicates                       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetFullName sets the "full_name" field.
func (m *UserMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *UserMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFullName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ClearFullName clears the value of the "full_name" field.
func (m *UserMutation) ClearFullName() {
	m.full_name = nil
	m.clearedFields[user.FieldFullName] = struct{}{}
}

// FullNameCleared returns if the "full_name" field was cleared in this mutation.
func (m *UserMutation) FullNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFullName]
	return ok
}

// ResetFullName resets all changes to the "full_name" field.
func (m *UserMutation) ResetFullName() {
	m.full_name = nil
	delete(m.clearedFields, user.FieldFullName)
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetPronouns sets the "pronouns" field.
func (m *UserMutation) SetPronouns(s string) {
	m.pronouns = &s
}

// Pronouns returns the value of the "pronouns" field in the mutation.
func (m *UserMutation) Pronouns() (r string, exists bool) {
	v := m.pronouns
	if v == nil {
		return
	}
	return *v, true
}

// OldPronouns returns the old "pronouns" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPronouns(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPronouns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPronouns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPronouns: %w", err)
	}
	return oldValue.Pronouns, nil
}

// ClearPronouns clears the value of the "pronouns" field.
func (m *UserMutation) ClearPronouns() {
	m.pronouns = nil
	m.clearedFields[user.FieldPronouns] = struct{}{}
}

// PronounsCleared returns if the "pronouns" field was cleared in this mutation.
func (m *UserMutation) PronounsCleared() bool {
	_, ok := m.clearedFields[user.FieldPronouns]
	return ok
}

// ResetPronouns resets all changes to the "pronouns" field.
func (m *UserMutation) ResetPronouns() {
	m.pronouns = nil
	delete(m.clearedFields, user.FieldPronouns)
}

// SetCompany sets the "company" field.
func (m *UserMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *UserMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *UserMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[user.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *UserMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[user.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *UserMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, user.FieldCompany)
}

// SetTelegram sets the "telegram" field.
func (m *UserMutation) SetTelegram(s string) {
	m.telegram = &s
}

// Telegram returns the value of the "telegram" field in the mutation.
func (m *UserMutation) Telegram() (r string, exists bool) {
	v := m.telegram
	if v == nil {
		return
	}
	return *v, true
}

// OldTelegram returns the old "telegram" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTelegram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelegram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelegram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelegram: %w", err)
	}
	return oldValue.Telegram, nil
}

// ClearTelegram clears the value of the "telegram" field.
func (m *UserMutation) ClearTelegram() {
	m.telegram = nil
	m.clearedFields[user.FieldTelegram] = struct{}{}
}

// TelegramCleared returns if the "telegram" field was cleared in this mutation.
func (m *UserMutation) TelegramCleared() bool {
	_, ok := m.clearedFields[user.FieldTelegram]
	return ok
}

// ResetTelegram resets all changes to the "telegram" field.
func (m *UserMutation) ResetTelegram() {
	m.telegram = nil
	delete(m.clearedFields, user.FieldTelegram)
}

// SetSocialAccounts sets the "social_accounts" field.
func (m *UserMutation) SetSocialAccounts(value map[string]interface{}) {
	m.social_accounts = &value
}

// SocialAccounts returns the value of the "social_accounts" field in the mutation.
func (m *UserMutation) SocialAccounts() (r map[string]interface{}, exists bool) {
	v := m.social_accounts
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialAccounts returns the old "social_accounts" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSocialAccounts(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialAccounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialAccounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialAccounts: %w", err)
	}
	return oldValue.SocialAccounts, nil
}

// ClearSocialAccounts clears the value of the "social_accounts" field.
func (m *UserMutation) ClearSocialAccounts() {
	m.social_accounts = nil
	m.clearedFields[user.FieldSocialAccounts] = struct{}{}
}

// SocialAccountsCleared returns if the "social_accounts" field was cleared in this mutation.
func (m *UserMutation) SocialAccountsCleared() bool {
	_, ok := m.clearedFields[user.FieldSocialAccounts]
	return ok
}

// ResetSocialAccounts resets all changes to the "social_accounts" field.
func (m *UserMutation) ResetSocialAccounts() {
	m.social_accounts = nil
	delete(m.clearedFields, user.FieldSocialAccounts)
}

// SetPrimaryBadgeID sets the "primary_badge_id" field.
func (m *UserMutation) SetPrimaryBadgeID(i int) {
	m.primary_badge = &i
}

// PrimaryBadgeID returns the value of the "primary_badge_id" field in the mutation.
func (m *UserMutation) PrimaryBadgeID() (r int, exists bool) {
	v := m.primary_badge
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryBadgeID returns the old "primary_badge_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrimaryBadgeID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryBadgeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryBadgeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryBadgeID: %w", err)
	}
	return oldValue.PrimaryBadgeID, nil
}

// ClearPrimaryBadgeID clears the value of the "primary_badge_id" field.
func (m *UserMutation) ClearPrimaryBadgeID() {
	m.primary_badge = nil
	m.clearedFields[user.FieldPrimaryBadgeID] = struct{}{}
}

// PrimaryBadgeIDCleared returns if the "primary_badge_id" field was cleared in this mutation.
func (m *UserMutation) PrimaryBadgeIDCleared() bool {
	_, ok := m.clearedFields[user.FieldPrimaryBadgeID]
	return ok
}

// ResetPrimaryBadgeID resets all changes to the "primary_badge_id" field.
func (m *UserMutation) ResetPrimaryBadgeID() {
	m.primary_badge = nil
	delete(m.clearedFields, user.FieldPrimaryBadgeID)
}

// SetTotpSecret sets the "totp_secret" field.
func (m *UserMutation) SetTotpSecret(s string) {
	m.totp_secret = &s
}

// TotpSecret returns the value of the "totp_secret" field in the mutation.
func (m *UserMutation) TotpSecret() (r string, exists bool) {
	v := m.totp_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpSecret returns the old "totp_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpSecret(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpSecret: %w", err)
	}
	return oldValue.TotpSecret, nil
}

// ClearTotpSecret clears the value of the "totp_secret" field.
func (m *UserMutation) ClearTotpSecret() {
	m.totp_secret = nil
	m.clearedFields[user.FieldTotpSecret] = struct{}{}
}

// TotpSecretCleared returns if the "totp_secret" field was cleared in this mutation.
func (m *UserMutation) TotpSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldTotpSecret]
	return ok
}

// ResetTotpSecret resets all changes to the "totp_secret" field.
func (m *UserMutation) ResetTotpSecret() {
	m.totp_secret = nil
	delete(m.clearedFields, user.FieldTotpSecret)
}

// SetTotpEnabled sets the "totp_enabled" field.
func (m *UserMutation) SetTotpEnabled(b bool) {
	m.totp_enabled = &b
}

// TotpEnabled returns the value of the "totp_enabled" field in the mutation.
func (m *UserMutation) TotpEnabled() (r bool, exists bool) {
	v := m.totp_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpEnabled returns the old "totp_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpEnabled: %w", err)
	}
	return oldValue.TotpEnabled, nil
}

// ResetTotpEnabled resets all changes to the "totp_enabled" field.
func (m *UserMutation) ResetTotpEnabled() {
	m.totp_enabled = nil
}

// SetTotpVerified sets the "totp_verified" field.
func (m *UserMutation) SetTotpVerified(b bool) {
	m.totp_verified = &b
}

// TotpVerified returns the value of the "totp_verified" field in the mutation.
func (m *UserMutation) TotpVerified() (r bool, exists bool) {
	v := m.totp_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpVerified returns the old "totp_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpVerified: %w", err)
	}
	return oldValue.TotpVerified, nil
}

// ResetTotpVerified resets all changes to the "totp_verified" field.
func (m *UserMutation) ResetTotpVerified() {
	m.totp_verified = nil
}

// SetTotpVerifiedAt sets the "totp_verified_at" field.
func (m *UserMutation) SetTotpVerifiedAt(t time.Time) {
	m.totp_verified_at = &t
}

// TotpVerifiedAt returns the value of the "totp_verified_at" field in the mutation.
func (m *UserMutation) TotpVerifiedAt() (r time.Time, exists bool) {
	v := m.totp_verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpVerifiedAt returns the old "totp_verified_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpVerifiedAt: %w", err)
	}
	return oldValue.TotpVerifiedAt, nil
}

// ClearTotpVerifiedAt clears the value of the "totp_verified_at" field.
func (m *UserMutation) ClearTotpVerifiedAt() {
	m.totp_verified_at = nil
	m.clearedFields[user.FieldTotpVerifiedAt] = struct{}{}
}

// TotpVerifiedAtCleared returns if the "totp_verified_at" field was cleared in this mutation.
func (m *UserMutation) TotpVerifiedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldTotpVerifiedAt]
	return ok
}

// ResetTotpVerifiedAt resets all changes to the "totp_verified_at" field.
func (m *UserMutation) ResetTotpVerifiedAt() {
	m.totp_verified_at = nil
	delete(m.clearedFields, user.FieldTotpVerifiedAt)
}

// SetFailedLoginAttempts sets the "failed_login_attempts" field.
func (m *UserMutation) SetFailedLoginAttempts(i int) {
	m.failed_login_attempts = &i
	m.addfailed_login_attempts = nil
}

// FailedLoginAttempts returns the value of the "failed_login_attempts" field in the mutation.
func (m *UserMutation) FailedLoginAttempts() (r int, exists bool) {
	v := m.failed_login_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedLoginAttempts returns the old "failed_login_attempts" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFailedLoginAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedLoginAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedLoginAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedLoginAttempts: %w", err)
	}
	return oldValue.FailedLoginAttempts, nil
}

// AddFailedLoginAttempts adds i to the "failed_login_attempts" field.
func (m *UserMutation) AddFailedLoginAttempts(i int) {
	if m.addfailed_login_attempts != nil {
		*m.addfailed_login_attempts += i
	} else {
		m.addfailed_login_attempts = &i
	}
}

// AddedFailedLoginAttempts returns the value that was added to the "failed_login_attempts" field in this mutation.
func (m *UserMutation) AddedFailedLoginAttempts() (r int, exists bool) {
	v := m.addfailed_login_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailedLoginAttempts resets all changes to the "failed_login_attempts" field.
func (m *UserMutation) ResetFailedLoginAttempts() {
	m.failed_login_attempts = nil
	m.addfailed_login_attempts = nil
}

// SetLastFailedAt sets the "last_failed_at" field.
func (m *UserMutation) SetLastFailedAt(t time.Time) {
	m.last_failed_at = &t
}

// LastFailedAt returns the value of the "last_failed_at" field in the mutation.
func (m *UserMutation) LastFailedAt() (r time.Time, exists bool) {
	v := m.last_failed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastFailedAt returns the old "last_failed_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastFailedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastFailedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastFailedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastFailedAt: %w", err)
	}
	return oldValue.LastFailedAt, nil
}

// ClearLastFailedAt clears the value of the "last_failed_at" field.
func (m *UserMutation) ClearLastFailedAt() {
	m.last_failed_at = nil
	m.clearedFields[user.FieldLastFailedAt] = struct{}{}
}

// LastFailedAtCleared returns if the "last_failed_at" field was cleared in this mutation.
func (m *UserMutation) LastFailedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastFailedAt]
	return ok
}

// ResetLastFailedAt resets all changes to the "last_failed_at" field.
func (m *UserMutation) ResetLastFailedAt() {
	m.last_failed_at = nil
	delete(m.clearedFields, user.FieldLastFailedAt)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *UserMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *UserMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (m *UserMutation) ClearLastLoginIP() {
	m.last_login_ip = nil
	m.clearedFields[user.FieldLastLoginIP] = struct{}{}
}

// LastLoginIPCleared returns if the "last_login_ip" field was cleared in this mutation.
func (m *UserMutation) LastLoginIPCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginIP]
	return ok
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *UserMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
	delete(m.clearedFields, user.FieldLastLoginIP)
}

// SetLockedUntil sets the "locked_until" field.
func (m *UserMutation) SetLockedUntil(t time.Time) {
	m.locked_until = &t
}

// LockedUntil returns the value of the "locked_until" field in the mutation.
func (m *UserMutation) LockedUntil() (r time.Time, exists bool) {
	v := m.locked_until
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedUntil returns the old "locked_until" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLockedUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedUntil: %w", err)
	}
	return oldValue.LockedUntil, nil
}

// ClearLockedUntil clears the value of the "locked_until" field.
func (m *UserMutation) ClearLockedUntil() {
	m.locked_until = nil
	m.clearedFields[user.FieldLockedUntil] = struct{}{}
}

// LockedUntilCleared returns if the "locked_until" field was cleared in this mutation.
func (m *UserMutation) LockedUntilCleared() bool {
	_, ok := m.clearedFields[user.FieldLockedUntil]
	return ok
}

// ResetLockedUntil resets all changes to the "locked_until" field.
func (m *UserMutation) ResetLockedUntil() {
	m.locked_until = nil
	delete(m.clearedFields, user.FieldLockedUntil)
}

// SetLockReason sets the "lock_reason" field.
func (m *UserMutation) SetLockReason(s string) {
	m.lock_reason = &s
}

// LockReason returns the value of the "lock_reason" field in the mutation.
func (m *UserMutation) LockReason() (r string, exists bool) {
	v := m.lock_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldLockReason returns the old "lock_reason" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLockReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockReason: %w", err)
	}
	return oldValue.LockReason, nil
}

// ClearLockReason clears the value of the "lock_reason" field.
func (m *UserMutation) ClearLockReason() {
	m.lock_reason = nil
	m.clearedFields[user.FieldLockReason] = struct{}{}
}

// LockReasonCleared returns if the "lock_reason" field was cleared in this mutation.
func (m *UserMutation) LockReasonCleared() bool {
	_, ok := m.clearedFields[user.FieldLockReason]
	return ok
}

// ResetLockReason resets all changes to the "lock_reason" field.
func (m *UserMutation) ResetLockReason() {
	m.lock_reason = nil
	delete(m.clearedFields, user.FieldLockReason)
}

// SetGuaranteeAmount sets the "guarantee_amount" field.
func (m *UserMutation) SetGuaranteeAmount(i int64) {
	m.guarantee_amount = &i
	m.addguarantee_amount = nil
}

// GuaranteeAmount returns the value of the "guarantee_amount" field in the mutation.
func (m *UserMutation) GuaranteeAmount() (r int64, exists bool) {
	v := m.guarantee_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldGuaranteeAmount returns the old "guarantee_amount" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGuaranteeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuaranteeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuaranteeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuaranteeAmount: %w", err)
	}
	return oldValue.GuaranteeAmount, nil
}

// AddGuaranteeAmount adds i to the "guarantee_amount" field.
func (m *UserMutation) AddGuaranteeAmount(i int64) {
	if m.addguarantee_amount != nil {
		*m.addguarantee_amount += i
	} else {
		m.addguarantee_amount = &i
	}
}

// AddedGuaranteeAmount returns the value that was added to the "guarantee_amount" field in this mutation.
func (m *UserMutation) AddedGuaranteeAmount() (r int64, exists bool) {
	v := m.addguarantee_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetGuaranteeAmount resets all changes to the "guarantee_amount" field.
func (m *UserMutation) ResetGuaranteeAmount() {
	m.guarantee_amount = nil
	m.addguarantee_amount = nil
}

// AddPasskeyIDs adds the "passkeys" edge to the Passkey entity by ids.
func (m *UserMutation) AddPasskeyIDs(ids ...int) {
	if m.passkeys == nil {
		m.passkeys = make(map[int]struct{})
	}
	for i := range ids {
		m.passkeys[ids[i]] = struct{}{}
	}
}

// ClearPasskeys clears the "passkeys" edge to the Passkey entity.
func (m *UserMutation) ClearPasskeys() {
	m.clearedpasskeys = true
}

// PasskeysCleared reports if the "passkeys" edge to the Passkey entity was cleared.
func (m *UserMutation) PasskeysCleared() bool {
	return m.clearedpasskeys
}

// RemovePasskeyIDs removes the "passkeys" edge to the Passkey entity by IDs.
func (m *UserMutation) RemovePasskeyIDs(ids ...int) {
	if m.removedpasskeys == nil {
		m.removedpasskeys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.passkeys, ids[i])
		m.removedpasskeys[ids[i]] = struct{}{}
	}
}

// RemovedPasskeys returns the removed IDs of the "passkeys" edge to the Passkey entity.
func (m *UserMutation) RemovedPasskeysIDs() (ids []int) {
	for id := range m.removedpasskeys {
		ids = append(ids, id)
	}
	return
}

// PasskeysIDs returns the "passkeys" edge IDs in the mutation.
func (m *UserMutation) PasskeysIDs() (ids []int) {
	for id := range m.passkeys {
		ids = append(ids, id)
	}
	return
}

// ResetPasskeys resets all changes to the "passkeys" edge.
func (m *UserMutation) ResetPasskeys() {
	m.passkeys = nil
	m.clearedpasskeys = false
	m.removedpasskeys = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddBackupCodeIDs adds the "backup_codes" edge to the BackupCode entity by ids.
func (m *UserMutation) AddBackupCodeIDs(ids ...int) {
	if m.backup_codes == nil {
		m.backup_codes = make(map[int]struct{})
	}
	for i := range ids {
		m.backup_codes[ids[i]] = struct{}{}
	}
}

// ClearBackupCodes clears the "backup_codes" edge to the BackupCode entity.
func (m *UserMutation) ClearBackupCodes() {
	m.clearedbackup_codes = true
}

// BackupCodesCleared reports if the "backup_codes" edge to the BackupCode entity was cleared.
func (m *UserMutation) BackupCodesCleared() bool {
	return m.clearedbackup_codes
}

// RemoveBackupCodeIDs removes the "backup_codes" edge to the BackupCode entity by IDs.
func (m *UserMutation) RemoveBackupCodeIDs(ids ...int) {
	if m.removedbackup_codes == nil {
		m.removedbackup_codes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.backup_codes, ids[i])
		m.removedbackup_codes[ids[i]] = struct{}{}
	}
}

// RemovedBackupCodes returns the removed IDs of the "backup_codes" edge to the BackupCode entity.
func (m *UserMutation) RemovedBackupCodesIDs() (ids []int) {
	for id := range m.removedbackup_codes {
		ids = append(ids, id)
	}
	return
}

// BackupCodesIDs returns the "backup_codes" edge IDs in the mutation.
func (m *UserMutation) BackupCodesIDs() (ids []int) {
	for id := range m.backup_codes {
		ids = append(ids, id)
	}
	return
}

// ResetBackupCodes resets all changes to the "backup_codes" edge.
func (m *UserMutation) ResetBackupCodes() {
	m.backup_codes = nil
	m.clearedbackup_codes = false
	m.removedbackup_codes = nil
}

// AddValidationCaseIDs adds the "validation_cases" edge to the ValidationCase entity by ids.
func (m *UserMutation) AddValidationCaseIDs(ids ...int) {
	if m.validation_cases == nil {
		m.validation_cases = make(map[int]struct{})
	}
	for i := range ids {
		m.validation_cases[ids[i]] = struct{}{}
	}
}

// ClearValidationCases clears the "validation_cases" edge to the ValidationCase entity.
func (m *UserMutation) ClearValidationCases() {
	m.clearedvalidation_cases = true
}

// ValidationCasesCleared reports if the "validation_cases" edge to the ValidationCase entity was cleared.
func (m *UserMutation) ValidationCasesCleared() bool {
	return m.clearedvalidation_cases
}

// RemoveValidationCaseIDs removes the "validation_cases" edge to the ValidationCase entity by IDs.
func (m *UserMutation) RemoveValidationCaseIDs(ids ...int) {
	if m.removedvalidation_cases == nil {
		m.removedvalidation_cases = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.validation_cases, ids[i])
		m.removedvalidation_cases[ids[i]] = struct{}{}
	}
}

// RemovedValidationCases returns the removed IDs of the "validation_cases" edge to the ValidationCase entity.
func (m *UserMutation) RemovedValidationCasesIDs() (ids []int) {
	for id := range m.removedvalidation_cases {
		ids = append(ids, id)
	}
	return
}

// ValidationCasesIDs returns the "validation_cases" edge IDs in the mutation.
func (m *UserMutation) ValidationCasesIDs() (ids []int) {
	for id := range m.validation_cases {
		ids = append(ids, id)
	}
	return
}

// ResetValidationCases resets all changes to the "validation_cases" edge.
func (m *UserMutation) ResetValidationCases() {
	m.validation_cases = nil
	m.clearedvalidation_cases = false
	m.removedvalidation_cases = nil
}

// AddUserBadgeIDs adds the "user_badges" edge to the UserBadge entity by ids.
func (m *UserMutation) AddUserBadgeIDs(ids ...int) {
	if m.user_badges == nil {
		m.user_badges = make(map[int]struct{})
	}
	for i := range ids {
		m.user_badges[ids[i]] = struct{}{}
	}
}

// ClearUserBadges clears the "user_badges" edge to the UserBadge entity.
func (m *UserMutation) ClearUserBadges() {
	m.cleareduser_badges = true
}

// UserBadgesCleared reports if the "user_badges" edge to the UserBadge entity was cleared.
func (m *UserMutation) UserBadgesCleared() bool {
	return m.cleareduser_badges
}

// RemoveUserBadgeIDs removes the "user_badges" edge to the UserBadge entity by IDs.
func (m *UserMutation) RemoveUserBadgeIDs(ids ...int) {
	if m.removeduser_badges == nil {
		m.removeduser_badges = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_badges, ids[i])
		m.removeduser_badges[ids[i]] = struct{}{}
	}
}

// RemovedUserBadges returns the removed IDs of the "user_badges" edge to the UserBadge entity.
func (m *UserMutation) RemovedUserBadgesIDs() (ids []int) {
	for id := range m.removeduser_badges {
		ids = append(ids, id)
	}
	return
}

// UserBadgesIDs returns the "user_badges" edge IDs in the mutation.
func (m *UserMutation) UserBadgesIDs() (ids []int) {
	for id := range m.user_badges {
		ids = append(ids, id)
	}
	return
}

// ResetUserBadges resets all changes to the "user_badges" edge.
func (m *UserMutation) ResetUserBadges() {
	m.user_badges = nil
	m.cleareduser_badges = false
	m.removeduser_badges = nil
}

// AddSessionLockIDs adds the "session_locks" edge to the SessionLock entity by ids.
func (m *UserMutation) AddSessionLockIDs(ids ...int) {
	if m.session_locks == nil {
		m.session_locks = make(map[int]struct{})
	}
	for i := range ids {
		m.session_locks[ids[i]] = struct{}{}
	}
}

// ClearSessionLocks clears the "session_locks" edge to the SessionLock entity.
func (m *UserMutation) ClearSessionLocks() {
	m.clearedsession_locks = true
}

// SessionLocksCleared reports if the "session_locks" edge to the SessionLock entity was cleared.
func (m *UserMutation) SessionLocksCleared() bool {
	return m.clearedsession_locks
}

// RemoveSessionLockIDs removes the "session_locks" edge to the SessionLock entity by IDs.
func (m *UserMutation) RemoveSessionLockIDs(ids ...int) {
	if m.removedsession_locks == nil {
		m.removedsession_locks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.session_locks, ids[i])
		m.removedsession_locks[ids[i]] = struct{}{}
	}
}

// RemovedSessionLocks returns the removed IDs of the "session_locks" edge to the SessionLock entity.
func (m *UserMutation) RemovedSessionLocksIDs() (ids []int) {
	for id := range m.removedsession_locks {
		ids = append(ids, id)
	}
	return
}

// SessionLocksIDs returns the "session_locks" edge IDs in the mutation.
func (m *UserMutation) SessionLocksIDs() (ids []int) {
	for id := range m.session_locks {
		ids = append(ids, id)
	}
	return
}

// ResetSessionLocks resets all changes to the "session_locks" edge.
func (m *UserMutation) ResetSessionLocks() {
	m.session_locks = nil
	m.clearedsession_locks = false
	m.removedsession_locks = nil
}

// AddEmailVerificationTokenIDs adds the "email_verification_tokens" edge to the EmailVerificationToken entity by ids.
func (m *UserMutation) AddEmailVerificationTokenIDs(ids ...int) {
	if m.email_verification_tokens == nil {
		m.email_verification_tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.email_verification_tokens[ids[i]] = struct{}{}
	}
}

// ClearEmailVerificationTokens clears the "email_verification_tokens" edge to the EmailVerificationToken entity.
func (m *UserMutation) ClearEmailVerificationTokens() {
	m.clearedemail_verification_tokens = true
}

// EmailVerificationTokensCleared reports if the "email_verification_tokens" edge to the EmailVerificationToken entity was cleared.
func (m *UserMutation) EmailVerificationTokensCleared() bool {
	return m.clearedemail_verification_tokens
}

// RemoveEmailVerificationTokenIDs removes the "email_verification_tokens" edge to the EmailVerificationToken entity by IDs.
func (m *UserMutation) RemoveEmailVerificationTokenIDs(ids ...int) {
	if m.removedemail_verification_tokens == nil {
		m.removedemail_verification_tokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.email_verification_tokens, ids[i])
		m.removedemail_verification_tokens[ids[i]] = struct{}{}
	}
}

// RemovedEmailVerificationTokens returns the removed IDs of the "email_verification_tokens" edge to the EmailVerificationToken entity.
func (m *UserMutation) RemovedEmailVerificationTokensIDs() (ids []int) {
	for id := range m.removedemail_verification_tokens {
		ids = append(ids, id)
	}
	return
}

// EmailVerificationTokensIDs returns the "email_verification_tokens" edge IDs in the mutation.
func (m *UserMutation) EmailVerificationTokensIDs() (ids []int) {
	for id := range m.email_verification_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetEmailVerificationTokens resets all changes to the "email_verification_tokens" edge.
func (m *UserMutation) ResetEmailVerificationTokens() {
	m.email_verification_tokens = nil
	m.clearedemail_verification_tokens = false
	m.removedemail_verification_tokens = nil
}

// AddPasswordResetTokenIDs adds the "password_reset_tokens" edge to the PasswordResetToken entity by ids.
func (m *UserMutation) AddPasswordResetTokenIDs(ids ...int) {
	if m.password_reset_tokens == nil {
		m.password_reset_tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.password_reset_tokens[ids[i]] = struct{}{}
	}
}

// ClearPasswordResetTokens clears the "password_reset_tokens" edge to the PasswordResetToken entity.
func (m *UserMutation) ClearPasswordResetTokens() {
	m.clearedpassword_reset_tokens = true
}

// PasswordResetTokensCleared reports if the "password_reset_tokens" edge to the PasswordResetToken entity was cleared.
func (m *UserMutation) PasswordResetTokensCleared() bool {
	return m.clearedpassword_reset_tokens
}

// RemovePasswordResetTokenIDs removes the "password_reset_tokens" edge to the PasswordResetToken entity by IDs.
func (m *UserMutation) RemovePasswordResetTokenIDs(ids ...int) {
	if m.removedpassword_reset_tokens == nil {
		m.removedpassword_reset_tokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.password_reset_tokens, ids[i])
		m.removedpassword_reset_tokens[ids[i]] = struct{}{}
	}
}

// RemovedPasswordResetTokens returns the removed IDs of the "password_reset_tokens" edge to the PasswordResetToken entity.
func (m *UserMutation) RemovedPasswordResetTokensIDs() (ids []int) {
	for id := range m.removedpassword_reset_tokens {
		ids = append(ids, id)
	}
	return
}

// PasswordResetTokensIDs returns the "password_reset_tokens" edge IDs in the mutation.
func (m *UserMutation) PasswordResetTokensIDs() (ids []int) {
	for id := range m.password_reset_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetPasswordResetTokens resets all changes to the "password_reset_tokens" edge.
func (m *UserMutation) ResetPasswordResetTokens() {
	m.password_reset_tokens = nil
	m.clearedpassword_reset_tokens = false
	m.removedpassword_reset_tokens = nil
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by ids.
func (m *UserMutation) AddCredentialIDs(ids ...int) {
	if m.credentials == nil {
		m.credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credential entity.
func (m *UserMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credential entity was cleared.
func (m *UserMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credential entity by IDs.
func (m *UserMutation) RemoveCredentialIDs(ids ...int) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credential entity.
func (m *UserMutation) RemovedCredentialsIDs() (ids []int) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *UserMutation) CredentialsIDs() (ids []int) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *UserMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// AddTotpPendingTokenIDs adds the "totp_pending_tokens" edge to the TOTPPendingToken entity by ids.
func (m *UserMutation) AddTotpPendingTokenIDs(ids ...int) {
	if m.totp_pending_tokens == nil {
		m.totp_pending_tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.totp_pending_tokens[ids[i]] = struct{}{}
	}
}

// ClearTotpPendingTokens clears the "totp_pending_tokens" edge to the TOTPPendingToken entity.
func (m *UserMutation) ClearTotpPendingTokens() {
	m.clearedtotp_pending_tokens = true
}

// TotpPendingTokensCleared reports if the "totp_pending_tokens" edge to the TOTPPendingToken entity was cleared.
func (m *UserMutation) TotpPendingTokensCleared() bool {
	return m.clearedtotp_pending_tokens
}

// RemoveTotpPendingTokenIDs removes the "totp_pending_tokens" edge to the TOTPPendingToken entity by IDs.
func (m *UserMutation) RemoveTotpPendingTokenIDs(ids ...int) {
	if m.removedtotp_pending_tokens == nil {
		m.removedtotp_pending_tokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.totp_pending_tokens, ids[i])
		m.removedtotp_pending_tokens[ids[i]] = struct{}{}
	}
}

// RemovedTotpPendingTokens returns the removed IDs of the "totp_pending_tokens" edge to the TOTPPendingToken entity.
func (m *UserMutation) RemovedTotpPendingTokensIDs() (ids []int) {
	for id := range m.removedtotp_pending_tokens {
		ids = append(ids, id)
	}
	return
}

// TotpPendingTokensIDs returns the "totp_pending_tokens" edge IDs in the mutation.
func (m *UserMutation) TotpPendingTokensIDs() (ids []int) {
	for id := range m.totp_pending_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTotpPendingTokens resets all changes to the "totp_pending_tokens" edge.
func (m *UserMutation) ResetTotpPendingTokens() {
	m.totp_pending_tokens = nil
	m.clearedtotp_pending_tokens = false
	m.removedtotp_pending_tokens = nil
}

// AddSecurityEventIDs adds the "security_events" edge to the SecurityEvent entity by ids.
func (m *UserMutation) AddSecurityEventIDs(ids ...int) {
	if m.security_events == nil {
		m.security_events = make(map[int]struct{})
	}
	for i := range ids {
		m.security_events[ids[i]] = struct{}{}
	}
}

// ClearSecurityEvents clears the "security_events" edge to the SecurityEvent entity.
func (m *UserMutation) ClearSecurityEvents() {
	m.clearedsecurity_events = true
}

// SecurityEventsCleared reports if the "security_events" edge to the SecurityEvent entity was cleared.
func (m *UserMutation) SecurityEventsCleared() bool {
	return m.clearedsecurity_events
}

// RemoveSecurityEventIDs removes the "security_events" edge to the SecurityEvent entity by IDs.
func (m *UserMutation) RemoveSecurityEventIDs(ids ...int) {
	if m.removedsecurity_events == nil {
		m.removedsecurity_events = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.security_events, ids[i])
		m.removedsecurity_events[ids[i]] = struct{}{}
	}
}

// RemovedSecurityEvents returns the removed IDs of the "security_events" edge to the SecurityEvent entity.
func (m *UserMutation) RemovedSecurityEventsIDs() (ids []int) {
	for id := range m.removedsecurity_events {
		ids = append(ids, id)
	}
	return
}

// SecurityEventsIDs returns the "security_events" edge IDs in the mutation.
func (m *UserMutation) SecurityEventsIDs() (ids []int) {
	for id := range m.security_events {
		ids = append(ids, id)
	}
	return
}

// ResetSecurityEvents resets all changes to the "security_events" edge.
func (m *UserMutation) ResetSecurityEvents() {
	m.security_events = nil
	m.clearedsecurity_events = false
	m.removedsecurity_events = nil
}

// AddDeviceFingerprintIDs adds the "device_fingerprints" edge to the DeviceFingerprint entity by ids.
func (m *UserMutation) AddDeviceFingerprintIDs(ids ...int) {
	if m.device_fingerprints == nil {
		m.device_fingerprints = make(map[int]struct{})
	}
	for i := range ids {
		m.device_fingerprints[ids[i]] = struct{}{}
	}
}

// ClearDeviceFingerprints clears the "device_fingerprints" edge to the DeviceFingerprint entity.
func (m *UserMutation) ClearDeviceFingerprints() {
	m.cleareddevice_fingerprints = true
}

// DeviceFingerprintsCleared reports if the "device_fingerprints" edge to the DeviceFingerprint entity was cleared.
func (m *UserMutation) DeviceFingerprintsCleared() bool {
	return m.cleareddevice_fingerprints
}

// RemoveDeviceFingerprintIDs removes the "device_fingerprints" edge to the DeviceFingerprint entity by IDs.
func (m *UserMutation) RemoveDeviceFingerprintIDs(ids ...int) {
	if m.removeddevice_fingerprints == nil {
		m.removeddevice_fingerprints = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_fingerprints, ids[i])
		m.removeddevice_fingerprints[ids[i]] = struct{}{}
	}
}

// RemovedDeviceFingerprints returns the removed IDs of the "device_fingerprints" edge to the DeviceFingerprint entity.
func (m *UserMutation) RemovedDeviceFingerprintsIDs() (ids []int) {
	for id := range m.removeddevice_fingerprints {
		ids = append(ids, id)
	}
	return
}

// DeviceFingerprintsIDs returns the "device_fingerprints" edge IDs in the mutation.
func (m *UserMutation) DeviceFingerprintsIDs() (ids []int) {
	for id := range m.device_fingerprints {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceFingerprints resets all changes to the "device_fingerprints" edge.
func (m *UserMutation) ResetDeviceFingerprints() {
	m.device_fingerprints = nil
	m.cleareddevice_fingerprints = false
	m.removeddevice_fingerprints = nil
}

// AddDeviceUserMappingIDs adds the "device_user_mappings" edge to the DeviceUserMapping entity by ids.
func (m *UserMutation) AddDeviceUserMappingIDs(ids ...int) {
	if m.device_user_mappings == nil {
		m.device_user_mappings = make(map[int]struct{})
	}
	for i := range ids {
		m.device_user_mappings[ids[i]] = struct{}{}
	}
}

// ClearDeviceUserMappings clears the "device_user_mappings" edge to the DeviceUserMapping entity.
func (m *UserMutation) ClearDeviceUserMappings() {
	m.cleareddevice_user_mappings = true
}

// DeviceUserMappingsCleared reports if the "device_user_mappings" edge to the DeviceUserMapping entity was cleared.
func (m *UserMutation) DeviceUserMappingsCleared() bool {
	return m.cleareddevice_user_mappings
}

// RemoveDeviceUserMappingIDs removes the "device_user_mappings" edge to the DeviceUserMapping entity by IDs.
func (m *UserMutation) RemoveDeviceUserMappingIDs(ids ...int) {
	if m.removeddevice_user_mappings == nil {
		m.removeddevice_user_mappings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_user_mappings, ids[i])
		m.removeddevice_user_mappings[ids[i]] = struct{}{}
	}
}

// RemovedDeviceUserMappings returns the removed IDs of the "device_user_mappings" edge to the DeviceUserMapping entity.
func (m *UserMutation) RemovedDeviceUserMappingsIDs() (ids []int) {
	for id := range m.removeddevice_user_mappings {
		ids = append(ids, id)
	}
	return
}

// DeviceUserMappingsIDs returns the "device_user_mappings" edge IDs in the mutation.
func (m *UserMutation) DeviceUserMappingsIDs() (ids []int) {
	for id := range m.device_user_mappings {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceUserMappings resets all changes to the "device_user_mappings" edge.
func (m *UserMutation) ResetDeviceUserMappings() {
	m.device_user_mappings = nil
	m.cleareddevice_user_mappings = false
	m.removeddevice_user_mappings = nil
}

// AddSudoSessionIDs adds the "sudo_sessions" edge to the SudoSession entity by ids.
func (m *UserMutation) AddSudoSessionIDs(ids ...int) {
	if m.sudo_sessions == nil {
		m.sudo_sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sudo_sessions[ids[i]] = struct{}{}
	}
}

// ClearSudoSessions clears the "sudo_sessions" edge to the SudoSession entity.
func (m *UserMutation) ClearSudoSessions() {
	m.clearedsudo_sessions = true
}

// SudoSessionsCleared reports if the "sudo_sessions" edge to the SudoSession entity was cleared.
func (m *UserMutation) SudoSessionsCleared() bool {
	return m.clearedsudo_sessions
}

// RemoveSudoSessionIDs removes the "sudo_sessions" edge to the SudoSession entity by IDs.
func (m *UserMutation) RemoveSudoSessionIDs(ids ...int) {
	if m.removedsudo_sessions == nil {
		m.removedsudo_sessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sudo_sessions, ids[i])
		m.removedsudo_sessions[ids[i]] = struct{}{}
	}
}

// RemovedSudoSessions returns the removed IDs of the "sudo_sessions" edge to the SudoSession entity.
func (m *UserMutation) RemovedSudoSessionsIDs() (ids []int) {
	for id := range m.removedsudo_sessions {
		ids = append(ids, id)
	}
	return
}

// SudoSessionsIDs returns the "sudo_sessions" edge IDs in the mutation.
func (m *UserMutation) SudoSessionsIDs() (ids []int) {
	for id := range m.sudo_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSudoSessions resets all changes to the "sudo_sessions" edge.
func (m *UserMutation) ResetSudoSessions() {
	m.sudo_sessions = nil
	m.clearedsudo_sessions = false
	m.removedsudo_sessions = nil
}

// AddValidationCaseLogIDs adds the "validation_case_logs" edge to the ValidationCaseLog entity by ids.
func (m *UserMutation) AddValidationCaseLogIDs(ids ...int) {
	if m.validation_case_logs == nil {
		m.validation_case_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.validation_case_logs[ids[i]] = struct{}{}
	}
}

// ClearValidationCaseLogs clears the "validation_case_logs" edge to the ValidationCaseLog entity.
func (m *UserMutation) ClearValidationCaseLogs() {
	m.clearedvalidation_case_logs = true
}

// ValidationCaseLogsCleared reports if the "validation_case_logs" edge to the ValidationCaseLog entity was cleared.
func (m *UserMutation) ValidationCaseLogsCleared() bool {
	return m.clearedvalidation_case_logs
}

// RemoveValidationCaseLogIDs removes the "validation_case_logs" edge to the ValidationCaseLog entity by IDs.
func (m *UserMutation) RemoveValidationCaseLogIDs(ids ...int) {
	if m.removedvalidation_case_logs == nil {
		m.removedvalidation_case_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.validation_case_logs, ids[i])
		m.removedvalidation_case_logs[ids[i]] = struct{}{}
	}
}

// RemovedValidationCaseLogs returns the removed IDs of the "validation_case_logs" edge to the ValidationCaseLog entity.
func (m *UserMutation) RemovedValidationCaseLogsIDs() (ids []int) {
	for id := range m.removedvalidation_case_logs {
		ids = append(ids, id)
	}
	return
}

// ValidationCaseLogsIDs returns the "validation_case_logs" edge IDs in the mutation.
func (m *UserMutation) ValidationCaseLogsIDs() (ids []int) {
	for id := range m.validation_case_logs {
		ids = append(ids, id)
	}
	return
}

// ResetValidationCaseLogs resets all changes to the "validation_case_logs" edge.
func (m *UserMutation) ResetValidationCaseLogs() {
	m.validation_case_logs = nil
	m.clearedvalidation_case_logs = false
	m.removedvalidation_case_logs = nil
}

// AddConsultationRequestIDs adds the "consultation_requests" edge to the ConsultationRequest entity by ids.
func (m *UserMutation) AddConsultationRequestIDs(ids ...int) {
	if m.consultation_requests == nil {
		m.consultation_requests = make(map[int]struct{})
	}
	for i := range ids {
		m.consultation_requests[ids[i]] = struct{}{}
	}
}

// ClearConsultationRequests clears the "consultation_requests" edge to the ConsultationRequest entity.
func (m *UserMutation) ClearConsultationRequests() {
	m.clearedconsultation_requests = true
}

// ConsultationRequestsCleared reports if the "consultation_requests" edge to the ConsultationRequest entity was cleared.
func (m *UserMutation) ConsultationRequestsCleared() bool {
	return m.clearedconsultation_requests
}

// RemoveConsultationRequestIDs removes the "consultation_requests" edge to the ConsultationRequest entity by IDs.
func (m *UserMutation) RemoveConsultationRequestIDs(ids ...int) {
	if m.removedconsultation_requests == nil {
		m.removedconsultation_requests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.consultation_requests, ids[i])
		m.removedconsultation_requests[ids[i]] = struct{}{}
	}
}

// RemovedConsultationRequests returns the removed IDs of the "consultation_requests" edge to the ConsultationRequest entity.
func (m *UserMutation) RemovedConsultationRequestsIDs() (ids []int) {
	for id := range m.removedconsultation_requests {
		ids = append(ids, id)
	}
	return
}

// ConsultationRequestsIDs returns the "consultation_requests" edge IDs in the mutation.
func (m *UserMutation) ConsultationRequestsIDs() (ids []int) {
	for id := range m.consultation_requests {
		ids = append(ids, id)
	}
	return
}

// ResetConsultationRequests resets all changes to the "consultation_requests" edge.
func (m *UserMutation) ResetConsultationRequests() {
	m.consultation_requests = nil
	m.clearedconsultation_requests = false
	m.removedconsultation_requests = nil
}

// AddFinalOfferIDs adds the "final_offers" edge to the FinalOffer entity by ids.
func (m *UserMutation) AddFinalOfferIDs(ids ...int) {
	if m.final_offers == nil {
		m.final_offers = make(map[int]struct{})
	}
	for i := range ids {
		m.final_offers[ids[i]] = struct{}{}
	}
}

// ClearFinalOffers clears the "final_offers" edge to the FinalOffer entity.
func (m *UserMutation) ClearFinalOffers() {
	m.clearedfinal_offers = true
}

// FinalOffersCleared reports if the "final_offers" edge to the FinalOffer entity was cleared.
func (m *UserMutation) FinalOffersCleared() bool {
	return m.clearedfinal_offers
}

// RemoveFinalOfferIDs removes the "final_offers" edge to the FinalOffer entity by IDs.
func (m *UserMutation) RemoveFinalOfferIDs(ids ...int) {
	if m.removedfinal_offers == nil {
		m.removedfinal_offers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.final_offers, ids[i])
		m.removedfinal_offers[ids[i]] = struct{}{}
	}
}

// RemovedFinalOffers returns the removed IDs of the "final_offers" edge to the FinalOffer entity.
func (m *UserMutation) RemovedFinalOffersIDs() (ids []int) {
	for id := range m.removedfinal_offers {
		ids = append(ids, id)
	}
	return
}

// FinalOffersIDs returns the "final_offers" edge IDs in the mutation.
func (m *UserMutation) FinalOffersIDs() (ids []int) {
	for id := range m.final_offers {
		ids = append(ids, id)
	}
	return
}

// ResetFinalOffers resets all changes to the "final_offers" edge.
func (m *UserMutation) ResetFinalOffers() {
	m.final_offers = nil
	m.clearedfinal_offers = false
	m.removedfinal_offers = nil
}

// AddArtifactSubmissionIDs adds the "artifact_submissions" edge to the ArtifactSubmission entity by ids.
func (m *UserMutation) AddArtifactSubmissionIDs(ids ...int) {
	if m.artifact_submissions == nil {
		m.artifact_submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.artifact_submissions[ids[i]] = struct{}{}
	}
}

// ClearArtifactSubmissions clears the "artifact_submissions" edge to the ArtifactSubmission entity.
func (m *UserMutation) ClearArtifactSubmissions() {
	m.clearedartifact_submissions = true
}

// ArtifactSubmissionsCleared reports if the "artifact_submissions" edge to the ArtifactSubmission entity was cleared.
func (m *UserMutation) ArtifactSubmissionsCleared() bool {
	return m.clearedartifact_submissions
}

// RemoveArtifactSubmissionIDs removes the "artifact_submissions" edge to the ArtifactSubmission entity by IDs.
func (m *UserMutation) RemoveArtifactSubmissionIDs(ids ...int) {
	if m.removedartifact_submissions == nil {
		m.removedartifact_submissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifact_submissions, ids[i])
		m.removedartifact_submissions[ids[i]] = struct{}{}
	}
}

// RemovedArtifactSubmissions returns the removed IDs of the "artifact_submissions" edge to the ArtifactSubmission entity.
func (m *UserMutation) RemovedArtifactSubmissionsIDs() (ids []int) {
	for id := range m.removedartifact_submissions {
		ids = append(ids, id)
	}
	return
}

// ArtifactSubmissionsIDs returns the "artifact_submissions" edge IDs in the mutation.
func (m *UserMutation) ArtifactSubmissionsIDs() (ids []int) {
	for id := range m.artifact_submissions {
		ids = append(ids, id)
	}
	return
}

// ResetArtifactSubmissions resets all changes to the "artifact_submissions" edge.
func (m *UserMutation) ResetArtifactSubmissions() {
	m.artifact_submissions = nil
	m.clearedartifact_submissions = false
	m.removedartifact_submissions = nil
}

// AddEndorsementIDs adds the "endorsements" edge to the Endorsement entity by ids.
func (m *UserMutation) AddEndorsementIDs(ids ...int) {
	if m.endorsements == nil {
		m.endorsements = make(map[int]struct{})
	}
	for i := range ids {
		m.endorsements[ids[i]] = struct{}{}
	}
}

// ClearEndorsements clears the "endorsements" edge to the Endorsement entity.
func (m *UserMutation) ClearEndorsements() {
	m.clearedendorsements = true
}

// EndorsementsCleared reports if the "endorsements" edge to the Endorsement entity was cleared.
func (m *UserMutation) EndorsementsCleared() bool {
	return m.clearedendorsements
}

// RemoveEndorsementIDs removes the "endorsements" edge to the Endorsement entity by IDs.
func (m *UserMutation) RemoveEndorsementIDs(ids ...int) {
	if m.removedendorsements == nil {
		m.removedendorsements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.endorsements, ids[i])
		m.removedendorsements[ids[i]] = struct{}{}
	}
}

// RemovedEndorsements returns the removed IDs of the "endorsements" edge to the Endorsement entity.
func (m *UserMutation) RemovedEndorsementsIDs() (ids []int) {
	for id := range m.removedendorsements {
		ids = append(ids, id)
	}
	return
}

// EndorsementsIDs returns the "endorsements" edge IDs in the mutation.
func (m *UserMutation) EndorsementsIDs() (ids []int) {
	for id := range m.endorsements {
		ids = append(ids, id)
	}
	return
}

// ResetEndorsements resets all changes to the "endorsements" edge.
func (m *UserMutation) ResetEndorsements() {
	m.endorsements = nil
	m.clearedendorsements = false
	m.removedendorsements = nil
}

// ClearPrimaryBadge clears the "primary_badge" edge to the Badge entity.
func (m *UserMutation) ClearPrimaryBadge() {
	m.clearedprimary_badge = true
	m.clearedFields[user.FieldPrimaryBadgeID] = struct{}{}
}

// PrimaryBadgeCleared reports if the "primary_badge" edge to the Badge entity was cleared.
func (m *UserMutation) PrimaryBadgeCleared() bool {
	return m.PrimaryBadgeIDCleared() || m.clearedprimary_badge
}

// PrimaryBadgeIDs returns the "primary_badge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryBadgeID instead. It exists only for internal usage by the builders.
func (m *UserMutation) PrimaryBadgeIDs() (ids []int) {
	if id := m.primary_badge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryBadge resets all changes to the "primary_badge" edge.
func (m *UserMutation) ResetPrimaryBadge() {
	m.primary_badge = nil
	m.clearedprimary_badge = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.full_name != nil {
		fields = append(fields, user.FieldFullName)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.pronouns != nil {
		fields = append(fields, user.FieldPronouns)
	}
	if m.company != nil {
		fields = append(fields, user.FieldCompany)
	}
	if m.telegram != nil {
		fields = append(fields, user.FieldTelegram)
	}
	if m.social_accounts != nil {
		fields = append(fields, user.FieldSocialAccounts)
	}
	if m.primary_badge != nil {
		fields = append(fields, user.FieldPrimaryBadgeID)
	}
	if m.totp_secret != nil {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.totp_enabled != nil {
		fields = append(fields, user.FieldTotpEnabled)
	}
	if m.totp_verified != nil {
		fields = append(fields, user.FieldTotpVerified)
	}
	if m.totp_verified_at != nil {
		fields = append(fields, user.FieldTotpVerifiedAt)
	}
	if m.failed_login_attempts != nil {
		fields = append(fields, user.FieldFailedLoginAttempts)
	}
	if m.last_failed_at != nil {
		fields = append(fields, user.FieldLastFailedAt)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.last_login_ip != nil {
		fields = append(fields, user.FieldLastLoginIP)
	}
	if m.locked_until != nil {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.lock_reason != nil {
		fields = append(fields, user.FieldLockReason)
	}
	if m.guarantee_amount != nil {
		fields = append(fields, user.FieldGuaranteeAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldFullName:
		return m.FullName()
	case user.FieldBio:
		return m.Bio()
	case user.FieldPronouns:
		return m.Pronouns()
	case user.FieldCompany:
		return m.Company()
	case user.FieldTelegram:
		return m.Telegram()
	case user.FieldSocialAccounts:
		return m.SocialAccounts()
	case user.FieldPrimaryBadgeID:
		return m.PrimaryBadgeID()
	case user.FieldTotpSecret:
		return m.TotpSecret()
	case user.FieldTotpEnabled:
		return m.TotpEnabled()
	case user.FieldTotpVerified:
		return m.TotpVerified()
	case user.FieldTotpVerifiedAt:
		return m.TotpVerifiedAt()
	case user.FieldFailedLoginAttempts:
		return m.FailedLoginAttempts()
	case user.FieldLastFailedAt:
		return m.LastFailedAt()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldLastLoginIP:
		return m.LastLoginIP()
	case user.FieldLockedUntil:
		return m.LockedUntil()
	case user.FieldLockReason:
		return m.LockReason()
	case user.FieldGuaranteeAmount:
		return m.GuaranteeAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldFullName:
		return m.OldFullName(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldPronouns:
		return m.OldPronouns(ctx)
	case user.FieldCompany:
		return m.OldCompany(ctx)
	case user.FieldTelegram:
		return m.OldTelegram(ctx)
	case user.FieldSocialAccounts:
		return m.OldSocialAccounts(ctx)
	case user.FieldPrimaryBadgeID:
		return m.OldPrimaryBadgeID(ctx)
	case user.FieldTotpSecret:
		return m.OldTotpSecret(ctx)
	case user.FieldTotpEnabled:
		return m.OldTotpEnabled(ctx)
	case user.FieldTotpVerified:
		return m.OldTotpVerified(ctx)
	case user.FieldTotpVerifiedAt:
		return m.OldTotpVerifiedAt(ctx)
	case user.FieldFailedLoginAttempts:
		return m.OldFailedLoginAttempts(ctx)
	case user.FieldLastFailedAt:
		return m.OldLastFailedAt(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	case user.FieldLockedUntil:
		return m.OldLockedUntil(ctx)
	case user.FieldLockReason:
		return m.OldLockReason(ctx)
	case user.FieldGuaranteeAmount:
		return m.OldGuaranteeAmount(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldPronouns:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPronouns(v)
		return nil
	case user.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case user.FieldTelegram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelegram(v)
		return nil
	case user.FieldSocialAccounts:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialAccounts(v)
		return nil
	case user.FieldPrimaryBadgeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryBadgeID(v)
		return nil
	case user.FieldTotpSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpSecret(v)
		return nil
	case user.FieldTotpEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpEnabled(v)
		return nil
	case user.FieldTotpVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpVerified(v)
		return nil
	case user.FieldTotpVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpVerifiedAt(v)
		return nil
	case user.FieldFailedLoginAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedLoginAttempts(v)
		return nil
	case user.FieldLastFailedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastFailedAt(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	case user.FieldLockedUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedUntil(v)
		return nil
	case user.FieldLockReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockReason(v)
		return nil
	case user.FieldGuaranteeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuaranteeAmount(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addfailed_login_attempts != nil {
		fields = append(fields, user.FieldFailedLoginAttempts)
	}
	if m.addguarantee_amount != nil {
		fields = append(fields, user.FieldGuaranteeAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFailedLoginAttempts:
		return m.AddedFailedLoginAttempts()
	case user.FieldGuaranteeAmount:
		return m.AddedGuaranteeAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldFailedLoginAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailedLoginAttempts(v)
		return nil
	case user.FieldGuaranteeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGuaranteeAmount(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldFullName) {
		fields = append(fields, user.FieldFullName)
	}
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	if m.FieldCleared(user.FieldPronouns) {
		fields = append(fields, user.FieldPronouns)
	}
	if m.FieldCleared(user.FieldCompany) {
		fields = append(fields, user.FieldCompany)
	}
	if m.FieldCleared(user.FieldTelegram) {
		fields = append(fields, user.FieldTelegram)
	}
	if m.FieldCleared(user.FieldSocialAccounts) {
		fields = append(fields, user.FieldSocialAccounts)
	}
	if m.FieldCleared(user.FieldPrimaryBadgeID) {
		fields = append(fields, user.FieldPrimaryBadgeID)
	}
	if m.FieldCleared(user.FieldTotpSecret) {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.FieldCleared(user.FieldTotpVerifiedAt) {
		fields = append(fields, user.FieldTotpVerifiedAt)
	}
	if m.FieldCleared(user.FieldLastFailedAt) {
		fields = append(fields, user.FieldLastFailedAt)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.FieldCleared(user.FieldLastLoginIP) {
		fields = append(fields, user.FieldLastLoginIP)
	}
	if m.FieldCleared(user.FieldLockedUntil) {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.FieldCleared(user.FieldLockReason) {
		fields = append(fields, user.FieldLockReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldFullName:
		m.ClearFullName()
		return nil
	case user.FieldBio:
		m.ClearBio()
		return nil
	case user.FieldPronouns:
		m.ClearPronouns()
		return nil
	case user.FieldCompany:
		m.ClearCompany()
		return nil
	case user.FieldTelegram:
		m.ClearTelegram()
		return nil
	case user.FieldSocialAccounts:
		m.ClearSocialAccounts()
		return nil
	case user.FieldPrimaryBadgeID:
		m.ClearPrimaryBadgeID()
		return nil
	case user.FieldTotpSecret:
		m.ClearTotpSecret()
		return nil
	case user.FieldTotpVerifiedAt:
		m.ClearTotpVerifiedAt()
		return nil
	case user.FieldLastFailedAt:
		m.ClearLastFailedAt()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case user.FieldLastLoginIP:
		m.ClearLastLoginIP()
		return nil
	case user.FieldLockedUntil:
		m.ClearLockedUntil()
		return nil
	case user.FieldLockReason:
		m.ClearLockReason()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldFullName:
		m.ResetFullName()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldPronouns:
		m.ResetPronouns()
		return nil
	case user.FieldCompany:
		m.ResetCompany()
		return nil
	case user.FieldTelegram:
		m.ResetTelegram()
		return nil
	case user.FieldSocialAccounts:
		m.ResetSocialAccounts()
		return nil
	case user.FieldPrimaryBadgeID:
		m.ResetPrimaryBadgeID()
		return nil
	case user.FieldTotpSecret:
		m.ResetTotpSecret()
		return nil
	case user.FieldTotpEnabled:
		m.ResetTotpEnabled()
		return nil
	case user.FieldTotpVerified:
		m.ResetTotpVerified()
		return nil
	case user.FieldTotpVerifiedAt:
		m.ResetTotpVerifiedAt()
		return nil
	case user.FieldFailedLoginAttempts:
		m.ResetFailedLoginAttempts()
		return nil
	case user.FieldLastFailedAt:
		m.ResetLastFailedAt()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	case user.FieldLockedUntil:
		m.ResetLockedUntil()
		return nil
	case user.FieldLockReason:
		m.ResetLockReason()
		return nil
	case user.FieldGuaranteeAmount:
		m.ResetGuaranteeAmount()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 20)
	if m.passkeys != nil {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.backup_codes != nil {
		edges = append(edges, user.EdgeBackupCodes)
	}
	if m.validation_cases != nil {
		edges = append(edges, user.EdgeValidationCases)
	}
	if m.user_badges != nil {
		edges = append(edges, user.EdgeUserBadges)
	}
	if m.session_locks != nil {
		edges = append(edges, user.EdgeSessionLocks)
	}
	if m.email_verification_tokens != nil {
		edges = append(edges, user.EdgeEmailVerificationTokens)
	}
	if m.password_reset_tokens != nil {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.credentials != nil {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.totp_pending_tokens != nil {
		edges = append(edges, user.EdgeTotpPendingTokens)
	}
	if m.security_events != nil {
		edges = append(edges, user.EdgeSecurityEvents)
	}
	if m.device_fingerprints != nil {
		edges = append(edges, user.EdgeDeviceFingerprints)
	}
	if m.device_user_mappings != nil {
		edges = append(edges, user.EdgeDeviceUserMappings)
	}
	if m.sudo_sessions != nil {
		edges = append(edges, user.EdgeSudoSessions)
	}
	if m.validation_case_logs != nil {
		edges = append(edges, user.EdgeValidationCaseLogs)
	}
	if m.consultation_requests != nil {
		edges = append(edges, user.EdgeConsultationRequests)
	}
	if m.final_offers != nil {
		edges = append(edges, user.EdgeFinalOffers)
	}
	if m.artifact_submissions != nil {
		edges = append(edges, user.EdgeArtifactSubmissions)
	}
	if m.endorsements != nil {
		edges = append(edges, user.EdgeEndorsements)
	}
	if m.primary_badge != nil {
		edges = append(edges, user.EdgePrimaryBadge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePasskeys:
		ids := make([]ent.Value, 0, len(m.passkeys))
		for id := range m.passkeys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBackupCodes:
		ids := make([]ent.Value, 0, len(m.backup_codes))
		for id := range m.backup_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeValidationCases:
		ids := make([]ent.Value, 0, len(m.validation_cases))
		for id := range m.validation_cases {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserBadges:
		ids := make([]ent.Value, 0, len(m.user_badges))
		for id := range m.user_badges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessionLocks:
		ids := make([]ent.Value, 0, len(m.session_locks))
		for id := range m.session_locks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEmailVerificationTokens:
		ids := make([]ent.Value, 0, len(m.email_verification_tokens))
		for id := range m.email_verification_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetTokens:
		ids := make([]ent.Value, 0, len(m.password_reset_tokens))
		for id := range m.password_reset_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTotpPendingTokens:
		ids := make([]ent.Value, 0, len(m.totp_pending_tokens))
		for id := range m.totp_pending_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSecurityEvents:
		ids := make([]ent.Value, 0, len(m.security_events))
		for id := range m.security_events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceFingerprints:
		ids := make([]ent.Value, 0, len(m.device_fingerprints))
		for id := range m.device_fingerprints {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceUserMappings:
		ids := make([]ent.Value, 0, len(m.device_user_mappings))
		for id := range m.device_user_mappings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSudoSessions:
		ids := make([]ent.Value, 0, len(m.sudo_sessions))
		for id := range m.sudo_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeValidationCaseLogs:
		ids := make([]ent.Value, 0, len(m.validation_case_logs))
		for id := range m.validation_case_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConsultationRequests:
		ids := make([]ent.Value, 0, len(m.consultation_requests))
		for id := range m.consultation_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFinalOffers:
		ids := make([]ent.Value, 0, len(m.final_offers))
		for id := range m.final_offers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeArtifactSubmissions:
		ids := make([]ent.Value, 0, len(m.artifact_submissions))
		for id := range m.artifact_submissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEndorsements:
		ids := make([]ent.Value, 0, len(m.endorsements))
		for id := range m.endorsements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePrimaryBadge:
		if id := m.primary_badge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 20)
	if m.removedpasskeys != nil {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedbackup_codes != nil {
		edges = append(edges, user.EdgeBackupCodes)
	}
	if m.removedvalidation_cases != nil {
		edges = append(edges, user.EdgeValidationCases)
	}
	if m.removeduser_badges != nil {
		edges = append(edges, user.EdgeUserBadges)
	}
	if m.removedsession_locks != nil {
		edges = append(edges, user.EdgeSessionLocks)
	}
	if m.removedemail_verification_tokens != nil {
		edges = append(edges, user.EdgeEmailVerificationTokens)
	}
	if m.removedpassword_reset_tokens != nil {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.removedcredentials != nil {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.removedtotp_pending_tokens != nil {
		edges = append(edges, user.EdgeTotpPendingTokens)
	}
	if m.removedsecurity_events != nil {
		edges = append(edges, user.EdgeSecurityEvents)
	}
	if m.removeddevice_fingerprints != nil {
		edges = append(edges, user.EdgeDeviceFingerprints)
	}
	if m.removeddevice_user_mappings != nil {
		edges = append(edges, user.EdgeDeviceUserMappings)
	}
	if m.removedsudo_sessions != nil {
		edges = append(edges, user.EdgeSudoSessions)
	}
	if m.removedvalidation_case_logs != nil {
		edges = append(edges, user.EdgeValidationCaseLogs)
	}
	if m.removedconsultation_requests != nil {
		edges = append(edges, user.EdgeConsultationRequests)
	}
	if m.removedfinal_offers != nil {
		edges = append(edges, user.EdgeFinalOffers)
	}
	if m.removedartifact_submissions != nil {
		edges = append(edges, user.EdgeArtifactSubmissions)
	}
	if m.removedendorsements != nil {
		edges = append(edges, user.EdgeEndorsements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePasskeys:
		ids := make([]ent.Value, 0, len(m.removedpasskeys))
		for id := range m.removedpasskeys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBackupCodes:
		ids := make([]ent.Value, 0, len(m.removedbackup_codes))
		for id := range m.removedbackup_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeValidationCases:
		ids := make([]ent.Value, 0, len(m.removedvalidation_cases))
		for id := range m.removedvalidation_cases {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserBadges:
		ids := make([]ent.Value, 0, len(m.removeduser_badges))
		for id := range m.removeduser_badges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessionLocks:
		ids := make([]ent.Value, 0, len(m.removedsession_locks))
		for id := range m.removedsession_locks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEmailVerificationTokens:
		ids := make([]ent.Value, 0, len(m.removedemail_verification_tokens))
		for id := range m.removedemail_verification_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetTokens:
		ids := make([]ent.Value, 0, len(m.removedpassword_reset_tokens))
		for id := range m.removedpassword_reset_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTotpPendingTokens:
		ids := make([]ent.Value, 0, len(m.removedtotp_pending_tokens))
		for id := range m.removedtotp_pending_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSecurityEvents:
		ids := make([]ent.Value, 0, len(m.removedsecurity_events))
		for id := range m.removedsecurity_events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceFingerprints:
		ids := make([]ent.Value, 0, len(m.removeddevice_fingerprints))
		for id := range m.removeddevice_fingerprints {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceUserMappings:
		ids := make([]ent.Value, 0, len(m.removeddevice_user_mappings))
		for id := range m.removeddevice_user_mappings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSudoSessions:
		ids := make([]ent.Value, 0, len(m.removedsudo_sessions))
		for id := range m.removedsudo_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeValidationCaseLogs:
		ids := make([]ent.Value, 0, len(m.removedvalidation_case_logs))
		for id := range m.removedvalidation_case_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConsultationRequests:
		ids := make([]ent.Value, 0, len(m.removedconsultation_requests))
		for id := range m.removedconsultation_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFinalOffers:
		ids := make([]ent.Value, 0, len(m.removedfinal_offers))
		for id := range m.removedfinal_offers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeArtifactSubmissions:
		ids := make([]ent.Value, 0, len(m.removedartifact_submissions))
		for id := range m.removedartifact_submissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEndorsements:
		ids := make([]ent.Value, 0, len(m.removedendorsements))
		for id := range m.removedendorsements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 20)
	if m.clearedpasskeys {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedbackup_codes {
		edges = append(edges, user.EdgeBackupCodes)
	}
	if m.clearedvalidation_cases {
		edges = append(edges, user.EdgeValidationCases)
	}
	if m.cleareduser_badges {
		edges = append(edges, user.EdgeUserBadges)
	}
	if m.clearedsession_locks {
		edges = append(edges, user.EdgeSessionLocks)
	}
	if m.clearedemail_verification_tokens {
		edges = append(edges, user.EdgeEmailVerificationTokens)
	}
	if m.clearedpassword_reset_tokens {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.clearedcredentials {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.clearedtotp_pending_tokens {
		edges = append(edges, user.EdgeTotpPendingTokens)
	}
	if m.clearedsecurity_events {
		edges = append(edges, user.EdgeSecurityEvents)
	}
	if m.cleareddevice_fingerprints {
		edges = append(edges, user.EdgeDeviceFingerprints)
	}
	if m.cleareddevice_user_mappings {
		edges = append(edges, user.EdgeDeviceUserMappings)
	}
	if m.clearedsudo_sessions {
		edges = append(edges, user.EdgeSudoSessions)
	}
	if m.clearedvalidation_case_logs {
		edges = append(edges, user.EdgeValidationCaseLogs)
	}
	if m.clearedconsultation_requests {
		edges = append(edges, user.EdgeConsultationRequests)
	}
	if m.clearedfinal_offers {
		edges = append(edges, user.EdgeFinalOffers)
	}
	if m.clearedartifact_submissions {
		edges = append(edges, user.EdgeArtifactSubmissions)
	}
	if m.clearedendorsements {
		edges = append(edges, user.EdgeEndorsements)
	}
	if m.clearedprimary_badge {
		edges = append(edges, user.EdgePrimaryBadge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePasskeys:
		return m.clearedpasskeys
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeBackupCodes:
		return m.clearedbackup_codes
	case user.EdgeValidationCases:
		return m.clearedvalidation_cases
	case user.EdgeUserBadges:
		return m.cleareduser_badges
	case user.EdgeSessionLocks:
		return m.clearedsession_locks
	case user.EdgeEmailVerificationTokens:
		return m.clearedemail_verification_tokens
	case user.EdgePasswordResetTokens:
		return m.clearedpassword_reset_tokens
	case user.EdgeCredentials:
		return m.clearedcredentials
	case user.EdgeTotpPendingTokens:
		return m.clearedtotp_pending_tokens
	case user.EdgeSecurityEvents:
		return m.clearedsecurity_events
	case user.EdgeDeviceFingerprints:
		return m.cleareddevice_fingerprints
	case user.EdgeDeviceUserMappings:
		return m.cleareddevice_user_mappings
	case user.EdgeSudoSessions:
		return m.clearedsudo_sessions
	case user.EdgeValidationCaseLogs:
		return m.clearedvalidation_case_logs
	case user.EdgeConsultationRequests:
		return m.clearedconsultation_requests
	case user.EdgeFinalOffers:
		return m.clearedfinal_offers
	case user.EdgeArtifactSubmissions:
		return m.clearedartifact_submissions
	case user.EdgeEndorsements:
		return m.clearedendorsements
	case user.EdgePrimaryBadge:
		return m.clearedprimary_badge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgePrimaryBadge:
		m.ClearPrimaryBadge()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePasskeys:
		m.ResetPasskeys()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeBackupCodes:
		m.ResetBackupCodes()
		return nil
	case user.EdgeValidationCases:
		m.ResetValidationCases()
		return nil
	case user.EdgeUserBadges:
		m.ResetUserBadges()
		return nil
	case user.EdgeSessionLocks:
		m.ResetSessionLocks()
		return nil
	case user.EdgeEmailVerificationTokens:
		m.ResetEmailVerificationTokens()
		return nil
	case user.EdgePasswordResetTokens:
		m.ResetPasswordResetTokens()
		return nil
	case user.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case user.EdgeTotpPendingTokens:
		m.ResetTotpPendingTokens()
		return nil
	case user.EdgeSecurityEvents:
		m.ResetSecurityEvents()
		return nil
	case user.EdgeDeviceFingerprints:
		m.ResetDeviceFingerprints()
		return nil
	case user.EdgeDeviceUserMappings:
		m.ResetDeviceUserMappings()
		return nil
	case user.EdgeSudoSessions:
		m.ResetSudoSessions()
		return nil
	case user.EdgeValidationCaseLogs:
		m.ResetValidationCaseLogs()
		return nil
	case user.EdgeConsultationRequests:
		m.ResetConsultationRequests()
		return nil
	case user.EdgeFinalOffers:
		m.ResetFinalOffers()
		return nil
	case user.EdgeArtifactSubmissions:
		m.ResetArtifactSubmissions()
		return nil
	case user.EdgeEndorsements:
		m.ResetEndorsements()
		return nil
	case user.EdgePrimaryBadge:
		m.ResetPrimaryBadge()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserBadgeMutation represents an operation that mutates the UserBadge nodes in the graph.
type UserBadgeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	reason        *string
	granted_at    *time.Time
	revoked_at    *time.Time
	revoke_reason *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	badge         *int
	clearedbadge  bool
	admin         *int
	clearedadmin  bool
	done          bool
	oldValue      func(context.Context) (*UserBadge, error)
	predicates    []predicate.UserBadge
}

var _ ent.Mutation = (*UserBadgeMutation)(nil)

// userbadgeOption allows management of the mutation configuration using functional options.
type userbadgeOption func(*UserBadgeMutation)

// newUserBadgeMutation creates new mutation for the UserBadge entity.
func newUserBadgeMutation(c config, op Op, opts ...userbadgeOption) *UserBadgeMutation {
	m := &UserBadgeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBadge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserBadgeID sets the ID field of the mutation.
func withUserBadgeID(id int) userbadgeOption {
	return func(m *UserBadgeMutation) {
		var (
			err   error
			once  sync.Once
			value *UserBadge
		)
		m.oldValue = func(ctx context.Context) (*UserBadge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserBadge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserBadge sets the old UserBadge of the mutation.
func withUserBadge(node *UserBadge) userbadgeOption {
	return func(m *UserBadgeMutation) {
		m.oldValue = func(context.Context) (*UserBadge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBadgeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBadgeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserBadgeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserBadgeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserBadge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserBadgeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserBadgeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserBadgeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserBadgeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserBadgeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserBadgeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserBadgeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserBadgeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserBadgeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userbadge.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserBadgeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userbadge.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserBadgeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userbadge.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserBadgeMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserBadgeMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserBadgeMutation) ResetUserID() {
	m.user = nil
}

// SetBadgeID sets the "badge_id" field.
func (m *UserBadgeMutation) SetBadgeID(i int) {
	m.badge = &i
}

// BadgeID returns the value of the "badge_id" field in the mutation.
func (m *UserBadgeMutation) BadgeID() (r int, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadgeID returns the old "badge_id" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldBadgeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadgeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadgeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadgeID: %w", err)
	}
	return oldValue.BadgeID, nil
}

// ResetBadgeID resets all changes to the "badge_id" field.
func (m *UserBadgeMutation) ResetBadgeID() {
	m.badge = nil
}

// SetReason sets the "reason" field.
func (m *UserBadgeMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *UserBadgeMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *UserBadgeMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[userbadge.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *UserBadgeMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[userbadge.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *UserBadgeMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, userbadge.FieldReason)
}

// SetGrantedBy sets the "granted_by" field.
func (m *UserBadgeMutation) SetGrantedBy(i int) {
	m.admin = &i
}

// GrantedBy returns the value of the "granted_by" field in the mutation.
func (m *UserBadgeMutation) GrantedBy() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedBy returns the old "granted_by" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldGrantedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedBy: %w", err)
	}
	return oldValue.GrantedBy, nil
}

// ResetGrantedBy resets all changes to the "granted_by" field.
func (m *UserBadgeMutation) ResetGrantedBy() {
	m.admin = nil
}

// SetGrantedAt sets the "granted_at" field.
func (m *UserBadgeMutation) SetGrantedAt(t time.Time) {
	m.granted_at = &t
}

// GrantedAt returns the value of the "granted_at" field in the mutation.
func (m *UserBadgeMutation) GrantedAt() (r time.Time, exists bool) {
	v := m.granted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedAt returns the old "granted_at" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldGrantedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedAt: %w", err)
	}
	return oldValue.GrantedAt, nil
}

// ResetGrantedAt resets all changes to the "granted_at" field.
func (m *UserBadgeMutation) ResetGrantedAt() {
	m.granted_at = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *UserBadgeMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *UserBadgeMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *UserBadgeMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[userbadge.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *UserBadgeMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[userbadge.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *UserBadgeMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, userbadge.FieldRevokedAt)
}

// SetRevokeReason sets the "revoke_reason" field.
func (m *UserBadgeMutation) SetRevokeReason(s string) {
	m.revoke_reason = &s
}

// RevokeReason returns the value of the "revoke_reason" field in the mutation.
func (m *UserBadgeMutation) RevokeReason() (r string, exists bool) {
	v := m.revoke_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokeReason returns the old "revoke_reason" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldRevokeReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokeReason: %w", err)
	}
	return oldValue.RevokeReason, nil
}

// ClearRevokeReason clears the value of the "revoke_reason" field.
func (m *UserBadgeMutation) ClearRevokeReason() {
	m.revoke_reason = nil
	m.clearedFields[userbadge.FieldRevokeReason] = struct{}{}
}

// RevokeReasonCleared returns if the "revoke_reason" field was cleared in this mutation.
func (m *UserBadgeMutation) RevokeReasonCleared() bool {
	_, ok := m.clearedFields[userbadge.FieldRevokeReason]
	return ok
}

// ResetRevokeReason resets all changes to the "revoke_reason" field.
func (m *UserBadgeMutation) ResetRevokeReason() {
	m.revoke_reason = nil
	delete(m.clearedFields, userbadge.FieldRevokeReason)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserBadgeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userbadge.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserBadgeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserBadgeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserBadgeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearBadge clears the "badge" edge to the Badge entity.
func (m *UserBadgeMutation) ClearBadge() {
	m.clearedbadge = true
	m.clearedFields[userbadge.FieldBadgeID] = struct{}{}
}

// BadgeCleared reports if the "badge" edge to the Badge entity was cleared.
func (m *UserBadgeMutation) BadgeCleared() bool {
	return m.clearedbadge
}

// BadgeIDs returns the "badge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BadgeID instead. It exists only for internal usage by the builders.
func (m *UserBadgeMutation) BadgeIDs() (ids []int) {
	if id := m.badge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBadge resets all changes to the "badge" edge.
func (m *UserBadgeMutation) ResetBadge() {
	m.badge = nil
	m.clearedbadge = false
}

// SetAdminID sets the "admin" edge to the Admin entity by id.
func (m *UserBadgeMutation) SetAdminID(id int) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *UserBadgeMutation) ClearAdmin() {
	m.clearedadmin = true
	m.clearedFields[userbadge.FieldGrantedBy] = struct{}{}
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *UserBadgeMutation) AdminCleared() bool {
	return m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *UserBadgeMutation) AdminID() (id int, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *UserBadgeMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *UserBadgeMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// Where appends a list predicates to the UserBadgeMutation builder.
func (m *UserBadgeMutation) Where(ps ...predicate.UserBadge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBadgeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBadgeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBadge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBadgeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBadgeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBadge).
func (m *UserBadgeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBadgeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, userbadge.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userbadge.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userbadge.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userbadge.FieldUserID)
	}
	if m.badge != nil {
		fields = append(fields, userbadge.FieldBadgeID)
	}
	if m.reason != nil {
		fields = append(fields, userbadge.FieldReason)
	}
	if m.admin != nil {
		fields = append(fields, userbadge.FieldGrantedBy)
	}
	if m.granted_at != nil {
		fields = append(fields, userbadge.FieldGrantedAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, userbadge.FieldRevokedAt)
	}
	if m.revoke_reason != nil {
		fields = append(fields, userbadge.FieldRevokeReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBadgeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userbadge.FieldCreatedAt:
		return m.CreatedAt()
	case userbadge.FieldUpdatedAt:
		return m.UpdatedAt()
	case userbadge.FieldDeletedAt:
		return m.DeletedAt()
	case userbadge.FieldUserID:
		return m.UserID()
	case userbadge.FieldBadgeID:
		return m.BadgeID()
	case userbadge.FieldReason:
		return m.Reason()
	case userbadge.FieldGrantedBy:
		return m.GrantedBy()
	case userbadge.FieldGrantedAt:
		return m.GrantedAt()
	case userbadge.FieldRevokedAt:
		return m.RevokedAt()
	case userbadge.FieldRevokeReason:
		return m.RevokeReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBadgeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userbadge.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userbadge.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userbadge.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userbadge.FieldUserID:
		return m.OldUserID(ctx)
	case userbadge.FieldBadgeID:
		return m.OldBadgeID(ctx)
	case userbadge.FieldReason:
		return m.OldReason(ctx)
	case userbadge.FieldGrantedBy:
		return m.OldGrantedBy(ctx)
	case userbadge.FieldGrantedAt:
		return m.OldGrantedAt(ctx)
	case userbadge.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case userbadge.FieldRevokeReason:
		return m.OldRevokeReason(ctx)
	}
	return nil, fmt.Errorf("unknown UserBadge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBadgeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userbadge.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userbadge.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userbadge.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userbadge.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userbadge.FieldBadgeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadgeID(v)
		return nil
	case userbadge.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case userbadge.FieldGrantedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedBy(v)
		return nil
	case userbadge.FieldGrantedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedAt(v)
		return nil
	case userbadge.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case userbadge.FieldRevokeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokeReason(v)
		return nil
	}
	return fmt.Errorf("unknown UserBadge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBadgeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBadgeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBadgeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserBadge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBadgeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userbadge.FieldDeletedAt) {
		fields = append(fields, userbadge.FieldDeletedAt)
	}
	if m.FieldCleared(userbadge.FieldReason) {
		fields = append(fields, userbadge.FieldReason)
	}
	if m.FieldCleared(userbadge.FieldRevokedAt) {
		fields = append(fields, userbadge.FieldRevokedAt)
	}
	if m.FieldCleared(userbadge.FieldRevokeReason) {
		fields = append(fields, userbadge.FieldRevokeReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBadgeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBadgeMutation) ClearField(name string) error {
	switch name {
	case userbadge.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userbadge.FieldReason:
		m.ClearReason()
		return nil
	case userbadge.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case userbadge.FieldRevokeReason:
		m.ClearRevokeReason()
		return nil
	}
	return fmt.Errorf("unknown UserBadge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBadgeMutation) ResetField(name string) error {
	switch name {
	case userbadge.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userbadge.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userbadge.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userbadge.FieldUserID:
		m.ResetUserID()
		return nil
	case userbadge.FieldBadgeID:
		m.ResetBadgeID()
		return nil
	case userbadge.FieldReason:
		m.ResetReason()
		return nil
	case userbadge.FieldGrantedBy:
		m.ResetGrantedBy()
		return nil
	case userbadge.FieldGrantedAt:
		m.ResetGrantedAt()
		return nil
	case userbadge.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case userbadge.FieldRevokeReason:
		m.ResetRevokeReason()
		return nil
	}
	return fmt.Errorf("unknown UserBadge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBadgeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, userbadge.EdgeUser)
	}
	if m.badge != nil {
		edges = append(edges, userbadge.EdgeBadge)
	}
	if m.admin != nil {
		edges = append(edges, userbadge.EdgeAdmin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBadgeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userbadge.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userbadge.EdgeBadge:
		if id := m.badge; id != nil {
			return []ent.Value{*id}
		}
	case userbadge.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBadgeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBadgeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBadgeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, userbadge.EdgeUser)
	}
	if m.clearedbadge {
		edges = append(edges, userbadge.EdgeBadge)
	}
	if m.clearedadmin {
		edges = append(edges, userbadge.EdgeAdmin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBadgeMutation) EdgeCleared(name string) bool {
	switch name {
	case userbadge.EdgeUser:
		return m.cleareduser
	case userbadge.EdgeBadge:
		return m.clearedbadge
	case userbadge.EdgeAdmin:
		return m.clearedadmin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBadgeMutation) ClearEdge(name string) error {
	switch name {
	case userbadge.EdgeUser:
		m.ClearUser()
		return nil
	case userbadge.EdgeBadge:
		m.ClearBadge()
		return nil
	case userbadge.EdgeAdmin:
		m.ClearAdmin()
		return nil
	}
	return fmt.Errorf("unknown UserBadge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBadgeMutation) ResetEdge(name string) error {
	switch name {
	case userbadge.EdgeUser:
		m.ResetUser()
		return nil
	case userbadge.EdgeBadge:
		m.ResetBadge()
		return nil
	case userbadge.EdgeAdmin:
		m.ResetAdmin()
		return nil
	}
	return fmt.Errorf("unknown UserBadge edge %s", name)
}

// ValidationCaseMutation represents an operation that mutates the ValidationCase nodes in the graph.
type ValidationCaseMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	title                          *string
	summary                        *string
	content_type                   *string
	content_json                   *map[string]interface{}
	meta                           *map[string]interface{}
	bounty_amount                  *int64
	addbounty_amount               *int64
	status                         *string
	sensitivity_level              *string
	intake_schema_version          *string
	clarification_state            *string
	owner_inactivity_count         *int
	addowner_inactivity_count      *int
	workflow_cycle                 *int
	addworkflow_cycle              *int
	escrow_transfer_id             *string
	dispute_id                     *string
	accepted_final_offer_id        *int
	addaccepted_final_offer_id     *int
	artifact_document_id           *string
	certified_artifact_document_id *string
	clearedFields                  map[string]struct{}
	user                           *int
	cleareduser                    bool
	category                       *int
	clearedcategory                bool
	tags                           map[int]struct{}
	removedtags                    map[int]struct{}
	clearedtags                    bool
	case_logs                      map[int]struct{}
	removedcase_logs               map[int]struct{}
	clearedcase_logs               bool
	consultation_requests          map[int]struct{}
	removedconsultation_requests   map[int]struct{}
	clearedconsultation_requests   bool
	final_offers                   map[int]struct{}
	removedfinal_offers            map[int]struct{}
	clearedfinal_offers            bool
	artifact_submissions           map[int]struct{}
	removedartifact_submissions    map[int]struct{}
	clearedartifact_submissions    bool
	endorsements                   map[int]struct{}
	removedendorsements            map[int]struct{}
	clearedendorsements            bool
	done                           bool
	oldValue                       func(context.Context) (*ValidationCase, error)
	predicates                     []predicate.ValidationCase
}

var _ ent.Mutation = (*ValidationCaseMutation)(nil)

// validationcaseOption allows management of the mutation configuration using functional options.
type validationcaseOption func(*ValidationCaseMutation)

// newValidationCaseMutation creates new mutation for the ValidationCase entity.
func newValidationCaseMutation(c config, op Op, opts ...validationcaseOption) *ValidationCaseMutation {
	m := &ValidationCaseMutation{
		config:        c,
		op:            op,
		typ:           TypeValidationCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withValidationCaseID sets the ID field of the mutation.
func withValidationCaseID(id int) validationcaseOption {
	return func(m *ValidationCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *ValidationCase
		)
		m.oldValue = func(ctx context.Context) (*ValidationCase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ValidationCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withValidationCase sets the old ValidationCase of the mutation.
func withValidationCase(node *ValidationCase) validationcaseOption {
	return func(m *ValidationCaseMutation) {
		m.oldValue = func(context.Context) (*ValidationCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ValidationCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ValidationCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ValidationCaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ValidationCaseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ValidationCase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ValidationCaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ValidationCaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ValidationCaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ValidationCaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ValidationCaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ValidationCaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ValidationCaseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ValidationCaseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ValidationCaseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[validationcase.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ValidationCaseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[validationcase.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ValidationCaseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, validationcase.FieldDeletedAt)
}

// SetCategoryID sets the "category_id" field.
func (m *ValidationCaseMutation) SetCategoryID(i int) {
	m.category = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *ValidationCaseMutation) CategoryID() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *ValidationCaseMutation) ResetCategoryID() {
	m.category = nil
}

// SetUserID sets the "user_id" field.
func (m *ValidationCaseMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ValidationCaseMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ValidationCaseMutation) ResetUserID() {
	m.user = nil
}

// SetTitle sets the "title" field.
func (m *ValidationCaseMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ValidationCaseMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ValidationCaseMutation) ResetTitle() {
	m.title = nil
}

// SetSummary sets the "summary" field.
func (m *ValidationCaseMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *ValidationCaseMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *ValidationCaseMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[validationcase.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *ValidationCaseMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[validationcase.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *ValidationCaseMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, validationcase.FieldSummary)
}

// SetContentType sets the "content_type" field.
func (m *ValidationCaseMutation) SetContentType(s string) {
	m.content_type = &s
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *ValidationCaseMutation) ContentType() (r string, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ResetContentType resets all changes to the "content_type" field.
func (m *ValidationCaseMutation) ResetContentType() {
	m.content_type = nil
}

// SetContentJSON sets the "content_json" field.
func (m *ValidationCaseMutation) SetContentJSON(value map[string]interface{}) {
	m.content_json = &value
}

// ContentJSON returns the value of the "content_json" field in the mutation.
func (m *ValidationCaseMutation) ContentJSON() (r map[string]interface{}, exists bool) {
	v := m.content_json
	if v == nil {
		return
	}
	return *v, true
}

// OldContentJSON returns the old "content_json" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldContentJSON(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentJSON: %w", err)
	}
	return oldValue.ContentJSON, nil
}

// ClearContentJSON clears the value of the "content_json" field.
func (m *ValidationCaseMutation) ClearContentJSON() {
	m.content_json = nil
	m.clearedFields[validationcase.FieldContentJSON] = struct{}{}
}

// ContentJSONCleared returns if the "content_json" field was cleared in this mutation.
func (m *ValidationCaseMutation) ContentJSONCleared() bool {
	_, ok := m.clearedFields[validationcase.FieldContentJSON]
	return ok
}

// ResetContentJSON resets all changes to the "content_json" field.
func (m *ValidationCaseMutation) ResetContentJSON() {
	m.content_json = nil
	delete(m.clearedFields, validationcase.FieldContentJSON)
}

// SetMeta sets the "meta" field.
func (m *ValidationCaseMutation) SetMeta(value map[string]interface{}) {
	m.meta = &value
}

// Meta returns the value of the "meta" field in the mutation.
func (m *ValidationCaseMutation) Meta() (r map[string]interface{}, exists bool) {
	v := m.meta
	if v == nil {
		return
	}
	return *v, true
}

// OldMeta returns the old "meta" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldMeta(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeta: %w", err)
	}
	return oldValue.Meta, nil
}

// ClearMeta clears the value of the "meta" field.
func (m *ValidationCaseMutation) ClearMeta() {
	m.meta = nil
	m.clearedFields[validationcase.FieldMeta] = struct{}{}
}

// MetaCleared returns if the "meta" field was cleared in this mutation.
func (m *ValidationCaseMutation) MetaCleared() bool {
	_, ok := m.clearedFields[validationcase.FieldMeta]
	return ok
}

// ResetMeta resets all changes to the "meta" field.
func (m *ValidationCaseMutation) ResetMeta() {
	m.meta = nil
	delete(m.clearedFields, validationcase.FieldMeta)
}

// SetBountyAmount sets the "bounty_amount" field.
func (m *ValidationCaseMutation) SetBountyAmount(i int64) {
	m.bounty_amount = &i
	m.addbounty_amount = nil
}

// BountyAmount returns the value of the "bounty_amount" field in the mutation.
func (m *ValidationCaseMutation) BountyAmount() (r int64, exists bool) {
	v := m.bounty_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldBountyAmount returns the old "bounty_amount" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldBountyAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBountyAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBountyAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBountyAmount: %w", err)
	}
	return oldValue.BountyAmount, nil
}

// AddBountyAmount adds i to the "bounty_amount" field.
func (m *ValidationCaseMutation) AddBountyAmount(i int64) {
	if m.addbounty_amount != nil {
		*m.addbounty_amount += i
	} else {
		m.addbounty_amount = &i
	}
}

// AddedBountyAmount returns the value that was added to the "bounty_amount" field in this mutation.
func (m *ValidationCaseMutation) AddedBountyAmount() (r int64, exists bool) {
	v := m.addbounty_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetBountyAmount resets all changes to the "bounty_amount" field.
func (m *ValidationCaseMutation) ResetBountyAmount() {
	m.bounty_amount = nil
	m.addbounty_amount = nil
}

// SetStatus sets the "status" field.
func (m *ValidationCaseMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ValidationCaseMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ValidationCaseMutation) ResetStatus() {
	m.status = nil
}

// SetSensitivityLevel sets the "sensitivity_level" field.
func (m *ValidationCaseMutation) SetSensitivityLevel(s string) {
	m.sensitivity_level = &s
}

// SensitivityLevel returns the value of the "sensitivity_level" field in the mutation.
func (m *ValidationCaseMutation) SensitivityLevel() (r string, exists bool) {
	v := m.sensitivity_level
	if v == nil {
		return
	}
	return *v, true
}

// OldSensitivityLevel returns the old "sensitivity_level" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldSensitivityLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSensitivityLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSensitivityLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSensitivityLevel: %w", err)
	}
	return oldValue.SensitivityLevel, nil
}

// ResetSensitivityLevel resets all changes to the "sensitivity_level" field.
func (m *ValidationCaseMutation) ResetSensitivityLevel() {
	m.sensitivity_level = nil
}

// SetIntakeSchemaVersion sets the "intake_schema_version" field.
func (m *ValidationCaseMutation) SetIntakeSchemaVersion(s string) {
	m.intake_schema_version = &s
}

// IntakeSchemaVersion returns the value of the "intake_schema_version" field in the mutation.
func (m *ValidationCaseMutation) IntakeSchemaVersion() (r string, exists bool) {
	v := m.intake_schema_version
	if v == nil {
		return
	}
	return *v, true
}

// OldIntakeSchemaVersion returns the old "intake_schema_version" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldIntakeSchemaVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntakeSchemaVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntakeSchemaVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntakeSchemaVersion: %w", err)
	}
	return oldValue.IntakeSchemaVersion, nil
}

// ResetIntakeSchemaVersion resets all changes to the "intake_schema_version" field.
func (m *ValidationCaseMutation) ResetIntakeSchemaVersion() {
	m.intake_schema_version = nil
}

// SetClarificationState sets the "clarification_state" field.
func (m *ValidationCaseMutation) SetClarificationState(s string) {
	m.clarification_state = &s
}

// ClarificationState returns the value of the "clarification_state" field in the mutation.
func (m *ValidationCaseMutation) ClarificationState() (r string, exists bool) {
	v := m.clarification_state
	if v == nil {
		return
	}
	return *v, true
}

// OldClarificationState returns the old "clarification_state" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldClarificationState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClarificationState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClarificationState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClarificationState: %w", err)
	}
	return oldValue.ClarificationState, nil
}

// ResetClarificationState resets all changes to the "clarification_state" field.
func (m *ValidationCaseMutation) ResetClarificationState() {
	m.clarification_state = nil
}

// SetOwnerInactivityCount sets the "owner_inactivity_count" field.
func (m *ValidationCaseMutation) SetOwnerInactivityCount(i int) {
	m.owner_inactivity_count = &i
	m.addowner_inactivity_count = nil
}

// OwnerInactivityCount returns the value of the "owner_inactivity_count" field in the mutation.
func (m *ValidationCaseMutation) OwnerInactivityCount() (r int, exists bool) {
	v := m.owner_inactivity_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerInactivityCount returns the old "owner_inactivity_count" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldOwnerInactivityCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerInactivityCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerInactivityCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerInactivityCount: %w", err)
	}
	return oldValue.OwnerInactivityCount, nil
}

// AddOwnerInactivityCount adds i to the "owner_inactivity_count" field.
func (m *ValidationCaseMutation) AddOwnerInactivityCount(i int) {
	if m.addowner_inactivity_count != nil {
		*m.addowner_inactivity_count += i
	} else {
		m.addowner_inactivity_count = &i
	}
}

// AddedOwnerInactivityCount returns the value that was added to the "owner_inactivity_count" field in this mutation.
func (m *ValidationCaseMutation) AddedOwnerInactivityCount() (r int, exists bool) {
	v := m.addowner_inactivity_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwnerInactivityCount resets all changes to the "owner_inactivity_count" field.
func (m *ValidationCaseMutation) ResetOwnerInactivityCount() {
	m.owner_inactivity_count = nil
	m.addowner_inactivity_count = nil
}

// SetWorkflowCycle sets the "workflow_cycle" field.
func (m *ValidationCaseMutation) SetWorkflowCycle(i int) {
	m.workflow_cycle = &i
	m.addworkflow_cycle = nil
}

// WorkflowCycle returns the value of the "workflow_cycle" field in the mutation.
func (m *ValidationCaseMutation) WorkflowCycle() (r int, exists bool) {
	v := m.workflow_cycle
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowCycle returns the old "workflow_cycle" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldWorkflowCycle(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowCycle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowCycle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowCycle: %w", err)
	}
	return oldValue.WorkflowCycle, nil
}

// AddWorkflowCycle adds i to the "workflow_cycle" field.
func (m *ValidationCaseMutation) AddWorkflowCycle(i int) {
	if m.addworkflow_cycle != nil {
		*m.addworkflow_cycle += i
	} else {
		m.addworkflow_cycle = &i
	}
}

// AddedWorkflowCycle returns the value that was added to the "workflow_cycle" field in this mutation.
func (m *ValidationCaseMutation) AddedWorkflowCycle() (r int, exists bool) {
	v := m.addworkflow_cycle
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorkflowCycle resets all changes to the "workflow_cycle" field.
func (m *ValidationCaseMutation) ResetWorkflowCycle() {
	m.workflow_cycle = nil
	m.addworkflow_cycle = nil
}

// SetEscrowTransferID sets the "escrow_transfer_id" field.
func (m *ValidationCaseMutation) SetEscrowTransferID(s string) {
	m.escrow_transfer_id = &s
}

// EscrowTransferID returns the value of the "escrow_transfer_id" field in the mutation.
func (m *ValidationCaseMutation) EscrowTransferID() (r string, exists bool) {
	v := m.escrow_transfer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEscrowTransferID returns the old "escrow_transfer_id" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldEscrowTransferID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEscrowTransferID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEscrowTransferID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEscrowTransferID: %w", err)
	}
	return oldValue.EscrowTransferID, nil
}

// ClearEscrowTransferID clears the value of the "escrow_transfer_id" field.
func (m *ValidationCaseMutation) ClearEscrowTransferID() {
	m.escrow_transfer_id = nil
	m.clearedFields[validationcase.FieldEscrowTransferID] = struct{}{}
}

// EscrowTransferIDCleared returns if the "escrow_transfer_id" field was cleared in this mutation.
func (m *ValidationCaseMutation) EscrowTransferIDCleared() bool {
	_, ok := m.clearedFields[validationcase.FieldEscrowTransferID]
	return ok
}

// ResetEscrowTransferID resets all changes to the "escrow_transfer_id" field.
func (m *ValidationCaseMutation) ResetEscrowTransferID() {
	m.escrow_transfer_id = nil
	delete(m.clearedFields, validationcase.FieldEscrowTransferID)
}

// SetDisputeID sets the "dispute_id" field.
func (m *ValidationCaseMutation) SetDisputeID(s string) {
	m.dispute_id = &s
}

// DisputeID returns the value of the "dispute_id" field in the mutation.
func (m *ValidationCaseMutation) DisputeID() (r string, exists bool) {
	v := m.dispute_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDisputeID returns the old "dispute_id" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldDisputeID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisputeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisputeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisputeID: %w", err)
	}
	return oldValue.DisputeID, nil
}

// ClearDisputeID clears the value of the "dispute_id" field.
func (m *ValidationCaseMutation) ClearDisputeID() {
	m.dispute_id = nil
	m.clearedFields[validationcase.FieldDisputeID] = struct{}{}
}

// DisputeIDCleared returns if the "dispute_id" field was cleared in this mutation.
func (m *ValidationCaseMutation) DisputeIDCleared() bool {
	_, ok := m.clearedFields[validationcase.FieldDisputeID]
	return ok
}

// ResetDisputeID resets all changes to the "dispute_id" field.
func (m *ValidationCaseMutation) ResetDisputeID() {
	m.dispute_id = nil
	delete(m.clearedFields, validationcase.FieldDisputeID)
}

// SetAcceptedFinalOfferID sets the "accepted_final_offer_id" field.
func (m *ValidationCaseMutation) SetAcceptedFinalOfferID(i int) {
	m.accepted_final_offer_id = &i
	m.addaccepted_final_offer_id = nil
}

// AcceptedFinalOfferID returns the value of the "accepted_final_offer_id" field in the mutation.
func (m *ValidationCaseMutation) AcceptedFinalOfferID() (r int, exists bool) {
	v := m.accepted_final_offer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedFinalOfferID returns the old "accepted_final_offer_id" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldAcceptedFinalOfferID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedFinalOfferID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedFinalOfferID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedFinalOfferID: %w", err)
	}
	return oldValue.AcceptedFinalOfferID, nil
}

// AddAcceptedFinalOfferID adds i to the "accepted_final_offer_id" field.
func (m *ValidationCaseMutation) AddAcceptedFinalOfferID(i int) {
	if m.addaccepted_final_offer_id != nil {
		*m.addaccepted_final_offer_id += i
	} else {
		m.addaccepted_final_offer_id = &i
	}
}

// AddedAcceptedFinalOfferID returns the value that was added to the "accepted_final_offer_id" field in this mutation.
func (m *ValidationCaseMutation) AddedAcceptedFinalOfferID() (r int, exists bool) {
	v := m.addaccepted_final_offer_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAcceptedFinalOfferID clears the value of the "accepted_final_offer_id" field.
func (m *ValidationCaseMutation) ClearAcceptedFinalOfferID() {
	m.accepted_final_offer_id = nil
	m.addaccepted_final_offer_id = nil
	m.clearedFields[validationcase.FieldAcceptedFinalOfferID] = struct{}{}
}

// AcceptedFinalOfferIDCleared returns if the "accepted_final_offer_id" field was cleared in this mutation.
func (m *ValidationCaseMutation) AcceptedFinalOfferIDCleared() bool {
	_, ok := m.clearedFields[validationcase.FieldAcceptedFinalOfferID]
	return ok
}

// ResetAcceptedFinalOfferID resets all changes to the "accepted_final_offer_id" field.
func (m *ValidationCaseMutation) ResetAcceptedFinalOfferID() {
	m.accepted_final_offer_id = nil
	m.addaccepted_final_offer_id = nil
	delete(m.clearedFields, validationcase.FieldAcceptedFinalOfferID)
}

// SetArtifactDocumentID sets the "artifact_document_id" field.
func (m *ValidationCaseMutation) SetArtifactDocumentID(s string) {
	m.artifact_document_id = &s
}

// ArtifactDocumentID returns the value of the "artifact_document_id" field in the mutation.
func (m *ValidationCaseMutation) ArtifactDocumentID() (r string, exists bool) {
	v := m.artifact_document_id
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactDocumentID returns the old "artifact_document_id" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldArtifactDocumentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactDocumentID: %w", err)
	}
	return oldValue.ArtifactDocumentID, nil
}

// ClearArtifactDocumentID clears the value of the "artifact_document_id" field.
func (m *ValidationCaseMutation) ClearArtifactDocumentID() {
	m.artifact_document_id = nil
	m.clearedFields[validationcase.FieldArtifactDocumentID] = struct{}{}
}

// ArtifactDocumentIDCleared returns if the "artifact_document_id" field was cleared in this mutation.
func (m *ValidationCaseMutation) ArtifactDocumentIDCleared() bool {
	_, ok := m.clearedFields[validationcase.FieldArtifactDocumentID]
	return ok
}

// ResetArtifactDocumentID resets all changes to the "artifact_document_id" field.
func (m *ValidationCaseMutation) ResetArtifactDocumentID() {
	m.artifact_document_id = nil
	delete(m.clearedFields, validationcase.FieldArtifactDocumentID)
}

// SetCertifiedArtifactDocumentID sets the "certified_artifact_document_id" field.
func (m *ValidationCaseMutation) SetCertifiedArtifactDocumentID(s string) {
	m.certified_artifact_document_id = &s
}

// CertifiedArtifactDocumentID returns the value of the "certified_artifact_document_id" field in the mutation.
func (m *ValidationCaseMutation) CertifiedArtifactDocumentID() (r string, exists bool) {
	v := m.certified_artifact_document_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCertifiedArtifactDocumentID returns the old "certified_artifact_document_id" field's value of the ValidationCase entity.
// If the ValidationCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseMutation) OldCertifiedArtifactDocumentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertifiedArtifactDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertifiedArtifactDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertifiedArtifactDocumentID: %w", err)
	}
	return oldValue.CertifiedArtifactDocumentID, nil
}

// ClearCertifiedArtifactDocumentID clears the value of the "certified_artifact_document_id" field.
func (m *ValidationCaseMutation) ClearCertifiedArtifactDocumentID() {
	m.certified_artifact_document_id = nil
	m.clearedFields[validationcase.FieldCertifiedArtifactDocumentID] = struct{}{}
}

// CertifiedArtifactDocumentIDCleared returns if the "certified_artifact_document_id" field was cleared in this mutation.
func (m *ValidationCaseMutation) CertifiedArtifactDocumentIDCleared() bool {
	_, ok := m.clearedFields[validationcase.FieldCertifiedArtifactDocumentID]
	return ok
}

// ResetCertifiedArtifactDocumentID resets all changes to the "certified_artifact_document_id" field.
func (m *ValidationCaseMutation) ResetCertifiedArtifactDocumentID() {
	m.certified_artifact_document_id = nil
	delete(m.clearedFields, validationcase.FieldCertifiedArtifactDocumentID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ValidationCaseMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[validationcase.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ValidationCaseMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ValidationCaseMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ValidationCaseMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *ValidationCaseMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[validationcase.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *ValidationCaseMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *ValidationCaseMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *ValidationCaseMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ValidationCaseMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ValidationCaseMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ValidationCaseMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ValidationCaseMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ValidationCaseMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ValidationCaseMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ValidationCaseMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddCaseLogIDs adds the "case_logs" edge to the ValidationCaseLog entity by ids.
func (m *ValidationCaseMutation) AddCaseLogIDs(ids ...int) {
	if m.case_logs == nil {
		m.case_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.case_logs[ids[i]] = struct{}{}
	}
}

// ClearCaseLogs clears the "case_logs" edge to the ValidationCaseLog entity.
func (m *ValidationCaseMutation) ClearCaseLogs() {
	m.clearedcase_logs = true
}

// CaseLogsCleared reports if the "case_logs" edge to the ValidationCaseLog entity was cleared.
func (m *ValidationCaseMutation) CaseLogsCleared() bool {
	return m.clearedcase_logs
}

// RemoveCaseLogIDs removes the "case_logs" edge to the ValidationCaseLog entity by IDs.
func (m *ValidationCaseMutation) RemoveCaseLogIDs(ids ...int) {
	if m.removedcase_logs == nil {
		m.removedcase_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.case_logs, ids[i])
		m.removedcase_logs[ids[i]] = struct{}{}
	}
}

// RemovedCaseLogs returns the removed IDs of the "case_logs" edge to the ValidationCaseLog entity.
func (m *ValidationCaseMutation) RemovedCaseLogsIDs() (ids []int) {
	for id := range m.removedcase_logs {
		ids = append(ids, id)
	}
	return
}

// CaseLogsIDs returns the "case_logs" edge IDs in the mutation.
func (m *ValidationCaseMutation) CaseLogsIDs() (ids []int) {
	for id := range m.case_logs {
		ids = append(ids, id)
	}
	return
}

// ResetCaseLogs resets all changes to the "case_logs" edge.
func (m *ValidationCaseMutation) ResetCaseLogs() {
	m.case_logs = nil
	m.clearedcase_logs = false
	m.removedcase_logs = nil
}

// AddConsultationRequestIDs adds the "consultation_requests" edge to the ConsultationRequest entity by ids.
func (m *ValidationCaseMutation) AddConsultationRequestIDs(ids ...int) {
	if m.consultation_requests == nil {
		m.consultation_requests = make(map[int]struct{})
	}
	for i := range ids {
		m.consultation_requests[ids[i]] = struct{}{}
	}
}

// ClearConsultationRequests clears the "consultation_requests" edge to the ConsultationRequest entity.
func (m *ValidationCaseMutation) ClearConsultationRequests() {
	m.clearedconsultation_requests = true
}

// ConsultationRequestsCleared reports if the "consultation_requests" edge to the ConsultationRequest entity was cleared.
func (m *ValidationCaseMutation) ConsultationRequestsCleared() bool {
	return m.clearedconsultation_requests
}

// RemoveConsultationRequestIDs removes the "consultation_requests" edge to the ConsultationRequest entity by IDs.
func (m *ValidationCaseMutation) RemoveConsultationRequestIDs(ids ...int) {
	if m.removedconsultation_requests == nil {
		m.removedconsultation_requests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.consultation_requests, ids[i])
		m.removedconsultation_requests[ids[i]] = struct{}{}
	}
}

// RemovedConsultationRequests returns the removed IDs of the "consultation_requests" edge to the ConsultationRequest entity.
func (m *ValidationCaseMutation) RemovedConsultationRequestsIDs() (ids []int) {
	for id := range m.removedconsultation_requests {
		ids = append(ids, id)
	}
	return
}

// ConsultationRequestsIDs returns the "consultation_requests" edge IDs in the mutation.
func (m *ValidationCaseMutation) ConsultationRequestsIDs() (ids []int) {
	for id := range m.consultation_requests {
		ids = append(ids, id)
	}
	return
}

// ResetConsultationRequests resets all changes to the "consultation_requests" edge.
func (m *ValidationCaseMutation) ResetConsultationRequests() {
	m.consultation_requests = nil
	m.clearedconsultation_requests = false
	m.removedconsultation_requests = nil
}

// AddFinalOfferIDs adds the "final_offers" edge to the FinalOffer entity by ids.
func (m *ValidationCaseMutation) AddFinalOfferIDs(ids ...int) {
	if m.final_offers == nil {
		m.final_offers = make(map[int]struct{})
	}
	for i := range ids {
		m.final_offers[ids[i]] = struct{}{}
	}
}

// ClearFinalOffers clears the "final_offers" edge to the FinalOffer entity.
func (m *ValidationCaseMutation) ClearFinalOffers() {
	m.clearedfinal_offers = true
}

// FinalOffersCleared reports if the "final_offers" edge to the FinalOffer entity was cleared.
func (m *ValidationCaseMutation) FinalOffersCleared() bool {
	return m.clearedfinal_offers
}

// RemoveFinalOfferIDs removes the "final_offers" edge to the FinalOffer entity by IDs.
func (m *ValidationCaseMutation) RemoveFinalOfferIDs(ids ...int) {
	if m.removedfinal_offers == nil {
		m.removedfinal_offers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.final_offers, ids[i])
		m.removedfinal_offers[ids[i]] = struct{}{}
	}
}

// RemovedFinalOffers returns the removed IDs of the "final_offers" edge to the FinalOffer entity.
func (m *ValidationCaseMutation) RemovedFinalOffersIDs() (ids []int) {
	for id := range m.removedfinal_offers {
		ids = append(ids, id)
	}
	return
}

// FinalOffersIDs returns the "final_offers" edge IDs in the mutation.
func (m *ValidationCaseMutation) FinalOffersIDs() (ids []int) {
	for id := range m.final_offers {
		ids = append(ids, id)
	}
	return
}

// ResetFinalOffers resets all changes to the "final_offers" edge.
func (m *ValidationCaseMutation) ResetFinalOffers() {
	m.final_offers = nil
	m.clearedfinal_offers = false
	m.removedfinal_offers = nil
}

// AddArtifactSubmissionIDs adds the "artifact_submissions" edge to the ArtifactSubmission entity by ids.
func (m *ValidationCaseMutation) AddArtifactSubmissionIDs(ids ...int) {
	if m.artifact_submissions == nil {
		m.artifact_submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.artifact_submissions[ids[i]] = struct{}{}
	}
}

// ClearArtifactSubmissions clears the "artifact_submissions" edge to the ArtifactSubmission entity.
func (m *ValidationCaseMutation) ClearArtifactSubmissions() {
	m.clearedartifact_submissions = true
}

// ArtifactSubmissionsCleared reports if the "artifact_submissions" edge to the ArtifactSubmission entity was cleared.
func (m *ValidationCaseMutation) ArtifactSubmissionsCleared() bool {
	return m.clearedartifact_submissions
}

// RemoveArtifactSubmissionIDs removes the "artifact_submissions" edge to the ArtifactSubmission entity by IDs.
func (m *ValidationCaseMutation) RemoveArtifactSubmissionIDs(ids ...int) {
	if m.removedartifact_submissions == nil {
		m.removedartifact_submissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artifact_submissions, ids[i])
		m.removedartifact_submissions[ids[i]] = struct{}{}
	}
}

// RemovedArtifactSubmissions returns the removed IDs of the "artifact_submissions" edge to the ArtifactSubmission entity.
func (m *ValidationCaseMutation) RemovedArtifactSubmissionsIDs() (ids []int) {
	for id := range m.removedartifact_submissions {
		ids = append(ids, id)
	}
	return
}

// ArtifactSubmissionsIDs returns the "artifact_submissions" edge IDs in the mutation.
func (m *ValidationCaseMutation) ArtifactSubmissionsIDs() (ids []int) {
	for id := range m.artifact_submissions {
		ids = append(ids, id)
	}
	return
}

// ResetArtifactSubmissions resets all changes to the "artifact_submissions" edge.
func (m *ValidationCaseMutation) ResetArtifactSubmissions() {
	m.artifact_submissions = nil
	m.clearedartifact_submissions = false
	m.removedartifact_submissions = nil
}

// AddEndorsementIDs adds the "endorsements" edge to the Endorsement entity by ids.
func (m *ValidationCaseMutation) AddEndorsementIDs(ids ...int) {
	if m.endorsements == nil {
		m.endorsements = make(map[int]struct{})
	}
	for i := range ids {
		m.endorsements[ids[i]] = struct{}{}
	}
}

// ClearEndorsements clears the "endorsements" edge to the Endorsement entity.
func (m *ValidationCaseMutation) ClearEndorsements() {
	m.clearedendorsements = true
}

// EndorsementsCleared reports if the "endorsements" edge to the Endorsement entity was cleared.
func (m *ValidationCaseMutation) EndorsementsCleared() bool {
	return m.clearedendorsements
}

// RemoveEndorsementIDs removes the "endorsements" edge to the Endorsement entity by IDs.
func (m *ValidationCaseMutation) RemoveEndorsementIDs(ids ...int) {
	if m.removedendorsements == nil {
		m.removedendorsements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.endorsements, ids[i])
		m.removedendorsements[ids[i]] = struct{}{}
	}
}

// RemovedEndorsements returns the removed IDs of the "endorsements" edge to the Endorsement entity.
func (m *ValidationCaseMutation) RemovedEndorsementsIDs() (ids []int) {
	for id := range m.removedendorsements {
		ids = append(ids, id)
	}
	return
}

// EndorsementsIDs returns the "endorsements" edge IDs in the mutation.
func (m *ValidationCaseMutation) EndorsementsIDs() (ids []int) {
	for id := range m.endorsements {
		ids = append(ids, id)
	}
	return
}

// ResetEndorsements resets all changes to the "endorsements" edge.
func (m *ValidationCaseMutation) ResetEndorsements() {
	m.endorsements = nil
	m.clearedendorsements = false
	m.removedendorsements = nil
}

// Where appends a list predicates to the ValidationCaseMutation builder.
func (m *ValidationCaseMutation) Where(ps ...predicate.ValidationCase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ValidationCaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ValidationCaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ValidationCase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ValidationCaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ValidationCaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ValidationCase).
func (m *ValidationCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ValidationCaseMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, validationcase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, validationcase.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, validationcase.FieldDeletedAt)
	}
	if m.category != nil {
		fields = append(fields, validationcase.FieldCategoryID)
	}
	if m.user != nil {
		fields = append(fields, validationcase.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, validationcase.FieldTitle)
	}
	if m.summary != nil {
		fields = append(fields, validationcase.FieldSummary)
	}
	if m.content_type != nil {
		fields = append(fields, validationcase.FieldContentType)
	}
	if m.content_json != nil {
		fields = append(fields, validationcase.FieldContentJSON)
	}
	if m.meta != nil {
		fields = append(fields, validationcase.FieldMeta)
	}
	if m.bounty_amount != nil {
		fields = append(fields, validationcase.FieldBountyAmount)
	}
	if m.status != nil {
		fields = append(fields, validationcase.FieldStatus)
	}
	if m.sensitivity_level != nil {
		fields = append(fields, validationcase.FieldSensitivityLevel)
	}
	if m.intake_schema_version != nil {
		fields = append(fields, validationcase.FieldIntakeSchemaVersion)
	}
	if m.clarification_state != nil {
		fields = append(fields, validationcase.FieldClarificationState)
	}
	if m.owner_inactivity_count != nil {
		fields = append(fields, validationcase.FieldOwnerInactivityCount)
	}
	if m.workflow_cycle != nil {
		fields = append(fields, validationcase.FieldWorkflowCycle)
	}
	if m.escrow_transfer_id != nil {
		fields = append(fields, validationcase.FieldEscrowTransferID)
	}
	if m.dispute_id != nil {
		fields = append(fields, validationcase.FieldDisputeID)
	}
	if m.accepted_final_offer_id != nil {
		fields = append(fields, validationcase.FieldAcceptedFinalOfferID)
	}
	if m.artifact_document_id != nil {
		fields = append(fields, validationcase.FieldArtifactDocumentID)
	}
	if m.certified_artifact_document_id != nil {
		fields = append(fields, validationcase.FieldCertifiedArtifactDocumentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ValidationCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case validationcase.FieldCreatedAt:
		return m.CreatedAt()
	case validationcase.FieldUpdatedAt:
		return m.UpdatedAt()
	case validationcase.FieldDeletedAt:
		return m.DeletedAt()
	case validationcase.FieldCategoryID:
		return m.CategoryID()
	case validationcase.FieldUserID:
		return m.UserID()
	case validationcase.FieldTitle:
		return m.Title()
	case validationcase.FieldSummary:
		return m.Summary()
	case validationcase.FieldContentType:
		return m.ContentType()
	case validationcase.FieldContentJSON:
		return m.ContentJSON()
	case validationcase.FieldMeta:
		return m.Meta()
	case validationcase.FieldBountyAmount:
		return m.BountyAmount()
	case validationcase.FieldStatus:
		return m.Status()
	case validationcase.FieldSensitivityLevel:
		return m.SensitivityLevel()
	case validationcase.FieldIntakeSchemaVersion:
		return m.IntakeSchemaVersion()
	case validationcase.FieldClarificationState:
		return m.ClarificationState()
	case validationcase.FieldOwnerInactivityCount:
		return m.OwnerInactivityCount()
	case validationcase.FieldWorkflowCycle:
		return m.WorkflowCycle()
	case validationcase.FieldEscrowTransferID:
		return m.EscrowTransferID()
	case validationcase.FieldDisputeID:
		return m.DisputeID()
	case validationcase.FieldAcceptedFinalOfferID:
		return m.AcceptedFinalOfferID()
	case validationcase.FieldArtifactDocumentID:
		return m.ArtifactDocumentID()
	case validationcase.FieldCertifiedArtifactDocumentID:
		return m.CertifiedArtifactDocumentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ValidationCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case validationcase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case validationcase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case validationcase.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case validationcase.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case validationcase.FieldUserID:
		return m.OldUserID(ctx)
	case validationcase.FieldTitle:
		return m.OldTitle(ctx)
	case validationcase.FieldSummary:
		return m.OldSummary(ctx)
	case validationcase.FieldContentType:
		return m.OldContentType(ctx)
	case validationcase.FieldContentJSON:
		return m.OldContentJSON(ctx)
	case validationcase.FieldMeta:
		return m.OldMeta(ctx)
	case validationcase.FieldBountyAmount:
		return m.OldBountyAmount(ctx)
	case validationcase.FieldStatus:
		return m.OldStatus(ctx)
	case validationcase.FieldSensitivityLevel:
		return m.OldSensitivityLevel(ctx)
	case validationcase.FieldIntakeSchemaVersion:
		return m.OldIntakeSchemaVersion(ctx)
	case validationcase.FieldClarificationState:
		return m.OldClarificationState(ctx)
	case validationcase.FieldOwnerInactivityCount:
		return m.OldOwnerInactivityCount(ctx)
	case validationcase.FieldWorkflowCycle:
		return m.OldWorkflowCycle(ctx)
	case validationcase.FieldEscrowTransferID:
		return m.OldEscrowTransferID(ctx)
	case validationcase.FieldDisputeID:
		return m.OldDisputeID(ctx)
	case validationcase.FieldAcceptedFinalOfferID:
		return m.OldAcceptedFinalOfferID(ctx)
	case validationcase.FieldArtifactDocumentID:
		return m.OldArtifactDocumentID(ctx)
	case validationcase.FieldCertifiedArtifactDocumentID:
		return m.OldCertifiedArtifactDocumentID(ctx)
	}
	return nil, fmt.Errorf("unknown ValidationCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ValidationCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case validationcase.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case validationcase.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case validationcase.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case validationcase.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case validationcase.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case validationcase.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case validationcase.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case validationcase.FieldContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case validationcase.FieldContentJSON:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentJSON(v)
		return nil
	case validationcase.FieldMeta:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeta(v)
		return nil
	case validationcase.FieldBountyAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBountyAmount(v)
		return nil
	case validationcase.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case validationcase.FieldSensitivityLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSensitivityLevel(v)
		return nil
	case validationcase.FieldIntakeSchemaVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntakeSchemaVersion(v)
		return nil
	case validationcase.FieldClarificationState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClarificationState(v)
		return nil
	case validationcase.FieldOwnerInactivityCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerInactivityCount(v)
		return nil
	case validationcase.FieldWorkflowCycle:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowCycle(v)
		return nil
	case validationcase.FieldEscrowTransferID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEscrowTransferID(v)
		return nil
	case validationcase.FieldDisputeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisputeID(v)
		return nil
	case validationcase.FieldAcceptedFinalOfferID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedFinalOfferID(v)
		return nil
	case validationcase.FieldArtifactDocumentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactDocumentID(v)
		return nil
	case validationcase.FieldCertifiedArtifactDocumentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertifiedArtifactDocumentID(v)
		return nil
	}
	return fmt.Errorf("unknown ValidationCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ValidationCaseMutation) AddedFields() []string {
	var fields []string
	if m.addbounty_amount != nil {
		fields = append(fields, validationcase.FieldBountyAmount)
	}
	if m.addowner_inactivity_count != nil {
		fields = append(fields, validationcase.FieldOwnerInactivityCount)
	}
	if m.addworkflow_cycle != nil {
		fields = append(fields, validationcase.FieldWorkflowCycle)
	}
	if m.addaccepted_final_offer_id != nil {
		fields = append(fields, validationcase.FieldAcceptedFinalOfferID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ValidationCaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case validationcase.FieldBountyAmount:
		return m.AddedBountyAmount()
	case validationcase.FieldOwnerInactivityCount:
		return m.AddedOwnerInactivityCount()
	case validationcase.FieldWorkflowCycle:
		return m.AddedWorkflowCycle()
	case validationcase.FieldAcceptedFinalOfferID:
		return m.AddedAcceptedFinalOfferID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ValidationCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case validationcase.FieldBountyAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBountyAmount(v)
		return nil
	case validationcase.FieldOwnerInactivityCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerInactivityCount(v)
		return nil
	case validationcase.FieldWorkflowCycle:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkflowCycle(v)
		return nil
	case validationcase.FieldAcceptedFinalOfferID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAcceptedFinalOfferID(v)
		return nil
	}
	return fmt.Errorf("unknown ValidationCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ValidationCaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(validationcase.FieldDeletedAt) {
		fields = append(fields, validationcase.FieldDeletedAt)
	}
	if m.FieldCleared(validationcase.FieldSummary) {
		fields = append(fields, validationcase.FieldSummary)
	}
	if m.FieldCleared(validationcase.FieldContentJSON) {
		fields = append(fields, validationcase.FieldContentJSON)
	}
	if m.FieldCleared(validationcase.FieldMeta) {
		fields = append(fields, validationcase.FieldMeta)
	}
	if m.FieldCleared(validationcase.FieldEscrowTransferID) {
		fields = append(fields, validationcase.FieldEscrowTransferID)
	}
	if m.FieldCleared(validationcase.FieldDisputeID) {
		fields = append(fields, validationcase.FieldDisputeID)
	}
	if m.FieldCleared(validationcase.FieldAcceptedFinalOfferID) {
		fields = append(fields, validationcase.FieldAcceptedFinalOfferID)
	}
	if m.FieldCleared(validationcase.FieldArtifactDocumentID) {
		fields = append(fields, validationcase.FieldArtifactDocumentID)
	}
	if m.FieldCleared(validationcase.FieldCertifiedArtifactDocumentID) {
		fields = append(fields, validationcase.FieldCertifiedArtifactDocumentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ValidationCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ValidationCaseMutation) ClearField(name string) error {
	switch name {
	case validationcase.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case validationcase.FieldSummary:
		m.ClearSummary()
		return nil
	case validationcase.FieldContentJSON:
		m.ClearContentJSON()
		return nil
	case validationcase.FieldMeta:
		m.ClearMeta()
		return nil
	case validationcase.FieldEscrowTransferID:
		m.ClearEscrowTransferID()
		return nil
	case validationcase.FieldDisputeID:
		m.ClearDisputeID()
		return nil
	case validationcase.FieldAcceptedFinalOfferID:
		m.ClearAcceptedFinalOfferID()
		return nil
	case validationcase.FieldArtifactDocumentID:
		m.ClearArtifactDocumentID()
		return nil
	case validationcase.FieldCertifiedArtifactDocumentID:
		m.ClearCertifiedArtifactDocumentID()
		return nil
	}
	return fmt.Errorf("unknown ValidationCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ValidationCaseMutation) ResetField(name string) error {
	switch name {
	case validationcase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case validationcase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case validationcase.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case validationcase.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case validationcase.FieldUserID:
		m.ResetUserID()
		return nil
	case validationcase.FieldTitle:
		m.ResetTitle()
		return nil
	case validationcase.FieldSummary:
		m.ResetSummary()
		return nil
	case validationcase.FieldContentType:
		m.ResetContentType()
		return nil
	case validationcase.FieldContentJSON:
		m.ResetContentJSON()
		return nil
	case validationcase.FieldMeta:
		m.ResetMeta()
		return nil
	case validationcase.FieldBountyAmount:
		m.ResetBountyAmount()
		return nil
	case validationcase.FieldStatus:
		m.ResetStatus()
		return nil
	case validationcase.FieldSensitivityLevel:
		m.ResetSensitivityLevel()
		return nil
	case validationcase.FieldIntakeSchemaVersion:
		m.ResetIntakeSchemaVersion()
		return nil
	case validationcase.FieldClarificationState:
		m.ResetClarificationState()
		return nil
	case validationcase.FieldOwnerInactivityCount:
		m.ResetOwnerInactivityCount()
		return nil
	case validationcase.FieldWorkflowCycle:
		m.ResetWorkflowCycle()
		return nil
	case validationcase.FieldEscrowTransferID:
		m.ResetEscrowTransferID()
		return nil
	case validationcase.FieldDisputeID:
		m.ResetDisputeID()
		return nil
	case validationcase.FieldAcceptedFinalOfferID:
		m.ResetAcceptedFinalOfferID()
		return nil
	case validationcase.FieldArtifactDocumentID:
		m.ResetArtifactDocumentID()
		return nil
	case validationcase.FieldCertifiedArtifactDocumentID:
		m.ResetCertifiedArtifactDocumentID()
		return nil
	}
	return fmt.Errorf("unknown ValidationCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ValidationCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.user != nil {
		edges = append(edges, validationcase.EdgeUser)
	}
	if m.category != nil {
		edges = append(edges, validationcase.EdgeCategory)
	}
	if m.tags != nil {
		edges = append(edges, validationcase.EdgeTags)
	}
	if m.case_logs != nil {
		edges = append(edges, validationcase.EdgeCaseLogs)
	}
	if m.consultation_requests != nil {
		edges = append(edges, validationcase.EdgeConsultationRequests)
	}
	if m.final_offers != nil {
		edges = append(edges, validationcase.EdgeFinalOffers)
	}
	if m.artifact_submissions != nil {
		edges = append(edges, validationcase.EdgeArtifactSubmissions)
	}
	if m.endorsements != nil {
		edges = append(edges, validationcase.EdgeEndorsements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ValidationCaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case validationcase.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case validationcase.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case validationcase.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case validationcase.EdgeCaseLogs:
		ids := make([]ent.Value, 0, len(m.case_logs))
		for id := range m.case_logs {
			ids = append(ids, id)
		}
		return ids
	case validationcase.EdgeConsultationRequests:
		ids := make([]ent.Value, 0, len(m.consultation_requests))
		for id := range m.consultation_requests {
			ids = append(ids, id)
		}
		return ids
	case validationcase.EdgeFinalOffers:
		ids := make([]ent.Value, 0, len(m.final_offers))
		for id := range m.final_offers {
			ids = append(ids, id)
		}
		return ids
	case validationcase.EdgeArtifactSubmissions:
		ids := make([]ent.Value, 0, len(m.artifact_submissions))
		for id := range m.artifact_submissions {
			ids = append(ids, id)
		}
		return ids
	case validationcase.EdgeEndorsements:
		ids := make([]ent.Value, 0, len(m.endorsements))
		for id := range m.endorsements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ValidationCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedtags != nil {
		edges = append(edges, validationcase.EdgeTags)
	}
	if m.removedcase_logs != nil {
		edges = append(edges, validationcase.EdgeCaseLogs)
	}
	if m.removedconsultation_requests != nil {
		edges = append(edges, validationcase.EdgeConsultationRequests)
	}
	if m.removedfinal_offers != nil {
		edges = append(edges, validationcase.EdgeFinalOffers)
	}
	if m.removedartifact_submissions != nil {
		edges = append(edges, validationcase.EdgeArtifactSubmissions)
	}
	if m.removedendorsements != nil {
		edges = append(edges, validationcase.EdgeEndorsements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ValidationCaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case validationcase.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case validationcase.EdgeCaseLogs:
		ids := make([]ent.Value, 0, len(m.removedcase_logs))
		for id := range m.removedcase_logs {
			ids = append(ids, id)
		}
		return ids
	case validationcase.EdgeConsultationRequests:
		ids := make([]ent.Value, 0, len(m.removedconsultation_requests))
		for id := range m.removedconsultation_requests {
			ids = append(ids, id)
		}
		return ids
	case validationcase.EdgeFinalOffers:
		ids := make([]ent.Value, 0, len(m.removedfinal_offers))
		for id := range m.removedfinal_offers {
			ids = append(ids, id)
		}
		return ids
	case validationcase.EdgeArtifactSubmissions:
		ids := make([]ent.Value, 0, len(m.removedartifact_submissions))
		for id := range m.removedartifact_submissions {
			ids = append(ids, id)
		}
		return ids
	case validationcase.EdgeEndorsements:
		ids := make([]ent.Value, 0, len(m.removedendorsements))
		for id := range m.removedendorsements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ValidationCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.cleareduser {
		edges = append(edges, validationcase.EdgeUser)
	}
	if m.clearedcategory {
		edges = append(edges, validationcase.EdgeCategory)
	}
	if m.clearedtags {
		edges = append(edges, validationcase.EdgeTags)
	}
	if m.clearedcase_logs {
		edges = append(edges, validationcase.EdgeCaseLogs)
	}
	if m.clearedconsultation_requests {
		edges = append(edges, validationcase.EdgeConsultationRequests)
	}
	if m.clearedfinal_offers {
		edges = append(edges, validationcase.EdgeFinalOffers)
	}
	if m.clearedartifact_submissions {
		edges = append(edges, validationcase.EdgeArtifactSubmissions)
	}
	if m.clearedendorsements {
		edges = append(edges, validationcase.EdgeEndorsements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ValidationCaseMutation) EdgeCleared(name string) bool {
	switch name {
	case validationcase.EdgeUser:
		return m.cleareduser
	case validationcase.EdgeCategory:
		return m.clearedcategory
	case validationcase.EdgeTags:
		return m.clearedtags
	case validationcase.EdgeCaseLogs:
		return m.clearedcase_logs
	case validationcase.EdgeConsultationRequests:
		return m.clearedconsultation_requests
	case validationcase.EdgeFinalOffers:
		return m.clearedfinal_offers
	case validationcase.EdgeArtifactSubmissions:
		return m.clearedartifact_submissions
	case validationcase.EdgeEndorsements:
		return m.clearedendorsements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ValidationCaseMutation) ClearEdge(name string) error {
	switch name {
	case validationcase.EdgeUser:
		m.ClearUser()
		return nil
	case validationcase.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown ValidationCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ValidationCaseMutation) ResetEdge(name string) error {
	switch name {
	case validationcase.EdgeUser:
		m.ResetUser()
		return nil
	case validationcase.EdgeCategory:
		m.ResetCategory()
		return nil
	case validationcase.EdgeTags:
		m.ResetTags()
		return nil
	case validationcase.EdgeCaseLogs:
		m.ResetCaseLogs()
		return nil
	case validationcase.EdgeConsultationRequests:
		m.ResetConsultationRequests()
		return nil
	case validationcase.EdgeFinalOffers:
		m.ResetFinalOffers()
		return nil
	case validationcase.EdgeArtifactSubmissions:
		m.ResetArtifactSubmissions()
		return nil
	case validationcase.EdgeEndorsements:
		m.ResetEndorsements()
		return nil
	}
	return fmt.Errorf("unknown ValidationCase edge %s", name)
}

// ValidationCaseLogMutation represents an operation that mutates the ValidationCaseLog nodes in the graph.
type ValidationCaseLogMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	event_type             *string
	detail_json            *map[string]interface{}
	clearedFields          map[string]struct{}
	validation_case        *int
	clearedvalidation_case bool
	actor_user             *int
	clearedactor_user      bool
	done                   bool
	oldValue               func(context.Context) (*ValidationCaseLog, error)
	predicates             []predicate.ValidationCaseLog
}

var _ ent.Mutation = (*ValidationCaseLogMutation)(nil)

// validationcaselogOption allows management of the mutation configuration using functional options.
type validationcaselogOption func(*ValidationCaseLogMutation)

// newValidationCaseLogMutation creates new mutation for the ValidationCaseLog entity.
func newValidationCaseLogMutation(c config, op Op, opts ...validationcaselogOption) *ValidationCaseLogMutation {
	m := &ValidationCaseLogMutation{
		config:        c,
		op:            op,
		typ:           TypeValidationCaseLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withValidationCaseLogID sets the ID field of the mutation.
func withValidationCaseLogID(id int) validationcaselogOption {
	return func(m *ValidationCaseLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ValidationCaseLog
		)
		m.oldValue = func(ctx context.Context) (*ValidationCaseLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ValidationCaseLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withValidationCaseLog sets the old ValidationCaseLog of the mutation.
func withValidationCaseLog(node *ValidationCaseLog) validationcaselogOption {
	return func(m *ValidationCaseLogMutation) {
		m.oldValue = func(context.Context) (*ValidationCaseLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ValidationCaseLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ValidationCaseLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ValidationCaseLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ValidationCaseLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ValidationCaseLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ValidationCaseLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ValidationCaseLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ValidationCaseLog entity.
// If the ValidationCaseLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ValidationCaseLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ValidationCaseLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ValidationCaseLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ValidationCaseLog entity.
// If the ValidationCaseLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ValidationCaseLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ValidationCaseLogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ValidationCaseLogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ValidationCaseLog entity.
// If the ValidationCaseLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseLogMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ValidationCaseLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[validationcaselog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ValidationCaseLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[validationcaselog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ValidationCaseLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, validationcaselog.FieldDeletedAt)
}

// SetValidationCaseID sets the "validation_case_id" field.
func (m *ValidationCaseLogMutation) SetValidationCaseID(i int) {
	m.validation_case = &i
}

// ValidationCaseID returns the value of the "validation_case_id" field in the mutation.
func (m *ValidationCaseLogMutation) ValidationCaseID() (r int, exists bool) {
	v := m.validation_case
	if v == nil {
		return
	}
	return *v, true
}

// OldValidationCaseID returns the old "validation_case_id" field's value of the ValidationCaseLog entity.
// If the ValidationCaseLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseLogMutation) OldValidationCaseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidationCaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidationCaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidationCaseID: %w", err)
	}
	return oldValue.ValidationCaseID, nil
}

// ResetValidationCaseID resets all changes to the "validation_case_id" field.
func (m *ValidationCaseLogMutation) ResetValidationCaseID() {
	m.validation_case = nil
}

// SetActorUserID sets the "actor_user_id" field.
func (m *ValidationCaseLogMutation) SetActorUserID(i int) {
	m.actor_user = &i
}

// ActorUserID returns the value of the "actor_user_id" field in the mutation.
func (m *ValidationCaseLogMutation) ActorUserID() (r int, exists bool) {
	v := m.actor_user
	if v == nil {
		return
	}
	return *v, true
}

// OldActorUserID returns the old "actor_user_id" field's value of the ValidationCaseLog entity.
// If the ValidationCaseLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseLogMutation) OldActorUserID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActorUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActorUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActorUserID: %w", err)
	}
	return oldValue.ActorUserID, nil
}

// ClearActorUserID clears the value of the "actor_user_id" field.
func (m *ValidationCaseLogMutation) ClearActorUserID() {
	m.actor_user = nil
	m.clearedFields[validationcaselog.FieldActorUserID] = struct{}{}
}

// ActorUserIDCleared returns if the "actor_user_id" field was cleared in this mutation.
func (m *ValidationCaseLogMutation) ActorUserIDCleared() bool {
	_, ok := m.clearedFields[validationcaselog.FieldActorUserID]
	return ok
}

// ResetActorUserID resets all changes to the "actor_user_id" field.
func (m *ValidationCaseLogMutation) ResetActorUserID() {
	m.actor_user = nil
	delete(m.clearedFields, validationcaselog.FieldActorUserID)
}

// SetEventType sets the "event_type" field.
func (m *ValidationCaseLogMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *ValidationCaseLogMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the ValidationCaseLog entity.
// If the ValidationCaseLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseLogMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *ValidationCaseLogMutation) ResetEventType() {
	m.event_type = nil
}

// SetDetailJSON sets the "detail_json" field.
func (m *ValidationCaseLogMutation) SetDetailJSON(value map[string]interface{}) {
	m.detail_json = &value
}

// DetailJSON returns the value of the "detail_json" field in the mutation.
func (m *ValidationCaseLogMutation) DetailJSON() (r map[string]interface{}, exists bool) {
	v := m.detail_json
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailJSON returns the old "detail_json" field's value of the ValidationCaseLog entity.
// If the ValidationCaseLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValidationCaseLogMutation) OldDetailJSON(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailJSON: %w", err)
	}
	return oldValue.DetailJSON, nil
}

// ClearDetailJSON clears the value of the "detail_json" field.
func (m *ValidationCaseLogMutation) ClearDetailJSON() {
	m.detail_json = nil
	m.clearedFields[validationcaselog.FieldDetailJSON] = struct{}{}
}

// DetailJSONCleared returns if the "detail_json" field was cleared in this mutation.
func (m *ValidationCaseLogMutation) DetailJSONCleared() bool {
	_, ok := m.clearedFields[validationcaselog.FieldDetailJSON]
	return ok
}

// ResetDetailJSON resets all changes to the "detail_json" field.
func (m *ValidationCaseLogMutation) ResetDetailJSON() {
	m.detail_json = nil
	delete(m.clearedFields, validationcaselog.FieldDetailJSON)
}

// ClearValidationCase clears the "validation_case" edge to the ValidationCase entity.
func (m *ValidationCaseLogMutation) ClearValidationCase() {
	m.clearedvalidation_case = true
	m.clearedFields[validationcaselog.FieldValidationCaseID] = struct{}{}
}

// ValidationCaseCleared reports if the "validation_case" edge to the ValidationCase entity was cleared.
func (m *ValidationCaseLogMutation) ValidationCaseCleared() bool {
	return m.clearedvalidation_case
}

// ValidationCaseIDs returns the "validation_case" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ValidationCaseID instead. It exists only for internal usage by the builders.
func (m *ValidationCaseLogMutation) ValidationCaseIDs() (ids []int) {
	if id := m.validation_case; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetValidationCase resets all changes to the "validation_case" edge.
func (m *ValidationCaseLogMutation) ResetValidationCase() {
	m.validation_case = nil
	m.clearedvalidation_case = false
}

// ClearActorUser clears the "actor_user" edge to the User entity.
func (m *ValidationCaseLogMutation) ClearActorUser() {
	m.clearedactor_user = true
	m.clearedFields[validationcaselog.FieldActorUserID] = struct{}{}
}

// ActorUserCleared reports if the "actor_user" edge to the User entity was cleared.
func (m *ValidationCaseLogMutation) ActorUserCleared() bool {
	return m.ActorUserIDCleared() || m.clearedactor_user
}

// ActorUserIDs returns the "actor_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActorUserID instead. It exists only for internal usage by the builders.
func (m *ValidationCaseLogMutation) ActorUserIDs() (ids []int) {
	if id := m.actor_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActorUser resets all changes to the "actor_user" edge.
func (m *ValidationCaseLogMutation) ResetActorUser() {
	m.actor_user = nil
	m.clearedactor_user = false
}

// Where appends a list predicates to the ValidationCaseLogMutation builder.
func (m *ValidationCaseLogMutation) Where(ps ...predicate.ValidationCaseLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ValidationCaseLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ValidationCaseLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ValidationCaseLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ValidationCaseLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ValidationCaseLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ValidationCaseLog).
func (m *ValidationCaseLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ValidationCaseLogMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, validationcaselog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, validationcaselog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, validationcaselog.FieldDeletedAt)
	}
	if m.validation_case != nil {
		fields = append(fields, validationcaselog.FieldValidationCaseID)
	}
	if m.actor_user != nil {
		fields = append(fields, validationcaselog.FieldActorUserID)
	}
	if m.event_type != nil {
		fields = append(fields, validationcaselog.FieldEventType)
	}
	if m.detail_json != nil {
		fields = append(fields, validationcaselog.FieldDetailJSON)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ValidationCaseLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case validationcaselog.FieldCreatedAt:
		return m.CreatedAt()
	case validationcaselog.FieldUpdatedAt:
		return m.UpdatedAt()
	case validationcaselog.FieldDeletedAt:
		return m.DeletedAt()
	case validationcaselog.FieldValidationCaseID:
		return m.ValidationCaseID()
	case validationcaselog.FieldActorUserID:
		return m.ActorUserID()
	case validationcaselog.FieldEventType:
		return m.EventType()
	case validationcaselog.FieldDetailJSON:
		return m.DetailJSON()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ValidationCaseLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case validationcaselog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case validationcaselog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case validationcaselog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case validationcaselog.FieldValidationCaseID:
		return m.OldValidationCaseID(ctx)
	case validationcaselog.FieldActorUserID:
		return m.OldActorUserID(ctx)
	case validationcaselog.FieldEventType:
		return m.OldEventType(ctx)
	case validationcaselog.FieldDetailJSON:
		return m.OldDetailJSON(ctx)
	}
	return nil, fmt.Errorf("unknown ValidationCaseLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ValidationCaseLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case validationcaselog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case validationcaselog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case validationcaselog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case validationcaselog.FieldValidationCaseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidationCaseID(v)
		return nil
	case validationcaselog.FieldActorUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActorUserID(v)
		return nil
	case validationcaselog.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case validationcaselog.FieldDetailJSON:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailJSON(v)
		return nil
	}
	return fmt.Errorf("unknown ValidationCaseLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ValidationCaseLogMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ValidationCaseLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ValidationCaseLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ValidationCaseLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ValidationCaseLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(validationcaselog.FieldDeletedAt) {
		fields = append(fields, validationcaselog.FieldDeletedAt)
	}
	if m.FieldCleared(validationcaselog.FieldActorUserID) {
		fields = append(fields, validationcaselog.FieldActorUserID)
	}
	if m.FieldCleared(validationcaselog.FieldDetailJSON) {
		fields = append(fields, validationcaselog.FieldDetailJSON)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ValidationCaseLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ValidationCaseLogMutation) ClearField(name string) error {
	switch name {
	case validationcaselog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case validationcaselog.FieldActorUserID:
		m.ClearActorUserID()
		return nil
	case validationcaselog.FieldDetailJSON:
		m.ClearDetailJSON()
		return nil
	}
	return fmt.Errorf("unknown ValidationCaseLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ValidationCaseLogMutation) ResetField(name string) error {
	switch name {
	case validationcaselog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case validationcaselog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case validationcaselog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case validationcaselog.FieldValidationCaseID:
		m.ResetValidationCaseID()
		return nil
	case validationcaselog.FieldActorUserID:
		m.ResetActorUserID()
		return nil
	case validationcaselog.FieldEventType:
		m.ResetEventType()
		return nil
	case validationcaselog.FieldDetailJSON:
		m.ResetDetailJSON()
		return nil
	}
	return fmt.Errorf("unknown ValidationCaseLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ValidationCaseLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.validation_case != nil {
		edges = append(edges, validationcaselog.EdgeValidationCase)
	}
	if m.actor_user != nil {
		edges = append(edges, validationcaselog.EdgeActorUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ValidationCaseLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case validationcaselog.EdgeValidationCase:
		if id := m.validation_case; id != nil {
			return []ent.Value{*id}
		}
	case validationcaselog.EdgeActorUser:
		if id := m.actor_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ValidationCaseLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ValidationCaseLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ValidationCaseLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvalidation_case {
		edges = append(edges, validationcaselog.EdgeValidationCase)
	}
	if m.clearedactor_user {
		edges = append(edges, validationcaselog.EdgeActorUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ValidationCaseLogMutation) EdgeCleared(name string) bool {
	switch name {
	case validationcaselog.EdgeValidationCase:
		return m.clearedvalidation_case
	case validationcaselog.EdgeActorUser:
		return m.clearedactor_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ValidationCaseLogMutation) ClearEdge(name string) error {
	switch name {
	case validationcaselog.EdgeValidationCase:
		m.ClearValidationCase()
		return nil
	case validationcaselog.EdgeActorUser:
		m.ClearActorUser()
		return nil
	}
	return fmt.Errorf("unknown ValidationCaseLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ValidationCaseLogMutation) ResetEdge(name string) error {
	switch name {
	case validationcaselog.EdgeValidationCase:
		m.ResetValidationCase()
		return nil
	case validationcaselog.EdgeActorUser:
		m.ResetActorUser()
		return nil
	}
	return fmt.Errorf("unknown ValidationCaseLog edge %s", name)
}
