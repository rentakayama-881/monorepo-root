// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend-gin/ent/admin"
	"backend-gin/ent/backupcode"
	"backend-gin/ent/badge"
	"backend-gin/ent/category"
	"backend-gin/ent/chaincursor"
	"backend-gin/ent/credential"
	"backend-gin/ent/devicefingerprint"
	"backend-gin/ent/deviceusermapping"
	"backend-gin/ent/emailverificationtoken"
	"backend-gin/ent/passkey"
	"backend-gin/ent/passwordresettoken"
	"backend-gin/ent/predicate"
	"backend-gin/ent/securityevent"
	"backend-gin/ent/session"
	"backend-gin/ent/sessionlock"
	"backend-gin/ent/sudosession"
	"backend-gin/ent/tag"
	"backend-gin/ent/thread"
	"backend-gin/ent/threadcredential"
	"backend-gin/ent/totppendingtoken"
	"backend-gin/ent/user"
	"backend-gin/ent/userbadge"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdmin                  = "Admin"
	TypeBackupCode             = "BackupCode"
	TypeBadge                  = "Badge"
	TypeCategory               = "Category"
	TypeChainCursor            = "ChainCursor"
	TypeCredential             = "Credential"
	TypeDeviceFingerprint      = "DeviceFingerprint"
	TypeDeviceUserMapping      = "DeviceUserMapping"
	TypeEmailVerificationToken = "EmailVerificationToken"
	TypePasskey                = "Passkey"
	TypePasswordResetToken     = "PasswordResetToken"
	TypeSecurityEvent          = "SecurityEvent"
	TypeSession                = "Session"
	TypeSessionLock            = "SessionLock"
	TypeSudoSession            = "SudoSession"
	TypeTOTPPendingToken       = "TOTPPendingToken"
	TypeTag                    = "Tag"
	TypeThread                 = "Thread"
	TypeThreadCredential       = "ThreadCredential"
	TypeUser                   = "User"
	TypeUserBadge              = "UserBadge"
)

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	email                 *string
	password_hash         *string
	name                  *string
	clearedFields         map[string]struct{}
	granted_badges        map[int]struct{}
	removedgranted_badges map[int]struct{}
	clearedgranted_badges bool
	done                  bool
	oldValue              func(context.Context) (*Admin, error)
	predicates            []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id int) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdminMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[admin.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdminMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[admin.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, admin.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *AdminMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AdminMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AdminMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *AdminMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *AdminMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *AdminMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetName sets the "name" field.
func (m *AdminMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdminMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AdminMutation) ResetName() {
	m.name = nil
}

// AddGrantedBadgeIDs adds the "granted_badges" edge to the UserBadge entity by ids.
func (m *AdminMutation) AddGrantedBadgeIDs(ids ...int) {
	if m.granted_badges == nil {
		m.granted_badges = make(map[int]struct{})
	}
	for i := range ids {
		m.granted_badges[ids[i]] = struct{}{}
	}
}

// ClearGrantedBadges clears the "granted_badges" edge to the UserBadge entity.
func (m *AdminMutation) ClearGrantedBadges() {
	m.clearedgranted_badges = true
}

// GrantedBadgesCleared reports if the "granted_badges" edge to the UserBadge entity was cleared.
func (m *AdminMutation) GrantedBadgesCleared() bool {
	return m.clearedgranted_badges
}

// RemoveGrantedBadgeIDs removes the "granted_badges" edge to the UserBadge entity by IDs.
func (m *AdminMutation) RemoveGrantedBadgeIDs(ids ...int) {
	if m.removedgranted_badges == nil {
		m.removedgranted_badges = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.granted_badges, ids[i])
		m.removedgranted_badges[ids[i]] = struct{}{}
	}
}

// RemovedGrantedBadges returns the removed IDs of the "granted_badges" edge to the UserBadge entity.
func (m *AdminMutation) RemovedGrantedBadgesIDs() (ids []int) {
	for id := range m.removedgranted_badges {
		ids = append(ids, id)
	}
	return
}

// GrantedBadgesIDs returns the "granted_badges" edge IDs in the mutation.
func (m *AdminMutation) GrantedBadgesIDs() (ids []int) {
	for id := range m.granted_badges {
		ids = append(ids, id)
	}
	return
}

// ResetGrantedBadges resets all changes to the "granted_badges" edge.
func (m *AdminMutation) ResetGrantedBadges() {
	m.granted_badges = nil
	m.clearedgranted_badges = false
	m.removedgranted_badges = nil
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Admin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, admin.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, admin.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, admin.FieldPasswordHash)
	}
	if m.name != nil {
		fields = append(fields, admin.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	case admin.FieldDeletedAt:
		return m.DeletedAt()
	case admin.FieldEmail:
		return m.Email()
	case admin.FieldPasswordHash:
		return m.PasswordHash()
	case admin.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case admin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case admin.FieldEmail:
		return m.OldEmail(ctx)
	case admin.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case admin.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case admin.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case admin.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case admin.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case admin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(admin.FieldDeletedAt) {
		fields = append(fields, admin.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	switch name {
	case admin.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case admin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case admin.FieldEmail:
		m.ResetEmail()
		return nil
	case admin.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case admin.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.granted_badges != nil {
		edges = append(edges, admin.EdgeGrantedBadges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeGrantedBadges:
		ids := make([]ent.Value, 0, len(m.granted_badges))
		for id := range m.granted_badges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgranted_badges != nil {
		edges = append(edges, admin.EdgeGrantedBadges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeGrantedBadges:
		ids := make([]ent.Value, 0, len(m.removedgranted_badges))
		for id := range m.removedgranted_badges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgranted_badges {
		edges = append(edges, admin.EdgeGrantedBadges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeGrantedBadges:
		return m.clearedgranted_badges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeGrantedBadges:
		m.ResetGrantedBadges()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// BackupCodeMutation represents an operation that mutates the BackupCode nodes in the graph.
type BackupCodeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	code_hash     *string
	used_at       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*BackupCode, error)
	predicates    []predicate.BackupCode
}

var _ ent.Mutation = (*BackupCodeMutation)(nil)

// backupcodeOption allows management of the mutation configuration using functional options.
type backupcodeOption func(*BackupCodeMutation)

// newBackupCodeMutation creates new mutation for the BackupCode entity.
func newBackupCodeMutation(c config, op Op, opts ...backupcodeOption) *BackupCodeMutation {
	m := &BackupCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeBackupCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBackupCodeID sets the ID field of the mutation.
func withBackupCodeID(id int) backupcodeOption {
	return func(m *BackupCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *BackupCode
		)
		m.oldValue = func(ctx context.Context) (*BackupCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BackupCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBackupCode sets the old BackupCode of the mutation.
func withBackupCode(node *BackupCode) backupcodeOption {
	return func(m *BackupCodeMutation) {
		m.oldValue = func(context.Context) (*BackupCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BackupCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BackupCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BackupCodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BackupCodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BackupCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BackupCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BackupCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BackupCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BackupCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BackupCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BackupCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BackupCodeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BackupCodeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BackupCodeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[backupcode.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BackupCodeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[backupcode.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BackupCodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, backupcode.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *BackupCodeMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BackupCodeMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BackupCodeMutation) ResetUserID() {
	m.user = nil
}

// SetCodeHash sets the "code_hash" field.
func (m *BackupCodeMutation) SetCodeHash(s string) {
	m.code_hash = &s
}

// CodeHash returns the value of the "code_hash" field in the mutation.
func (m *BackupCodeMutation) CodeHash() (r string, exists bool) {
	v := m.code_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeHash returns the old "code_hash" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldCodeHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeHash: %w", err)
	}
	return oldValue.CodeHash, nil
}

// ResetCodeHash resets all changes to the "code_hash" field.
func (m *BackupCodeMutation) ResetCodeHash() {
	m.code_hash = nil
}

// SetUsedAt sets the "used_at" field.
func (m *BackupCodeMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *BackupCodeMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the BackupCode entity.
// If the BackupCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupCodeMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *BackupCodeMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[backupcode.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *BackupCodeMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[backupcode.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *BackupCodeMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, backupcode.FieldUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *BackupCodeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[backupcode.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BackupCodeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BackupCodeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BackupCodeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the BackupCodeMutation builder.
func (m *BackupCodeMutation) Where(ps ...predicate.BackupCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BackupCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BackupCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BackupCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BackupCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BackupCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BackupCode).
func (m *BackupCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BackupCodeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, backupcode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backupcode.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, backupcode.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, backupcode.FieldUserID)
	}
	if m.code_hash != nil {
		fields = append(fields, backupcode.FieldCodeHash)
	}
	if m.used_at != nil {
		fields = append(fields, backupcode.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BackupCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backupcode.FieldCreatedAt:
		return m.CreatedAt()
	case backupcode.FieldUpdatedAt:
		return m.UpdatedAt()
	case backupcode.FieldDeletedAt:
		return m.DeletedAt()
	case backupcode.FieldUserID:
		return m.UserID()
	case backupcode.FieldCodeHash:
		return m.CodeHash()
	case backupcode.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BackupCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backupcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backupcode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case backupcode.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case backupcode.FieldUserID:
		return m.OldUserID(ctx)
	case backupcode.FieldCodeHash:
		return m.OldCodeHash(ctx)
	case backupcode.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BackupCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backupcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backupcode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case backupcode.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case backupcode.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case backupcode.FieldCodeHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeHash(v)
		return nil
	case backupcode.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BackupCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BackupCodeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BackupCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BackupCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BackupCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(backupcode.FieldDeletedAt) {
		fields = append(fields, backupcode.FieldDeletedAt)
	}
	if m.FieldCleared(backupcode.FieldUsedAt) {
		fields = append(fields, backupcode.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BackupCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BackupCodeMutation) ClearField(name string) error {
	switch name {
	case backupcode.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case backupcode.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown BackupCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BackupCodeMutation) ResetField(name string) error {
	switch name {
	case backupcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backupcode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case backupcode.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case backupcode.FieldUserID:
		m.ResetUserID()
		return nil
	case backupcode.FieldCodeHash:
		m.ResetCodeHash()
		return nil
	case backupcode.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown BackupCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BackupCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, backupcode.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BackupCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case backupcode.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BackupCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BackupCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BackupCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, backupcode.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BackupCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case backupcode.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BackupCodeMutation) ClearEdge(name string) error {
	switch name {
	case backupcode.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown BackupCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BackupCodeMutation) ResetEdge(name string) error {
	switch name {
	case backupcode.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown BackupCode edge %s", name)
}

// BadgeMutation represents an operation that mutates the Badge nodes in the graph.
type BadgeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	slug                 *string
	description          *string
	icon_type            *string
	color                *string
	clearedFields        map[string]struct{}
	user_badges          map[int]struct{}
	removeduser_badges   map[int]struct{}
	cleareduser_badges   bool
	primary_users        map[int]struct{}
	removedprimary_users map[int]struct{}
	clearedprimary_users bool
	done                 bool
	oldValue             func(context.Context) (*Badge, error)
	predicates           []predicate.Badge
}

var _ ent.Mutation = (*BadgeMutation)(nil)

// badgeOption allows management of the mutation configuration using functional options.
type badgeOption func(*BadgeMutation)

// newBadgeMutation creates new mutation for the Badge entity.
func newBadgeMutation(c config, op Op, opts ...badgeOption) *BadgeMutation {
	m := &BadgeMutation{
		config:        c,
		op:            op,
		typ:           TypeBadge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBadgeID sets the ID field of the mutation.
func withBadgeID(id int) badgeOption {
	return func(m *BadgeMutation) {
		var (
			err   error
			once  sync.Once
			value *Badge
		)
		m.oldValue = func(ctx context.Context) (*Badge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Badge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBadge sets the old Badge of the mutation.
func withBadge(node *Badge) badgeOption {
	return func(m *BadgeMutation) {
		m.oldValue = func(context.Context) (*Badge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BadgeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BadgeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BadgeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BadgeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Badge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BadgeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BadgeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BadgeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BadgeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BadgeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BadgeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BadgeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BadgeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BadgeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[badge.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BadgeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[badge.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BadgeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, badge.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BadgeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BadgeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BadgeMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *BadgeMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *BadgeMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *BadgeMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *BadgeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BadgeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BadgeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[badge.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BadgeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[badge.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BadgeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, badge.FieldDescription)
}

// SetIconType sets the "icon_type" field.
func (m *BadgeMutation) SetIconType(s string) {
	m.icon_type = &s
}

// IconType returns the value of the "icon_type" field in the mutation.
func (m *BadgeMutation) IconType() (r string, exists bool) {
	v := m.icon_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIconType returns the old "icon_type" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldIconType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconType: %w", err)
	}
	return oldValue.IconType, nil
}

// ResetIconType resets all changes to the "icon_type" field.
func (m *BadgeMutation) ResetIconType() {
	m.icon_type = nil
}

// SetColor sets the "color" field.
func (m *BadgeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *BadgeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *BadgeMutation) ResetColor() {
	m.color = nil
}

// AddUserBadgeIDs adds the "user_badges" edge to the UserBadge entity by ids.
func (m *BadgeMutation) AddUserBadgeIDs(ids ...int) {
	if m.user_badges == nil {
		m.user_badges = make(map[int]struct{})
	}
	for i := range ids {
		m.user_badges[ids[i]] = struct{}{}
	}
}

// ClearUserBadges clears the "user_badges" edge to the UserBadge entity.
func (m *BadgeMutation) ClearUserBadges() {
	m.cleareduser_badges = true
}

// UserBadgesCleared reports if the "user_badges" edge to the UserBadge entity was cleared.
func (m *BadgeMutation) UserBadgesCleared() bool {
	return m.cleareduser_badges
}

// RemoveUserBadgeIDs removes the "user_badges" edge to the UserBadge entity by IDs.
func (m *BadgeMutation) RemoveUserBadgeIDs(ids ...int) {
	if m.removeduser_badges == nil {
		m.removeduser_badges = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_badges, ids[i])
		m.removeduser_badges[ids[i]] = struct{}{}
	}
}

// RemovedUserBadges returns the removed IDs of the "user_badges" edge to the UserBadge entity.
func (m *BadgeMutation) RemovedUserBadgesIDs() (ids []int) {
	for id := range m.removeduser_badges {
		ids = append(ids, id)
	}
	return
}

// UserBadgesIDs returns the "user_badges" edge IDs in the mutation.
func (m *BadgeMutation) UserBadgesIDs() (ids []int) {
	for id := range m.user_badges {
		ids = append(ids, id)
	}
	return
}

// ResetUserBadges resets all changes to the "user_badges" edge.
func (m *BadgeMutation) ResetUserBadges() {
	m.user_badges = nil
	m.cleareduser_badges = false
	m.removeduser_badges = nil
}

// AddPrimaryUserIDs adds the "primary_users" edge to the User entity by ids.
func (m *BadgeMutation) AddPrimaryUserIDs(ids ...int) {
	if m.primary_users == nil {
		m.primary_users = make(map[int]struct{})
	}
	for i := range ids {
		m.primary_users[ids[i]] = struct{}{}
	}
}

// ClearPrimaryUsers clears the "primary_users" edge to the User entity.
func (m *BadgeMutation) ClearPrimaryUsers() {
	m.clearedprimary_users = true
}

// PrimaryUsersCleared reports if the "primary_users" edge to the User entity was cleared.
func (m *BadgeMutation) PrimaryUsersCleared() bool {
	return m.clearedprimary_users
}

// RemovePrimaryUserIDs removes the "primary_users" edge to the User entity by IDs.
func (m *BadgeMutation) RemovePrimaryUserIDs(ids ...int) {
	if m.removedprimary_users == nil {
		m.removedprimary_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.primary_users, ids[i])
		m.removedprimary_users[ids[i]] = struct{}{}
	}
}

// RemovedPrimaryUsers returns the removed IDs of the "primary_users" edge to the User entity.
func (m *BadgeMutation) RemovedPrimaryUsersIDs() (ids []int) {
	for id := range m.removedprimary_users {
		ids = append(ids, id)
	}
	return
}

// PrimaryUsersIDs returns the "primary_users" edge IDs in the mutation.
func (m *BadgeMutation) PrimaryUsersIDs() (ids []int) {
	for id := range m.primary_users {
		ids = append(ids, id)
	}
	return
}

// ResetPrimaryUsers resets all changes to the "primary_users" edge.
func (m *BadgeMutation) ResetPrimaryUsers() {
	m.primary_users = nil
	m.clearedprimary_users = false
	m.removedprimary_users = nil
}

// Where appends a list predicates to the BadgeMutation builder.
func (m *BadgeMutation) Where(ps ...predicate.Badge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BadgeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BadgeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Badge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BadgeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BadgeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Badge).
func (m *BadgeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BadgeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, badge.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, badge.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, badge.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, badge.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, badge.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, badge.FieldDescription)
	}
	if m.icon_type != nil {
		fields = append(fields, badge.FieldIconType)
	}
	if m.color != nil {
		fields = append(fields, badge.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BadgeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case badge.FieldCreatedAt:
		return m.CreatedAt()
	case badge.FieldUpdatedAt:
		return m.UpdatedAt()
	case badge.FieldDeletedAt:
		return m.DeletedAt()
	case badge.FieldName:
		return m.Name()
	case badge.FieldSlug:
		return m.Slug()
	case badge.FieldDescription:
		return m.Description()
	case badge.FieldIconType:
		return m.IconType()
	case badge.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BadgeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case badge.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case badge.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case badge.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case badge.FieldName:
		return m.OldName(ctx)
	case badge.FieldSlug:
		return m.OldSlug(ctx)
	case badge.FieldDescription:
		return m.OldDescription(ctx)
	case badge.FieldIconType:
		return m.OldIconType(ctx)
	case badge.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Badge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BadgeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case badge.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case badge.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case badge.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case badge.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case badge.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case badge.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case badge.FieldIconType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconType(v)
		return nil
	case badge.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Badge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BadgeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BadgeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BadgeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Badge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BadgeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(badge.FieldDeletedAt) {
		fields = append(fields, badge.FieldDeletedAt)
	}
	if m.FieldCleared(badge.FieldDescription) {
		fields = append(fields, badge.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BadgeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BadgeMutation) ClearField(name string) error {
	switch name {
	case badge.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case badge.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Badge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BadgeMutation) ResetField(name string) error {
	switch name {
	case badge.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case badge.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case badge.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case badge.FieldName:
		m.ResetName()
		return nil
	case badge.FieldSlug:
		m.ResetSlug()
		return nil
	case badge.FieldDescription:
		m.ResetDescription()
		return nil
	case badge.FieldIconType:
		m.ResetIconType()
		return nil
	case badge.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Badge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BadgeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_badges != nil {
		edges = append(edges, badge.EdgeUserBadges)
	}
	if m.primary_users != nil {
		edges = append(edges, badge.EdgePrimaryUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BadgeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case badge.EdgeUserBadges:
		ids := make([]ent.Value, 0, len(m.user_badges))
		for id := range m.user_badges {
			ids = append(ids, id)
		}
		return ids
	case badge.EdgePrimaryUsers:
		ids := make([]ent.Value, 0, len(m.primary_users))
		for id := range m.primary_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BadgeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_badges != nil {
		edges = append(edges, badge.EdgeUserBadges)
	}
	if m.removedprimary_users != nil {
		edges = append(edges, badge.EdgePrimaryUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BadgeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case badge.EdgeUserBadges:
		ids := make([]ent.Value, 0, len(m.removeduser_badges))
		for id := range m.removeduser_badges {
			ids = append(ids, id)
		}
		return ids
	case badge.EdgePrimaryUsers:
		ids := make([]ent.Value, 0, len(m.removedprimary_users))
		for id := range m.removedprimary_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BadgeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_badges {
		edges = append(edges, badge.EdgeUserBadges)
	}
	if m.clearedprimary_users {
		edges = append(edges, badge.EdgePrimaryUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BadgeMutation) EdgeCleared(name string) bool {
	switch name {
	case badge.EdgeUserBadges:
		return m.cleareduser_badges
	case badge.EdgePrimaryUsers:
		return m.clearedprimary_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BadgeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Badge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BadgeMutation) ResetEdge(name string) error {
	switch name {
	case badge.EdgeUserBadges:
		m.ResetUserBadges()
		return nil
	case badge.EdgePrimaryUsers:
		m.ResetPrimaryUsers()
		return nil
	}
	return fmt.Errorf("unknown Badge edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	slug           *string
	name           *string
	description    *string
	clearedFields  map[string]struct{}
	threads        map[int]struct{}
	removedthreads map[int]struct{}
	clearedthreads bool
	done           bool
	oldValue       func(context.Context) (*Category, error)
	predicates     []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[category.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[category.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, category.FieldDeletedAt)
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *CategoryMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *CategoryMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *CategoryMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *CategoryMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *CategoryMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *CategoryMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *CategoryMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldDeletedAt:
		return m.DeletedAt()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldName:
		return m.Name()
	case category.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldDeletedAt) {
		fields = append(fields, category.FieldDeletedAt)
	}
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.threads != nil {
		edges = append(edges, category.EdgeThreads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedthreads != nil {
		edges = append(edges, category.EdgeThreads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedthreads {
		edges = append(edges, category.EdgeThreads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeThreads:
		return m.clearedthreads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeThreads:
		m.ResetThreads()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// ChainCursorMutation represents an operation that mutates the ChainCursor nodes in the graph.
type ChainCursorMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	chain_id          *uint64
	addchain_id       *int64
	last_processed    *uint64
	addlast_processed *int64
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ChainCursor, error)
	predicates        []predicate.ChainCursor
}

var _ ent.Mutation = (*ChainCursorMutation)(nil)

// chaincursorOption allows management of the mutation configuration using functional options.
type chaincursorOption func(*ChainCursorMutation)

// newChainCursorMutation creates new mutation for the ChainCursor entity.
func newChainCursorMutation(c config, op Op, opts ...chaincursorOption) *ChainCursorMutation {
	m := &ChainCursorMutation{
		config:        c,
		op:            op,
		typ:           TypeChainCursor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChainCursorID sets the ID field of the mutation.
func withChainCursorID(id int) chaincursorOption {
	return func(m *ChainCursorMutation) {
		var (
			err   error
			once  sync.Once
			value *ChainCursor
		)
		m.oldValue = func(ctx context.Context) (*ChainCursor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChainCursor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChainCursor sets the old ChainCursor of the mutation.
func withChainCursor(node *ChainCursor) chaincursorOption {
	return func(m *ChainCursorMutation) {
		m.oldValue = func(context.Context) (*ChainCursor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChainCursorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChainCursorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChainCursorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChainCursorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChainCursor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ChainCursorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChainCursorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ChainCursor entity.
// If the ChainCursor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainCursorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChainCursorMutation) ResetName() {
	m.name = nil
}

// SetChainID sets the "chain_id" field.
func (m *ChainCursorMutation) SetChainID(u uint64) {
	m.chain_id = &u
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *ChainCursorMutation) ChainID() (r uint64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the ChainCursor entity.
// If the ChainCursor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainCursorMutation) OldChainID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds u to the "chain_id" field.
func (m *ChainCursorMutation) AddChainID(u int64) {
	if m.addchain_id != nil {
		*m.addchain_id += u
	} else {
		m.addchain_id = &u
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *ChainCursorMutation) AddedChainID() (r int64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *ChainCursorMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
}

// SetLastProcessed sets the "last_processed" field.
func (m *ChainCursorMutation) SetLastProcessed(u uint64) {
	m.last_processed = &u
	m.addlast_processed = nil
}

// LastProcessed returns the value of the "last_processed" field in the mutation.
func (m *ChainCursorMutation) LastProcessed() (r uint64, exists bool) {
	v := m.last_processed
	if v == nil {
		return
	}
	return *v, true
}

// OldLastProcessed returns the old "last_processed" field's value of the ChainCursor entity.
// If the ChainCursor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainCursorMutation) OldLastProcessed(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastProcessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastProcessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastProcessed: %w", err)
	}
	return oldValue.LastProcessed, nil
}

// AddLastProcessed adds u to the "last_processed" field.
func (m *ChainCursorMutation) AddLastProcessed(u int64) {
	if m.addlast_processed != nil {
		*m.addlast_processed += u
	} else {
		m.addlast_processed = &u
	}
}

// AddedLastProcessed returns the value that was added to the "last_processed" field in this mutation.
func (m *ChainCursorMutation) AddedLastProcessed() (r int64, exists bool) {
	v := m.addlast_processed
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastProcessed resets all changes to the "last_processed" field.
func (m *ChainCursorMutation) ResetLastProcessed() {
	m.last_processed = nil
	m.addlast_processed = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChainCursorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChainCursorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChainCursor entity.
// If the ChainCursor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainCursorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChainCursorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChainCursorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChainCursorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChainCursor entity.
// If the ChainCursor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainCursorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChainCursorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ChainCursorMutation builder.
func (m *ChainCursorMutation) Where(ps ...predicate.ChainCursor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChainCursorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChainCursorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChainCursor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChainCursorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChainCursorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChainCursor).
func (m *ChainCursorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChainCursorMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, chaincursor.FieldName)
	}
	if m.chain_id != nil {
		fields = append(fields, chaincursor.FieldChainID)
	}
	if m.last_processed != nil {
		fields = append(fields, chaincursor.FieldLastProcessed)
	}
	if m.created_at != nil {
		fields = append(fields, chaincursor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, chaincursor.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChainCursorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chaincursor.FieldName:
		return m.Name()
	case chaincursor.FieldChainID:
		return m.ChainID()
	case chaincursor.FieldLastProcessed:
		return m.LastProcessed()
	case chaincursor.FieldCreatedAt:
		return m.CreatedAt()
	case chaincursor.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChainCursorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chaincursor.FieldName:
		return m.OldName(ctx)
	case chaincursor.FieldChainID:
		return m.OldChainID(ctx)
	case chaincursor.FieldLastProcessed:
		return m.OldLastProcessed(ctx)
	case chaincursor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chaincursor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ChainCursor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChainCursorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chaincursor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case chaincursor.FieldChainID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case chaincursor.FieldLastProcessed:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastProcessed(v)
		return nil
	case chaincursor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chaincursor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChainCursor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChainCursorMutation) AddedFields() []string {
	var fields []string
	if m.addchain_id != nil {
		fields = append(fields, chaincursor.FieldChainID)
	}
	if m.addlast_processed != nil {
		fields = append(fields, chaincursor.FieldLastProcessed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChainCursorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chaincursor.FieldChainID:
		return m.AddedChainID()
	case chaincursor.FieldLastProcessed:
		return m.AddedLastProcessed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChainCursorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chaincursor.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	case chaincursor.FieldLastProcessed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastProcessed(v)
		return nil
	}
	return fmt.Errorf("unknown ChainCursor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChainCursorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChainCursorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChainCursorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChainCursor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChainCursorMutation) ResetField(name string) error {
	switch name {
	case chaincursor.FieldName:
		m.ResetName()
		return nil
	case chaincursor.FieldChainID:
		m.ResetChainID()
		return nil
	case chaincursor.FieldLastProcessed:
		m.ResetLastProcessed()
		return nil
	case chaincursor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chaincursor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ChainCursor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChainCursorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChainCursorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChainCursorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChainCursorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChainCursorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChainCursorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChainCursorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ChainCursor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChainCursorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ChainCursor edge %s", name)
}

// CredentialMutation represents an operation that mutates the Credential nodes in the graph.
type CredentialMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	platform      *string
	description   *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Credential, error)
	predicates    []predicate.Credential
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// credentialOption allows management of the mutation configuration using functional options.
type credentialOption func(*CredentialMutation)

// newCredentialMutation creates new mutation for the Credential entity.
func newCredentialMutation(c config, op Op, opts ...credentialOption) *CredentialMutation {
	m := &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialID sets the ID field of the mutation.
func withCredentialID(id int) credentialOption {
	return func(m *CredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *Credential
		)
		m.oldValue = func(ctx context.Context) (*Credential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredential sets the old Credential of the mutation.
func withCredential(node *Credential) credentialOption {
	return func(m *CredentialMutation) {
		m.oldValue = func(context.Context) (*Credential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CredentialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CredentialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CredentialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CredentialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CredentialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CredentialMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CredentialMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CredentialMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[credential.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CredentialMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[credential.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CredentialMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, credential.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *CredentialMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CredentialMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CredentialMutation) ResetUserID() {
	m.user = nil
}

// SetPlatform sets the "platform" field.
func (m *CredentialMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *CredentialMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ClearPlatform clears the value of the "platform" field.
func (m *CredentialMutation) ClearPlatform() {
	m.platform = nil
	m.clearedFields[credential.FieldPlatform] = struct{}{}
}

// PlatformCleared returns if the "platform" field was cleared in this mutation.
func (m *CredentialMutation) PlatformCleared() bool {
	_, ok := m.clearedFields[credential.FieldPlatform]
	return ok
}

// ResetPlatform resets all changes to the "platform" field.
func (m *CredentialMutation) ResetPlatform() {
	m.platform = nil
	delete(m.clearedFields, credential.FieldPlatform)
}

// SetDescription sets the "description" field.
func (m *CredentialMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CredentialMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CredentialMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[credential.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CredentialMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[credential.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CredentialMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, credential.FieldDescription)
}

// ClearUser clears the "user" edge to the User entity.
func (m *CredentialMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[credential.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CredentialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CredentialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CredentialMutation builder.
func (m *CredentialMutation) Where(ps ...predicate.Credential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, credential.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, credential.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, credential.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, credential.FieldUserID)
	}
	if m.platform != nil {
		fields = append(fields, credential.FieldPlatform)
	}
	if m.description != nil {
		fields = append(fields, credential.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldCreatedAt:
		return m.CreatedAt()
	case credential.FieldUpdatedAt:
		return m.UpdatedAt()
	case credential.FieldDeletedAt:
		return m.DeletedAt()
	case credential.FieldUserID:
		return m.UserID()
	case credential.FieldPlatform:
		return m.Platform()
	case credential.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case credential.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case credential.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case credential.FieldUserID:
		return m.OldUserID(ctx)
	case credential.FieldPlatform:
		return m.OldPlatform(ctx)
	case credential.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Credential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case credential.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case credential.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case credential.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case credential.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case credential.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credential.FieldDeletedAt) {
		fields = append(fields, credential.FieldDeletedAt)
	}
	if m.FieldCleared(credential.FieldPlatform) {
		fields = append(fields, credential.FieldPlatform)
	}
	if m.FieldCleared(credential.FieldDescription) {
		fields = append(fields, credential.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	switch name {
	case credential.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case credential.FieldPlatform:
		m.ClearPlatform()
		return nil
	case credential.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case credential.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case credential.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case credential.FieldUserID:
		m.ResetUserID()
		return nil
	case credential.FieldPlatform:
		m.ResetPlatform()
		return nil
	case credential.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, credential.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, credential.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case credential.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	switch name {
	case credential.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	switch name {
	case credential.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Credential edge %s", name)
}

// DeviceFingerprintMutation represents an operation that mutates the DeviceFingerprint nodes in the graph.
type DeviceFingerprintMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	fingerprint_hash *string
	ip_address       *string
	user_agent       *string
	account_count    *int
	addaccount_count *int
	last_seen_at     *time.Time
	blocked          *bool
	block_reason     *string
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*DeviceFingerprint, error)
	predicates       []predicate.DeviceFingerprint
}

var _ ent.Mutation = (*DeviceFingerprintMutation)(nil)

// devicefingerprintOption allows management of the mutation configuration using functional options.
type devicefingerprintOption func(*DeviceFingerprintMutation)

// newDeviceFingerprintMutation creates new mutation for the DeviceFingerprint entity.
func newDeviceFingerprintMutation(c config, op Op, opts ...devicefingerprintOption) *DeviceFingerprintMutation {
	m := &DeviceFingerprintMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceFingerprint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceFingerprintID sets the ID field of the mutation.
func withDeviceFingerprintID(id int) devicefingerprintOption {
	return func(m *DeviceFingerprintMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceFingerprint
		)
		m.oldValue = func(ctx context.Context) (*DeviceFingerprint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceFingerprint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceFingerprint sets the old DeviceFingerprint of the mutation.
func withDeviceFingerprint(node *DeviceFingerprint) devicefingerprintOption {
	return func(m *DeviceFingerprintMutation) {
		m.oldValue = func(context.Context) (*DeviceFingerprint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceFingerprintMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceFingerprintMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceFingerprintMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceFingerprintMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceFingerprint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceFingerprintMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceFingerprintMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceFingerprintMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceFingerprintMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceFingerprintMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceFingerprintMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceFingerprintMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceFingerprintMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DeviceFingerprintMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[devicefingerprint.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DeviceFingerprintMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[devicefingerprint.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceFingerprintMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, devicefingerprint.FieldDeletedAt)
}

// SetFingerprintHash sets the "fingerprint_hash" field.
func (m *DeviceFingerprintMutation) SetFingerprintHash(s string) {
	m.fingerprint_hash = &s
}

// FingerprintHash returns the value of the "fingerprint_hash" field in the mutation.
func (m *DeviceFingerprintMutation) FingerprintHash() (r string, exists bool) {
	v := m.fingerprint_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprintHash returns the old "fingerprint_hash" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldFingerprintHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprintHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprintHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprintHash: %w", err)
	}
	return oldValue.FingerprintHash, nil
}

// ResetFingerprintHash resets all changes to the "fingerprint_hash" field.
func (m *DeviceFingerprintMutation) ResetFingerprintHash() {
	m.fingerprint_hash = nil
}

// SetUserID sets the "user_id" field.
func (m *DeviceFingerprintMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DeviceFingerprintMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *DeviceFingerprintMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[devicefingerprint.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *DeviceFingerprintMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[devicefingerprint.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DeviceFingerprintMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, devicefingerprint.FieldUserID)
}

// SetIPAddress sets the "ip_address" field.
func (m *DeviceFingerprintMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *DeviceFingerprintMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *DeviceFingerprintMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[devicefingerprint.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *DeviceFingerprintMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[devicefingerprint.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *DeviceFingerprintMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, devicefingerprint.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *DeviceFingerprintMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *DeviceFingerprintMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *DeviceFingerprintMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[devicefingerprint.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *DeviceFingerprintMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[devicefingerprint.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *DeviceFingerprintMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, devicefingerprint.FieldUserAgent)
}

// SetAccountCount sets the "account_count" field.
func (m *DeviceFingerprintMutation) SetAccountCount(i int) {
	m.account_count = &i
	m.addaccount_count = nil
}

// AccountCount returns the value of the "account_count" field in the mutation.
func (m *DeviceFingerprintMutation) AccountCount() (r int, exists bool) {
	v := m.account_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountCount returns the old "account_count" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldAccountCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountCount: %w", err)
	}
	return oldValue.AccountCount, nil
}

// AddAccountCount adds i to the "account_count" field.
func (m *DeviceFingerprintMutation) AddAccountCount(i int) {
	if m.addaccount_count != nil {
		*m.addaccount_count += i
	} else {
		m.addaccount_count = &i
	}
}

// AddedAccountCount returns the value that was added to the "account_count" field in this mutation.
func (m *DeviceFingerprintMutation) AddedAccountCount() (r int, exists bool) {
	v := m.addaccount_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountCount resets all changes to the "account_count" field.
func (m *DeviceFingerprintMutation) ResetAccountCount() {
	m.account_count = nil
	m.addaccount_count = nil
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *DeviceFingerprintMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *DeviceFingerprintMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldLastSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *DeviceFingerprintMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
}

// SetBlocked sets the "blocked" field.
func (m *DeviceFingerprintMutation) SetBlocked(b bool) {
	m.blocked = &b
}

// Blocked returns the value of the "blocked" field in the mutation.
func (m *DeviceFingerprintMutation) Blocked() (r bool, exists bool) {
	v := m.blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldBlocked returns the old "blocked" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldBlocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlocked: %w", err)
	}
	return oldValue.Blocked, nil
}

// ResetBlocked resets all changes to the "blocked" field.
func (m *DeviceFingerprintMutation) ResetBlocked() {
	m.blocked = nil
}

// SetBlockReason sets the "block_reason" field.
func (m *DeviceFingerprintMutation) SetBlockReason(s string) {
	m.block_reason = &s
}

// BlockReason returns the value of the "block_reason" field in the mutation.
func (m *DeviceFingerprintMutation) BlockReason() (r string, exists bool) {
	v := m.block_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockReason returns the old "block_reason" field's value of the DeviceFingerprint entity.
// If the DeviceFingerprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceFingerprintMutation) OldBlockReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockReason: %w", err)
	}
	return oldValue.BlockReason, nil
}

// ClearBlockReason clears the value of the "block_reason" field.
func (m *DeviceFingerprintMutation) ClearBlockReason() {
	m.block_reason = nil
	m.clearedFields[devicefingerprint.FieldBlockReason] = struct{}{}
}

// BlockReasonCleared returns if the "block_reason" field was cleared in this mutation.
func (m *DeviceFingerprintMutation) BlockReasonCleared() bool {
	_, ok := m.clearedFields[devicefingerprint.FieldBlockReason]
	return ok
}

// ResetBlockReason resets all changes to the "block_reason" field.
func (m *DeviceFingerprintMutation) ResetBlockReason() {
	m.block_reason = nil
	delete(m.clearedFields, devicefingerprint.FieldBlockReason)
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeviceFingerprintMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[devicefingerprint.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeviceFingerprintMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeviceFingerprintMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeviceFingerprintMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the DeviceFingerprintMutation builder.
func (m *DeviceFingerprintMutation) Where(ps ...predicate.DeviceFingerprint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceFingerprintMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceFingerprintMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceFingerprint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceFingerprintMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceFingerprintMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceFingerprint).
func (m *DeviceFingerprintMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceFingerprintMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, devicefingerprint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, devicefingerprint.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, devicefingerprint.FieldDeletedAt)
	}
	if m.fingerprint_hash != nil {
		fields = append(fields, devicefingerprint.FieldFingerprintHash)
	}
	if m.user != nil {
		fields = append(fields, devicefingerprint.FieldUserID)
	}
	if m.ip_address != nil {
		fields = append(fields, devicefingerprint.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, devicefingerprint.FieldUserAgent)
	}
	if m.account_count != nil {
		fields = append(fields, devicefingerprint.FieldAccountCount)
	}
	if m.last_seen_at != nil {
		fields = append(fields, devicefingerprint.FieldLastSeenAt)
	}
	if m.blocked != nil {
		fields = append(fields, devicefingerprint.FieldBlocked)
	}
	if m.block_reason != nil {
		fields = append(fields, devicefingerprint.FieldBlockReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceFingerprintMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicefingerprint.FieldCreatedAt:
		return m.CreatedAt()
	case devicefingerprint.FieldUpdatedAt:
		return m.UpdatedAt()
	case devicefingerprint.FieldDeletedAt:
		return m.DeletedAt()
	case devicefingerprint.FieldFingerprintHash:
		return m.FingerprintHash()
	case devicefingerprint.FieldUserID:
		return m.UserID()
	case devicefingerprint.FieldIPAddress:
		return m.IPAddress()
	case devicefingerprint.FieldUserAgent:
		return m.UserAgent()
	case devicefingerprint.FieldAccountCount:
		return m.AccountCount()
	case devicefingerprint.FieldLastSeenAt:
		return m.LastSeenAt()
	case devicefingerprint.FieldBlocked:
		return m.Blocked()
	case devicefingerprint.FieldBlockReason:
		return m.BlockReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceFingerprintMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicefingerprint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case devicefingerprint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case devicefingerprint.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case devicefingerprint.FieldFingerprintHash:
		return m.OldFingerprintHash(ctx)
	case devicefingerprint.FieldUserID:
		return m.OldUserID(ctx)
	case devicefingerprint.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case devicefingerprint.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case devicefingerprint.FieldAccountCount:
		return m.OldAccountCount(ctx)
	case devicefingerprint.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	case devicefingerprint.FieldBlocked:
		return m.OldBlocked(ctx)
	case devicefingerprint.FieldBlockReason:
		return m.OldBlockReason(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceFingerprint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceFingerprintMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicefingerprint.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case devicefingerprint.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case devicefingerprint.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case devicefingerprint.FieldFingerprintHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprintHash(v)
		return nil
	case devicefingerprint.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case devicefingerprint.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case devicefingerprint.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case devicefingerprint.FieldAccountCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountCount(v)
		return nil
	case devicefingerprint.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	case devicefingerprint.FieldBlocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlocked(v)
		return nil
	case devicefingerprint.FieldBlockReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockReason(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceFingerprintMutation) AddedFields() []string {
	var fields []string
	if m.addaccount_count != nil {
		fields = append(fields, devicefingerprint.FieldAccountCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceFingerprintMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case devicefingerprint.FieldAccountCount:
		return m.AddedAccountCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceFingerprintMutation) AddField(name string, value ent.Value) error {
	switch name {
	case devicefingerprint.FieldAccountCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountCount(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceFingerprintMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(devicefingerprint.FieldDeletedAt) {
		fields = append(fields, devicefingerprint.FieldDeletedAt)
	}
	if m.FieldCleared(devicefingerprint.FieldUserID) {
		fields = append(fields, devicefingerprint.FieldUserID)
	}
	if m.FieldCleared(devicefingerprint.FieldIPAddress) {
		fields = append(fields, devicefingerprint.FieldIPAddress)
	}
	if m.FieldCleared(devicefingerprint.FieldUserAgent) {
		fields = append(fields, devicefingerprint.FieldUserAgent)
	}
	if m.FieldCleared(devicefingerprint.FieldBlockReason) {
		fields = append(fields, devicefingerprint.FieldBlockReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceFingerprintMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceFingerprintMutation) ClearField(name string) error {
	switch name {
	case devicefingerprint.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case devicefingerprint.FieldUserID:
		m.ClearUserID()
		return nil
	case devicefingerprint.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case devicefingerprint.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case devicefingerprint.FieldBlockReason:
		m.ClearBlockReason()
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceFingerprintMutation) ResetField(name string) error {
	switch name {
	case devicefingerprint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case devicefingerprint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case devicefingerprint.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case devicefingerprint.FieldFingerprintHash:
		m.ResetFingerprintHash()
		return nil
	case devicefingerprint.FieldUserID:
		m.ResetUserID()
		return nil
	case devicefingerprint.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case devicefingerprint.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case devicefingerprint.FieldAccountCount:
		m.ResetAccountCount()
		return nil
	case devicefingerprint.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	case devicefingerprint.FieldBlocked:
		m.ResetBlocked()
		return nil
	case devicefingerprint.FieldBlockReason:
		m.ResetBlockReason()
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceFingerprintMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, devicefingerprint.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceFingerprintMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicefingerprint.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceFingerprintMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceFingerprintMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceFingerprintMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, devicefingerprint.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceFingerprintMutation) EdgeCleared(name string) bool {
	switch name {
	case devicefingerprint.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceFingerprintMutation) ClearEdge(name string) error {
	switch name {
	case devicefingerprint.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceFingerprintMutation) ResetEdge(name string) error {
	switch name {
	case devicefingerprint.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown DeviceFingerprint edge %s", name)
}

// DeviceUserMappingMutation represents an operation that mutates the DeviceUserMapping nodes in the graph.
type DeviceUserMappingMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	fingerprint_hash *string
	first_seen_at    *time.Time
	last_seen_at     *time.Time
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*DeviceUserMapping, error)
	predicates       []predicate.DeviceUserMapping
}

var _ ent.Mutation = (*DeviceUserMappingMutation)(nil)

// deviceusermappingOption allows management of the mutation configuration using functional options.
type deviceusermappingOption func(*DeviceUserMappingMutation)

// newDeviceUserMappingMutation creates new mutation for the DeviceUserMapping entity.
func newDeviceUserMappingMutation(c config, op Op, opts ...deviceusermappingOption) *DeviceUserMappingMutation {
	m := &DeviceUserMappingMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceUserMapping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceUserMappingID sets the ID field of the mutation.
func withDeviceUserMappingID(id int) deviceusermappingOption {
	return func(m *DeviceUserMappingMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceUserMapping
		)
		m.oldValue = func(ctx context.Context) (*DeviceUserMapping, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceUserMapping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceUserMapping sets the old DeviceUserMapping of the mutation.
func withDeviceUserMapping(node *DeviceUserMapping) deviceusermappingOption {
	return func(m *DeviceUserMappingMutation) {
		m.oldValue = func(context.Context) (*DeviceUserMapping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceUserMappingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceUserMappingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceUserMappingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceUserMappingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceUserMapping.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceUserMappingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceUserMappingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceUserMappingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceUserMappingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceUserMappingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceUserMappingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceUserMappingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceUserMappingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DeviceUserMappingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[deviceusermapping.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DeviceUserMappingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[deviceusermapping.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceUserMappingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, deviceusermapping.FieldDeletedAt)
}

// SetFingerprintHash sets the "fingerprint_hash" field.
func (m *DeviceUserMappingMutation) SetFingerprintHash(s string) {
	m.fingerprint_hash = &s
}

// FingerprintHash returns the value of the "fingerprint_hash" field in the mutation.
func (m *DeviceUserMappingMutation) FingerprintHash() (r string, exists bool) {
	v := m.fingerprint_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprintHash returns the old "fingerprint_hash" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldFingerprintHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprintHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprintHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprintHash: %w", err)
	}
	return oldValue.FingerprintHash, nil
}

// ResetFingerprintHash resets all changes to the "fingerprint_hash" field.
func (m *DeviceUserMappingMutation) ResetFingerprintHash() {
	m.fingerprint_hash = nil
}

// SetUserID sets the "user_id" field.
func (m *DeviceUserMappingMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DeviceUserMappingMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DeviceUserMappingMutation) ResetUserID() {
	m.user = nil
}

// SetFirstSeenAt sets the "first_seen_at" field.
func (m *DeviceUserMappingMutation) SetFirstSeenAt(t time.Time) {
	m.first_seen_at = &t
}

// FirstSeenAt returns the value of the "first_seen_at" field in the mutation.
func (m *DeviceUserMappingMutation) FirstSeenAt() (r time.Time, exists bool) {
	v := m.first_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstSeenAt returns the old "first_seen_at" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldFirstSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstSeenAt: %w", err)
	}
	return oldValue.FirstSeenAt, nil
}

// ResetFirstSeenAt resets all changes to the "first_seen_at" field.
func (m *DeviceUserMappingMutation) ResetFirstSeenAt() {
	m.first_seen_at = nil
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *DeviceUserMappingMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *DeviceUserMappingMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the DeviceUserMapping entity.
// If the DeviceUserMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceUserMappingMutation) OldLastSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *DeviceUserMappingMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeviceUserMappingMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[deviceusermapping.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeviceUserMappingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeviceUserMappingMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeviceUserMappingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the DeviceUserMappingMutation builder.
func (m *DeviceUserMappingMutation) Where(ps ...predicate.DeviceUserMapping) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceUserMappingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceUserMappingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceUserMapping, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceUserMappingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceUserMappingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceUserMapping).
func (m *DeviceUserMappingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceUserMappingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, deviceusermapping.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceusermapping.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, deviceusermapping.FieldDeletedAt)
	}
	if m.fingerprint_hash != nil {
		fields = append(fields, deviceusermapping.FieldFingerprintHash)
	}
	if m.user != nil {
		fields = append(fields, deviceusermapping.FieldUserID)
	}
	if m.first_seen_at != nil {
		fields = append(fields, deviceusermapping.FieldFirstSeenAt)
	}
	if m.last_seen_at != nil {
		fields = append(fields, deviceusermapping.FieldLastSeenAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceUserMappingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceusermapping.FieldCreatedAt:
		return m.CreatedAt()
	case deviceusermapping.FieldUpdatedAt:
		return m.UpdatedAt()
	case deviceusermapping.FieldDeletedAt:
		return m.DeletedAt()
	case deviceusermapping.FieldFingerprintHash:
		return m.FingerprintHash()
	case deviceusermapping.FieldUserID:
		return m.UserID()
	case deviceusermapping.FieldFirstSeenAt:
		return m.FirstSeenAt()
	case deviceusermapping.FieldLastSeenAt:
		return m.LastSeenAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceUserMappingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceusermapping.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceusermapping.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deviceusermapping.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case deviceusermapping.FieldFingerprintHash:
		return m.OldFingerprintHash(ctx)
	case deviceusermapping.FieldUserID:
		return m.OldUserID(ctx)
	case deviceusermapping.FieldFirstSeenAt:
		return m.OldFirstSeenAt(ctx)
	case deviceusermapping.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceUserMapping field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceUserMappingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceusermapping.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceusermapping.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deviceusermapping.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case deviceusermapping.FieldFingerprintHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprintHash(v)
		return nil
	case deviceusermapping.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case deviceusermapping.FieldFirstSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstSeenAt(v)
		return nil
	case deviceusermapping.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceUserMapping field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceUserMappingMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceUserMappingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceUserMappingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceUserMapping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceUserMappingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceusermapping.FieldDeletedAt) {
		fields = append(fields, deviceusermapping.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceUserMappingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceUserMappingMutation) ClearField(name string) error {
	switch name {
	case deviceusermapping.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceUserMapping nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceUserMappingMutation) ResetField(name string) error {
	switch name {
	case deviceusermapping.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceusermapping.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deviceusermapping.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case deviceusermapping.FieldFingerprintHash:
		m.ResetFingerprintHash()
		return nil
	case deviceusermapping.FieldUserID:
		m.ResetUserID()
		return nil
	case deviceusermapping.FieldFirstSeenAt:
		m.ResetFirstSeenAt()
		return nil
	case deviceusermapping.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceUserMapping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceUserMappingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, deviceusermapping.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceUserMappingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceusermapping.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceUserMappingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceUserMappingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceUserMappingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, deviceusermapping.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceUserMappingMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceusermapping.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceUserMappingMutation) ClearEdge(name string) error {
	switch name {
	case deviceusermapping.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown DeviceUserMapping unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceUserMappingMutation) ResetEdge(name string) error {
	switch name {
	case deviceusermapping.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown DeviceUserMapping edge %s", name)
}

// EmailVerificationTokenMutation represents an operation that mutates the EmailVerificationToken nodes in the graph.
type EmailVerificationTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token_hash    *string
	expires_at    *time.Time
	used_at       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*EmailVerificationToken, error)
	predicates    []predicate.EmailVerificationToken
}

var _ ent.Mutation = (*EmailVerificationTokenMutation)(nil)

// emailverificationtokenOption allows management of the mutation configuration using functional options.
type emailverificationtokenOption func(*EmailVerificationTokenMutation)

// newEmailVerificationTokenMutation creates new mutation for the EmailVerificationToken entity.
func newEmailVerificationTokenMutation(c config, op Op, opts ...emailverificationtokenOption) *EmailVerificationTokenMutation {
	m := &EmailVerificationTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailVerificationToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailVerificationTokenID sets the ID field of the mutation.
func withEmailVerificationTokenID(id int) emailverificationtokenOption {
	return func(m *EmailVerificationTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailVerificationToken
		)
		m.oldValue = func(ctx context.Context) (*EmailVerificationToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailVerificationToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailVerificationToken sets the old EmailVerificationToken of the mutation.
func withEmailVerificationToken(node *EmailVerificationToken) emailverificationtokenOption {
	return func(m *EmailVerificationTokenMutation) {
		m.oldValue = func(context.Context) (*EmailVerificationToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailVerificationTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailVerificationTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailVerificationTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailVerificationTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailVerificationToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailVerificationTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailVerificationTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailVerificationTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailVerificationTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailVerificationTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailVerificationTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmailVerificationTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmailVerificationTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmailVerificationTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[emailverificationtoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmailVerificationTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[emailverificationtoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmailVerificationTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, emailverificationtoken.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *EmailVerificationTokenMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EmailVerificationTokenMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EmailVerificationTokenMutation) ResetUserID() {
	m.user = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *EmailVerificationTokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *EmailVerificationTokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *EmailVerificationTokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *EmailVerificationTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *EmailVerificationTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *EmailVerificationTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsedAt sets the "used_at" field.
func (m *EmailVerificationTokenMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *EmailVerificationTokenMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the EmailVerificationToken entity.
// If the EmailVerificationToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailVerificationTokenMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *EmailVerificationTokenMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[emailverificationtoken.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *EmailVerificationTokenMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[emailverificationtoken.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *EmailVerificationTokenMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, emailverificationtoken.FieldUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *EmailVerificationTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[emailverificationtoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EmailVerificationTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EmailVerificationTokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EmailVerificationTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the EmailVerificationTokenMutation builder.
func (m *EmailVerificationTokenMutation) Where(ps ...predicate.EmailVerificationToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailVerificationTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailVerificationTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailVerificationToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailVerificationTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailVerificationTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailVerificationToken).
func (m *EmailVerificationTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailVerificationTokenMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, emailverificationtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailverificationtoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, emailverificationtoken.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, emailverificationtoken.FieldUserID)
	}
	if m.token_hash != nil {
		fields = append(fields, emailverificationtoken.FieldTokenHash)
	}
	if m.expires_at != nil {
		fields = append(fields, emailverificationtoken.FieldExpiresAt)
	}
	if m.used_at != nil {
		fields = append(fields, emailverificationtoken.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailVerificationTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		return m.CreatedAt()
	case emailverificationtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailverificationtoken.FieldDeletedAt:
		return m.DeletedAt()
	case emailverificationtoken.FieldUserID:
		return m.UserID()
	case emailverificationtoken.FieldTokenHash:
		return m.TokenHash()
	case emailverificationtoken.FieldExpiresAt:
		return m.ExpiresAt()
	case emailverificationtoken.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailVerificationTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailverificationtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailverificationtoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case emailverificationtoken.FieldUserID:
		return m.OldUserID(ctx)
	case emailverificationtoken.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case emailverificationtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case emailverificationtoken.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailVerificationToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailVerificationTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailverificationtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailverificationtoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case emailverificationtoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case emailverificationtoken.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case emailverificationtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case emailverificationtoken.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailVerificationTokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailVerificationTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailVerificationTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailVerificationToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailVerificationTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailverificationtoken.FieldDeletedAt) {
		fields = append(fields, emailverificationtoken.FieldDeletedAt)
	}
	if m.FieldCleared(emailverificationtoken.FieldUsedAt) {
		fields = append(fields, emailverificationtoken.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailVerificationTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailVerificationTokenMutation) ClearField(name string) error {
	switch name {
	case emailverificationtoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case emailverificationtoken.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailVerificationTokenMutation) ResetField(name string) error {
	switch name {
	case emailverificationtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailverificationtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailverificationtoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case emailverificationtoken.FieldUserID:
		m.ResetUserID()
		return nil
	case emailverificationtoken.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case emailverificationtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case emailverificationtoken.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailVerificationTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, emailverificationtoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailVerificationTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailverificationtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailVerificationTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailVerificationTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailVerificationTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, emailverificationtoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailVerificationTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case emailverificationtoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailVerificationTokenMutation) ClearEdge(name string) error {
	switch name {
	case emailverificationtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailVerificationTokenMutation) ResetEdge(name string) error {
	switch name {
	case emailverificationtoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown EmailVerificationToken edge %s", name)
}

// PasskeyMutation represents an operation that mutates the Passkey nodes in the graph.
type PasskeyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	credential_id    *[]byte
	public_key       *[]byte
	attestation_type *string
	aaguid           *[]byte
	sign_count       *uint32
	addsign_count    *int32
	backup_eligible  *bool
	backup_state     *bool
	name             *string
	last_used_at     *time.Time
	transports       *[]string
	appendtransports []string
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Passkey, error)
	predicates       []predicate.Passkey
}

var _ ent.Mutation = (*PasskeyMutation)(nil)

// passkeyOption allows management of the mutation configuration using functional options.
type passkeyOption func(*PasskeyMutation)

// newPasskeyMutation creates new mutation for the Passkey entity.
func newPasskeyMutation(c config, op Op, opts ...passkeyOption) *PasskeyMutation {
	m := &PasskeyMutation{
		config:        c,
		op:            op,
		typ:           TypePasskey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasskeyID sets the ID field of the mutation.
func withPasskeyID(id int) passkeyOption {
	return func(m *PasskeyMutation) {
		var (
			err   error
			once  sync.Once
			value *Passkey
		)
		m.oldValue = func(ctx context.Context) (*Passkey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Passkey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasskey sets the old Passkey of the mutation.
func withPasskey(node *Passkey) passkeyOption {
	return func(m *PasskeyMutation) {
		m.oldValue = func(context.Context) (*Passkey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasskeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasskeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasskeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasskeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Passkey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PasskeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasskeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasskeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PasskeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PasskeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PasskeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PasskeyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PasskeyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PasskeyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[passkey.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PasskeyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[passkey.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PasskeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, passkey.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *PasskeyMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasskeyMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasskeyMutation) ResetUserID() {
	m.user = nil
}

// SetCredentialID sets the "credential_id" field.
func (m *PasskeyMutation) SetCredentialID(b []byte) {
	m.credential_id = &b
}

// CredentialID returns the value of the "credential_id" field in the mutation.
func (m *PasskeyMutation) CredentialID() (r []byte, exists bool) {
	v := m.credential_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentialID returns the old "credential_id" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldCredentialID(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentialID: %w", err)
	}
	return oldValue.CredentialID, nil
}

// ResetCredentialID resets all changes to the "credential_id" field.
func (m *PasskeyMutation) ResetCredentialID() {
	m.credential_id = nil
}

// SetPublicKey sets the "public_key" field.
func (m *PasskeyMutation) SetPublicKey(b []byte) {
	m.public_key = &b
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *PasskeyMutation) PublicKey() (r []byte, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *PasskeyMutation) ResetPublicKey() {
	m.public_key = nil
}

// SetAttestationType sets the "attestation_type" field.
func (m *PasskeyMutation) SetAttestationType(s string) {
	m.attestation_type = &s
}

// AttestationType returns the value of the "attestation_type" field in the mutation.
func (m *PasskeyMutation) AttestationType() (r string, exists bool) {
	v := m.attestation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAttestationType returns the old "attestation_type" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldAttestationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttestationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttestationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttestationType: %w", err)
	}
	return oldValue.AttestationType, nil
}

// ResetAttestationType resets all changes to the "attestation_type" field.
func (m *PasskeyMutation) ResetAttestationType() {
	m.attestation_type = nil
}

// SetAaguid sets the "aaguid" field.
func (m *PasskeyMutation) SetAaguid(b []byte) {
	m.aaguid = &b
}

// Aaguid returns the value of the "aaguid" field in the mutation.
func (m *PasskeyMutation) Aaguid() (r []byte, exists bool) {
	v := m.aaguid
	if v == nil {
		return
	}
	return *v, true
}

// OldAaguid returns the old "aaguid" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldAaguid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAaguid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAaguid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAaguid: %w", err)
	}
	return oldValue.Aaguid, nil
}

// ClearAaguid clears the value of the "aaguid" field.
func (m *PasskeyMutation) ClearAaguid() {
	m.aaguid = nil
	m.clearedFields[passkey.FieldAaguid] = struct{}{}
}

// AaguidCleared returns if the "aaguid" field was cleared in this mutation.
func (m *PasskeyMutation) AaguidCleared() bool {
	_, ok := m.clearedFields[passkey.FieldAaguid]
	return ok
}

// ResetAaguid resets all changes to the "aaguid" field.
func (m *PasskeyMutation) ResetAaguid() {
	m.aaguid = nil
	delete(m.clearedFields, passkey.FieldAaguid)
}

// SetSignCount sets the "sign_count" field.
func (m *PasskeyMutation) SetSignCount(u uint32) {
	m.sign_count = &u
	m.addsign_count = nil
}

// SignCount returns the value of the "sign_count" field in the mutation.
func (m *PasskeyMutation) SignCount() (r uint32, exists bool) {
	v := m.sign_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSignCount returns the old "sign_count" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldSignCount(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignCount: %w", err)
	}
	return oldValue.SignCount, nil
}

// AddSignCount adds u to the "sign_count" field.
func (m *PasskeyMutation) AddSignCount(u int32) {
	if m.addsign_count != nil {
		*m.addsign_count += u
	} else {
		m.addsign_count = &u
	}
}

// AddedSignCount returns the value that was added to the "sign_count" field in this mutation.
func (m *PasskeyMutation) AddedSignCount() (r int32, exists bool) {
	v := m.addsign_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSignCount resets all changes to the "sign_count" field.
func (m *PasskeyMutation) ResetSignCount() {
	m.sign_count = nil
	m.addsign_count = nil
}

// SetBackupEligible sets the "backup_eligible" field.
func (m *PasskeyMutation) SetBackupEligible(b bool) {
	m.backup_eligible = &b
}

// BackupEligible returns the value of the "backup_eligible" field in the mutation.
func (m *PasskeyMutation) BackupEligible() (r bool, exists bool) {
	v := m.backup_eligible
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupEligible returns the old "backup_eligible" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldBackupEligible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupEligible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupEligible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupEligible: %w", err)
	}
	return oldValue.BackupEligible, nil
}

// ResetBackupEligible resets all changes to the "backup_eligible" field.
func (m *PasskeyMutation) ResetBackupEligible() {
	m.backup_eligible = nil
}

// SetBackupState sets the "backup_state" field.
func (m *PasskeyMutation) SetBackupState(b bool) {
	m.backup_state = &b
}

// BackupState returns the value of the "backup_state" field in the mutation.
func (m *PasskeyMutation) BackupState() (r bool, exists bool) {
	v := m.backup_state
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupState returns the old "backup_state" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldBackupState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupState: %w", err)
	}
	return oldValue.BackupState, nil
}

// ResetBackupState resets all changes to the "backup_state" field.
func (m *PasskeyMutation) ResetBackupState() {
	m.backup_state = nil
}

// SetName sets the "name" field.
func (m *PasskeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PasskeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PasskeyMutation) ResetName() {
	m.name = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *PasskeyMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *PasskeyMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *PasskeyMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[passkey.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *PasskeyMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[passkey.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *PasskeyMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, passkey.FieldLastUsedAt)
}

// SetTransports sets the "transports" field.
func (m *PasskeyMutation) SetTransports(s []string) {
	m.transports = &s
	m.appendtransports = nil
}

// Transports returns the value of the "transports" field in the mutation.
func (m *PasskeyMutation) Transports() (r []string, exists bool) {
	v := m.transports
	if v == nil {
		return
	}
	return *v, true
}

// OldTransports returns the old "transports" field's value of the Passkey entity.
// If the Passkey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasskeyMutation) OldTransports(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransports is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransports requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransports: %w", err)
	}
	return oldValue.Transports, nil
}

// AppendTransports adds s to the "transports" field.
func (m *PasskeyMutation) AppendTransports(s []string) {
	m.appendtransports = append(m.appendtransports, s...)
}

// AppendedTransports returns the list of values that were appended to the "transports" field in this mutation.
func (m *PasskeyMutation) AppendedTransports() ([]string, bool) {
	if len(m.appendtransports) == 0 {
		return nil, false
	}
	return m.appendtransports, true
}

// ClearTransports clears the value of the "transports" field.
func (m *PasskeyMutation) ClearTransports() {
	m.transports = nil
	m.appendtransports = nil
	m.clearedFields[passkey.FieldTransports] = struct{}{}
}

// TransportsCleared returns if the "transports" field was cleared in this mutation.
func (m *PasskeyMutation) TransportsCleared() bool {
	_, ok := m.clearedFields[passkey.FieldTransports]
	return ok
}

// ResetTransports resets all changes to the "transports" field.
func (m *PasskeyMutation) ResetTransports() {
	m.transports = nil
	m.appendtransports = nil
	delete(m.clearedFields, passkey.FieldTransports)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasskeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[passkey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasskeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasskeyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasskeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasskeyMutation builder.
func (m *PasskeyMutation) Where(ps ...predicate.Passkey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasskeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasskeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Passkey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasskeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasskeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Passkey).
func (m *PasskeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasskeyMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, passkey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, passkey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, passkey.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, passkey.FieldUserID)
	}
	if m.credential_id != nil {
		fields = append(fields, passkey.FieldCredentialID)
	}
	if m.public_key != nil {
		fields = append(fields, passkey.FieldPublicKey)
	}
	if m.attestation_type != nil {
		fields = append(fields, passkey.FieldAttestationType)
	}
	if m.aaguid != nil {
		fields = append(fields, passkey.FieldAaguid)
	}
	if m.sign_count != nil {
		fields = append(fields, passkey.FieldSignCount)
	}
	if m.backup_eligible != nil {
		fields = append(fields, passkey.FieldBackupEligible)
	}
	if m.backup_state != nil {
		fields = append(fields, passkey.FieldBackupState)
	}
	if m.name != nil {
		fields = append(fields, passkey.FieldName)
	}
	if m.last_used_at != nil {
		fields = append(fields, passkey.FieldLastUsedAt)
	}
	if m.transports != nil {
		fields = append(fields, passkey.FieldTransports)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasskeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passkey.FieldCreatedAt:
		return m.CreatedAt()
	case passkey.FieldUpdatedAt:
		return m.UpdatedAt()
	case passkey.FieldDeletedAt:
		return m.DeletedAt()
	case passkey.FieldUserID:
		return m.UserID()
	case passkey.FieldCredentialID:
		return m.CredentialID()
	case passkey.FieldPublicKey:
		return m.PublicKey()
	case passkey.FieldAttestationType:
		return m.AttestationType()
	case passkey.FieldAaguid:
		return m.Aaguid()
	case passkey.FieldSignCount:
		return m.SignCount()
	case passkey.FieldBackupEligible:
		return m.BackupEligible()
	case passkey.FieldBackupState:
		return m.BackupState()
	case passkey.FieldName:
		return m.Name()
	case passkey.FieldLastUsedAt:
		return m.LastUsedAt()
	case passkey.FieldTransports:
		return m.Transports()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasskeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passkey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case passkey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case passkey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case passkey.FieldUserID:
		return m.OldUserID(ctx)
	case passkey.FieldCredentialID:
		return m.OldCredentialID(ctx)
	case passkey.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case passkey.FieldAttestationType:
		return m.OldAttestationType(ctx)
	case passkey.FieldAaguid:
		return m.OldAaguid(ctx)
	case passkey.FieldSignCount:
		return m.OldSignCount(ctx)
	case passkey.FieldBackupEligible:
		return m.OldBackupEligible(ctx)
	case passkey.FieldBackupState:
		return m.OldBackupState(ctx)
	case passkey.FieldName:
		return m.OldName(ctx)
	case passkey.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case passkey.FieldTransports:
		return m.OldTransports(ctx)
	}
	return nil, fmt.Errorf("unknown Passkey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasskeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passkey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case passkey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case passkey.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case passkey.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case passkey.FieldCredentialID:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentialID(v)
		return nil
	case passkey.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case passkey.FieldAttestationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttestationType(v)
		return nil
	case passkey.FieldAaguid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAaguid(v)
		return nil
	case passkey.FieldSignCount:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignCount(v)
		return nil
	case passkey.FieldBackupEligible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupEligible(v)
		return nil
	case passkey.FieldBackupState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupState(v)
		return nil
	case passkey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case passkey.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case passkey.FieldTransports:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransports(v)
		return nil
	}
	return fmt.Errorf("unknown Passkey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasskeyMutation) AddedFields() []string {
	var fields []string
	if m.addsign_count != nil {
		fields = append(fields, passkey.FieldSignCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasskeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case passkey.FieldSignCount:
		return m.AddedSignCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasskeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case passkey.FieldSignCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSignCount(v)
		return nil
	}
	return fmt.Errorf("unknown Passkey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasskeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passkey.FieldDeletedAt) {
		fields = append(fields, passkey.FieldDeletedAt)
	}
	if m.FieldCleared(passkey.FieldAaguid) {
		fields = append(fields, passkey.FieldAaguid)
	}
	if m.FieldCleared(passkey.FieldLastUsedAt) {
		fields = append(fields, passkey.FieldLastUsedAt)
	}
	if m.FieldCleared(passkey.FieldTransports) {
		fields = append(fields, passkey.FieldTransports)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasskeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasskeyMutation) ClearField(name string) error {
	switch name {
	case passkey.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case passkey.FieldAaguid:
		m.ClearAaguid()
		return nil
	case passkey.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case passkey.FieldTransports:
		m.ClearTransports()
		return nil
	}
	return fmt.Errorf("unknown Passkey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasskeyMutation) ResetField(name string) error {
	switch name {
	case passkey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case passkey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case passkey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case passkey.FieldUserID:
		m.ResetUserID()
		return nil
	case passkey.FieldCredentialID:
		m.ResetCredentialID()
		return nil
	case passkey.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case passkey.FieldAttestationType:
		m.ResetAttestationType()
		return nil
	case passkey.FieldAaguid:
		m.ResetAaguid()
		return nil
	case passkey.FieldSignCount:
		m.ResetSignCount()
		return nil
	case passkey.FieldBackupEligible:
		m.ResetBackupEligible()
		return nil
	case passkey.FieldBackupState:
		m.ResetBackupState()
		return nil
	case passkey.FieldName:
		m.ResetName()
		return nil
	case passkey.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case passkey.FieldTransports:
		m.ResetTransports()
		return nil
	}
	return fmt.Errorf("unknown Passkey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasskeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passkey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasskeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passkey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasskeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasskeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasskeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passkey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasskeyMutation) EdgeCleared(name string) bool {
	switch name {
	case passkey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasskeyMutation) ClearEdge(name string) error {
	switch name {
	case passkey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Passkey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasskeyMutation) ResetEdge(name string) error {
	switch name {
	case passkey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Passkey edge %s", name)
}

// PasswordResetTokenMutation represents an operation that mutates the PasswordResetToken nodes in the graph.
type PasswordResetTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token_hash    *string
	expires_at    *time.Time
	used_at       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*PasswordResetToken, error)
	predicates    []predicate.PasswordResetToken
}

var _ ent.Mutation = (*PasswordResetTokenMutation)(nil)

// passwordresettokenOption allows management of the mutation configuration using functional options.
type passwordresettokenOption func(*PasswordResetTokenMutation)

// newPasswordResetTokenMutation creates new mutation for the PasswordResetToken entity.
func newPasswordResetTokenMutation(c config, op Op, opts ...passwordresettokenOption) *PasswordResetTokenMutation {
	m := &PasswordResetTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePasswordResetToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordResetTokenID sets the ID field of the mutation.
func withPasswordResetTokenID(id int) passwordresettokenOption {
	return func(m *PasswordResetTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PasswordResetToken
		)
		m.oldValue = func(ctx context.Context) (*PasswordResetToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PasswordResetToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasswordResetToken sets the old PasswordResetToken of the mutation.
func withPasswordResetToken(node *PasswordResetToken) passwordresettokenOption {
	return func(m *PasswordResetTokenMutation) {
		m.oldValue = func(context.Context) (*PasswordResetToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordResetTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordResetTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordResetTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordResetTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PasswordResetToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PasswordResetTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasswordResetTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasswordResetTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PasswordResetTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PasswordResetTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PasswordResetTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PasswordResetTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PasswordResetTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PasswordResetTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[passwordresettoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PasswordResetTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[passwordresettoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PasswordResetTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, passwordresettoken.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *PasswordResetTokenMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasswordResetTokenMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasswordResetTokenMutation) ResetUserID() {
	m.user = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *PasswordResetTokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *PasswordResetTokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *PasswordResetTokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *PasswordResetTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PasswordResetTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PasswordResetTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsedAt sets the "used_at" field.
func (m *PasswordResetTokenMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *PasswordResetTokenMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the PasswordResetToken entity.
// If the PasswordResetToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetTokenMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *PasswordResetTokenMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[passwordresettoken.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *PasswordResetTokenMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[passwordresettoken.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *PasswordResetTokenMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, passwordresettoken.FieldUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasswordResetTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[passwordresettoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasswordResetTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasswordResetTokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasswordResetTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasswordResetTokenMutation builder.
func (m *PasswordResetTokenMutation) Where(ps ...predicate.PasswordResetToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordResetTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordResetTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PasswordResetToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordResetTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordResetTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PasswordResetToken).
func (m *PasswordResetTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordResetTokenMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, passwordresettoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, passwordresettoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, passwordresettoken.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, passwordresettoken.FieldUserID)
	}
	if m.token_hash != nil {
		fields = append(fields, passwordresettoken.FieldTokenHash)
	}
	if m.expires_at != nil {
		fields = append(fields, passwordresettoken.FieldExpiresAt)
	}
	if m.used_at != nil {
		fields = append(fields, passwordresettoken.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordResetTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		return m.CreatedAt()
	case passwordresettoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case passwordresettoken.FieldDeletedAt:
		return m.DeletedAt()
	case passwordresettoken.FieldUserID:
		return m.UserID()
	case passwordresettoken.FieldTokenHash:
		return m.TokenHash()
	case passwordresettoken.FieldExpiresAt:
		return m.ExpiresAt()
	case passwordresettoken.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordResetTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case passwordresettoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case passwordresettoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case passwordresettoken.FieldUserID:
		return m.OldUserID(ctx)
	case passwordresettoken.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case passwordresettoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case passwordresettoken.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case passwordresettoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case passwordresettoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case passwordresettoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case passwordresettoken.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case passwordresettoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case passwordresettoken.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordResetTokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordResetTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PasswordResetToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordResetTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passwordresettoken.FieldDeletedAt) {
		fields = append(fields, passwordresettoken.FieldDeletedAt)
	}
	if m.FieldCleared(passwordresettoken.FieldUsedAt) {
		fields = append(fields, passwordresettoken.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordResetTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordResetTokenMutation) ClearField(name string) error {
	switch name {
	case passwordresettoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case passwordresettoken.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordResetTokenMutation) ResetField(name string) error {
	switch name {
	case passwordresettoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case passwordresettoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case passwordresettoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case passwordresettoken.FieldUserID:
		m.ResetUserID()
		return nil
	case passwordresettoken.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case passwordresettoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case passwordresettoken.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordResetTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passwordresettoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordResetTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passwordresettoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordResetTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordResetTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordResetTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passwordresettoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordResetTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case passwordresettoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordResetTokenMutation) ClearEdge(name string) error {
	switch name {
	case passwordresettoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordResetTokenMutation) ResetEdge(name string) error {
	switch name {
	case passwordresettoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetToken edge %s", name)
}

// SecurityEventMutation represents an operation that mutates the SecurityEvent nodes in the graph.
type SecurityEventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	email         *string
	event_type    *string
	ip_address    *string
	user_agent    *string
	success       *bool
	details       *string
	severity      *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*SecurityEvent, error)
	predicates    []predicate.SecurityEvent
}

var _ ent.Mutation = (*SecurityEventMutation)(nil)

// securityeventOption allows management of the mutation configuration using functional options.
type securityeventOption func(*SecurityEventMutation)

// newSecurityEventMutation creates new mutation for the SecurityEvent entity.
func newSecurityEventMutation(c config, op Op, opts ...securityeventOption) *SecurityEventMutation {
	m := &SecurityEventMutation{
		config:        c,
		op:            op,
		typ:           TypeSecurityEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecurityEventID sets the ID field of the mutation.
func withSecurityEventID(id int) securityeventOption {
	return func(m *SecurityEventMutation) {
		var (
			err   error
			once  sync.Once
			value *SecurityEvent
		)
		m.oldValue = func(ctx context.Context) (*SecurityEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SecurityEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecurityEvent sets the old SecurityEvent of the mutation.
func withSecurityEvent(node *SecurityEvent) securityeventOption {
	return func(m *SecurityEventMutation) {
		m.oldValue = func(context.Context) (*SecurityEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecurityEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecurityEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SecurityEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SecurityEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SecurityEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SecurityEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SecurityEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SecurityEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SecurityEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SecurityEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SecurityEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SecurityEventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SecurityEventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SecurityEventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[securityevent.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SecurityEventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SecurityEventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, securityevent.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *SecurityEventMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SecurityEventMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldUserID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *SecurityEventMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[securityevent.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SecurityEventMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SecurityEventMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, securityevent.FieldUserID)
}

// SetEmail sets the "email" field.
func (m *SecurityEventMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SecurityEventMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *SecurityEventMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[securityevent.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *SecurityEventMutation) EmailCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *SecurityEventMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, securityevent.FieldEmail)
}

// SetEventType sets the "event_type" field.
func (m *SecurityEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *SecurityEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *SecurityEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *SecurityEventMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SecurityEventMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SecurityEventMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[securityevent.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SecurityEventMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SecurityEventMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, securityevent.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *SecurityEventMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SecurityEventMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SecurityEventMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[securityevent.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SecurityEventMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SecurityEventMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, securityevent.FieldUserAgent)
}

// SetSuccess sets the "success" field.
func (m *SecurityEventMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *SecurityEventMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *SecurityEventMutation) ResetSuccess() {
	m.success = nil
}

// SetDetails sets the "details" field.
func (m *SecurityEventMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the value of the "details" field in the mutation.
func (m *SecurityEventMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *SecurityEventMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[securityevent.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *SecurityEventMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *SecurityEventMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, securityevent.FieldDetails)
}

// SetSeverity sets the "severity" field.
func (m *SecurityEventMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *SecurityEventMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the SecurityEvent entity.
// If the SecurityEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityEventMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ClearSeverity clears the value of the "severity" field.
func (m *SecurityEventMutation) ClearSeverity() {
	m.severity = nil
	m.clearedFields[securityevent.FieldSeverity] = struct{}{}
}

// SeverityCleared returns if the "severity" field was cleared in this mutation.
func (m *SecurityEventMutation) SeverityCleared() bool {
	_, ok := m.clearedFields[securityevent.FieldSeverity]
	return ok
}

// ResetSeverity resets all changes to the "severity" field.
func (m *SecurityEventMutation) ResetSeverity() {
	m.severity = nil
	delete(m.clearedFields, securityevent.FieldSeverity)
}

// ClearUser clears the "user" edge to the User entity.
func (m *SecurityEventMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[securityevent.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SecurityEventMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SecurityEventMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SecurityEventMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SecurityEventMutation builder.
func (m *SecurityEventMutation) Where(ps ...predicate.SecurityEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SecurityEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SecurityEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SecurityEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SecurityEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SecurityEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SecurityEvent).
func (m *SecurityEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecurityEventMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, securityevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, securityevent.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, securityevent.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, securityevent.FieldUserID)
	}
	if m.email != nil {
		fields = append(fields, securityevent.FieldEmail)
	}
	if m.event_type != nil {
		fields = append(fields, securityevent.FieldEventType)
	}
	if m.ip_address != nil {
		fields = append(fields, securityevent.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, securityevent.FieldUserAgent)
	}
	if m.success != nil {
		fields = append(fields, securityevent.FieldSuccess)
	}
	if m.details != nil {
		fields = append(fields, securityevent.FieldDetails)
	}
	if m.severity != nil {
		fields = append(fields, securityevent.FieldSeverity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecurityEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case securityevent.FieldCreatedAt:
		return m.CreatedAt()
	case securityevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case securityevent.FieldDeletedAt:
		return m.DeletedAt()
	case securityevent.FieldUserID:
		return m.UserID()
	case securityevent.FieldEmail:
		return m.Email()
	case securityevent.FieldEventType:
		return m.EventType()
	case securityevent.FieldIPAddress:
		return m.IPAddress()
	case securityevent.FieldUserAgent:
		return m.UserAgent()
	case securityevent.FieldSuccess:
		return m.Success()
	case securityevent.FieldDetails:
		return m.Details()
	case securityevent.FieldSeverity:
		return m.Severity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecurityEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case securityevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case securityevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case securityevent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case securityevent.FieldUserID:
		return m.OldUserID(ctx)
	case securityevent.FieldEmail:
		return m.OldEmail(ctx)
	case securityevent.FieldEventType:
		return m.OldEventType(ctx)
	case securityevent.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case securityevent.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case securityevent.FieldSuccess:
		return m.OldSuccess(ctx)
	case securityevent.FieldDetails:
		return m.OldDetails(ctx)
	case securityevent.FieldSeverity:
		return m.OldSeverity(ctx)
	}
	return nil, fmt.Errorf("unknown SecurityEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case securityevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case securityevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case securityevent.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case securityevent.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case securityevent.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case securityevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case securityevent.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case securityevent.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case securityevent.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case securityevent.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case securityevent.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	}
	return fmt.Errorf("unknown SecurityEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecurityEventMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecurityEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SecurityEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecurityEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(securityevent.FieldDeletedAt) {
		fields = append(fields, securityevent.FieldDeletedAt)
	}
	if m.FieldCleared(securityevent.FieldUserID) {
		fields = append(fields, securityevent.FieldUserID)
	}
	if m.FieldCleared(securityevent.FieldEmail) {
		fields = append(fields, securityevent.FieldEmail)
	}
	if m.FieldCleared(securityevent.FieldIPAddress) {
		fields = append(fields, securityevent.FieldIPAddress)
	}
	if m.FieldCleared(securityevent.FieldUserAgent) {
		fields = append(fields, securityevent.FieldUserAgent)
	}
	if m.FieldCleared(securityevent.FieldDetails) {
		fields = append(fields, securityevent.FieldDetails)
	}
	if m.FieldCleared(securityevent.FieldSeverity) {
		fields = append(fields, securityevent.FieldSeverity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecurityEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecurityEventMutation) ClearField(name string) error {
	switch name {
	case securityevent.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case securityevent.FieldUserID:
		m.ClearUserID()
		return nil
	case securityevent.FieldEmail:
		m.ClearEmail()
		return nil
	case securityevent.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case securityevent.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case securityevent.FieldDetails:
		m.ClearDetails()
		return nil
	case securityevent.FieldSeverity:
		m.ClearSeverity()
		return nil
	}
	return fmt.Errorf("unknown SecurityEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecurityEventMutation) ResetField(name string) error {
	switch name {
	case securityevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case securityevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case securityevent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case securityevent.FieldUserID:
		m.ResetUserID()
		return nil
	case securityevent.FieldEmail:
		m.ResetEmail()
		return nil
	case securityevent.FieldEventType:
		m.ResetEventType()
		return nil
	case securityevent.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case securityevent.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case securityevent.FieldSuccess:
		m.ResetSuccess()
		return nil
	case securityevent.FieldDetails:
		m.ResetDetails()
		return nil
	case securityevent.FieldSeverity:
		m.ResetSeverity()
		return nil
	}
	return fmt.Errorf("unknown SecurityEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecurityEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, securityevent.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecurityEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case securityevent.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecurityEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecurityEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecurityEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, securityevent.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecurityEventMutation) EdgeCleared(name string) bool {
	switch name {
	case securityevent.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecurityEventMutation) ClearEdge(name string) error {
	switch name {
	case securityevent.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SecurityEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecurityEventMutation) ResetEdge(name string) error {
	switch name {
	case securityevent.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SecurityEvent edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	refresh_token_hash *string
	access_token_jti   *string
	ip_address         *string
	user_agent         *string
	expires_at         *time.Time
	last_used_at       *time.Time
	revoked_at         *time.Time
	revoke_reason      *string
	token_family       *string
	is_used            *bool
	clearedFields      map[string]struct{}
	user               *int
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*Session, error)
	predicates         []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id int) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SessionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SessionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SessionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[session.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SessionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SessionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, session.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
}

// SetRefreshTokenHash sets the "refresh_token_hash" field.
func (m *SessionMutation) SetRefreshTokenHash(s string) {
	m.refresh_token_hash = &s
}

// RefreshTokenHash returns the value of the "refresh_token_hash" field in the mutation.
func (m *SessionMutation) RefreshTokenHash() (r string, exists bool) {
	v := m.refresh_token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenHash returns the old "refresh_token_hash" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRefreshTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenHash: %w", err)
	}
	return oldValue.RefreshTokenHash, nil
}

// ResetRefreshTokenHash resets all changes to the "refresh_token_hash" field.
func (m *SessionMutation) ResetRefreshTokenHash() {
	m.refresh_token_hash = nil
}

// SetAccessTokenJti sets the "access_token_jti" field.
func (m *SessionMutation) SetAccessTokenJti(s string) {
	m.access_token_jti = &s
}

// AccessTokenJti returns the value of the "access_token_jti" field in the mutation.
func (m *SessionMutation) AccessTokenJti() (r string, exists bool) {
	v := m.access_token_jti
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessTokenJti returns the old "access_token_jti" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldAccessTokenJti(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessTokenJti is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessTokenJti requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessTokenJti: %w", err)
	}
	return oldValue.AccessTokenJti, nil
}

// ClearAccessTokenJti clears the value of the "access_token_jti" field.
func (m *SessionMutation) ClearAccessTokenJti() {
	m.access_token_jti = nil
	m.clearedFields[session.FieldAccessTokenJti] = struct{}{}
}

// AccessTokenJtiCleared returns if the "access_token_jti" field was cleared in this mutation.
func (m *SessionMutation) AccessTokenJtiCleared() bool {
	_, ok := m.clearedFields[session.FieldAccessTokenJti]
	return ok
}

// ResetAccessTokenJti resets all changes to the "access_token_jti" field.
func (m *SessionMutation) ResetAccessTokenJti() {
	m.access_token_jti = nil
	delete(m.clearedFields, session.FieldAccessTokenJti)
}

// SetIPAddress sets the "ip_address" field.
func (m *SessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[session.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[session.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, session.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[session.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[session.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, session.FieldUserAgent)
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *SessionMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *SessionMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLastUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *SessionMutation) ResetLastUsedAt() {
	m.last_used_at = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *SessionMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *SessionMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *SessionMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[session.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *SessionMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *SessionMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, session.FieldRevokedAt)
}

// SetRevokeReason sets the "revoke_reason" field.
func (m *SessionMutation) SetRevokeReason(s string) {
	m.revoke_reason = &s
}

// RevokeReason returns the value of the "revoke_reason" field in the mutation.
func (m *SessionMutation) RevokeReason() (r string, exists bool) {
	v := m.revoke_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokeReason returns the old "revoke_reason" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRevokeReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokeReason: %w", err)
	}
	return oldValue.RevokeReason, nil
}

// ClearRevokeReason clears the value of the "revoke_reason" field.
func (m *SessionMutation) ClearRevokeReason() {
	m.revoke_reason = nil
	m.clearedFields[session.FieldRevokeReason] = struct{}{}
}

// RevokeReasonCleared returns if the "revoke_reason" field was cleared in this mutation.
func (m *SessionMutation) RevokeReasonCleared() bool {
	_, ok := m.clearedFields[session.FieldRevokeReason]
	return ok
}

// ResetRevokeReason resets all changes to the "revoke_reason" field.
func (m *SessionMutation) ResetRevokeReason() {
	m.revoke_reason = nil
	delete(m.clearedFields, session.FieldRevokeReason)
}

// SetTokenFamily sets the "token_family" field.
func (m *SessionMutation) SetTokenFamily(s string) {
	m.token_family = &s
}

// TokenFamily returns the value of the "token_family" field in the mutation.
func (m *SessionMutation) TokenFamily() (r string, exists bool) {
	v := m.token_family
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenFamily returns the old "token_family" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTokenFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenFamily: %w", err)
	}
	return oldValue.TokenFamily, nil
}

// ResetTokenFamily resets all changes to the "token_family" field.
func (m *SessionMutation) ResetTokenFamily() {
	m.token_family = nil
}

// SetIsUsed sets the "is_used" field.
func (m *SessionMutation) SetIsUsed(b bool) {
	m.is_used = &b
}

// IsUsed returns the value of the "is_used" field in the mutation.
func (m *SessionMutation) IsUsed() (r bool, exists bool) {
	v := m.is_used
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUsed returns the old "is_used" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIsUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUsed: %w", err)
	}
	return oldValue.IsUsed, nil
}

// ResetIsUsed resets all changes to the "is_used" field.
func (m *SessionMutation) ResetIsUsed() {
	m.is_used = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, session.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.refresh_token_hash != nil {
		fields = append(fields, session.FieldRefreshTokenHash)
	}
	if m.access_token_jti != nil {
		fields = append(fields, session.FieldAccessTokenJti)
	}
	if m.ip_address != nil {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, session.FieldLastUsedAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.revoke_reason != nil {
		fields = append(fields, session.FieldRevokeReason)
	}
	if m.token_family != nil {
		fields = append(fields, session.FieldTokenFamily)
	}
	if m.is_used != nil {
		fields = append(fields, session.FieldIsUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldDeletedAt:
		return m.DeletedAt()
	case session.FieldUserID:
		return m.UserID()
	case session.FieldRefreshTokenHash:
		return m.RefreshTokenHash()
	case session.FieldAccessTokenJti:
		return m.AccessTokenJti()
	case session.FieldIPAddress:
		return m.IPAddress()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldLastUsedAt:
		return m.LastUsedAt()
	case session.FieldRevokedAt:
		return m.RevokedAt()
	case session.FieldRevokeReason:
		return m.RevokeReason()
	case session.FieldTokenFamily:
		return m.TokenFamily()
	case session.FieldIsUsed:
		return m.IsUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldRefreshTokenHash:
		return m.OldRefreshTokenHash(ctx)
	case session.FieldAccessTokenJti:
		return m.OldAccessTokenJti(ctx)
	case session.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case session.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case session.FieldRevokeReason:
		return m.OldRevokeReason(ctx)
	case session.FieldTokenFamily:
		return m.OldTokenFamily(ctx)
	case session.FieldIsUsed:
		return m.OldIsUsed(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case session.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldRefreshTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenHash(v)
		return nil
	case session.FieldAccessTokenJti:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessTokenJti(v)
		return nil
	case session.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case session.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case session.FieldRevokeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokeReason(v)
		return nil
	case session.FieldTokenFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenFamily(v)
		return nil
	case session.FieldIsUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUsed(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldDeletedAt) {
		fields = append(fields, session.FieldDeletedAt)
	}
	if m.FieldCleared(session.FieldAccessTokenJti) {
		fields = append(fields, session.FieldAccessTokenJti)
	}
	if m.FieldCleared(session.FieldIPAddress) {
		fields = append(fields, session.FieldIPAddress)
	}
	if m.FieldCleared(session.FieldUserAgent) {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.FieldCleared(session.FieldRevokedAt) {
		fields = append(fields, session.FieldRevokedAt)
	}
	if m.FieldCleared(session.FieldRevokeReason) {
		fields = append(fields, session.FieldRevokeReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case session.FieldAccessTokenJti:
		m.ClearAccessTokenJti()
		return nil
	case session.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case session.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case session.FieldRevokeReason:
		m.ClearRevokeReason()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldRefreshTokenHash:
		m.ResetRefreshTokenHash()
		return nil
	case session.FieldAccessTokenJti:
		m.ResetAccessTokenJti()
		return nil
	case session.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case session.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case session.FieldRevokeReason:
		m.ResetRevokeReason()
		return nil
	case session.FieldTokenFamily:
		m.ResetTokenFamily()
		return nil
	case session.FieldIsUsed:
		m.ResetIsUsed()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// SessionLockMutation represents an operation that mutates the SessionLock nodes in the graph.
type SessionLockMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	locked_at     *time.Time
	unlocked_at   *time.Time
	expires_at    *time.Time
	reason        *string
	locked_by     *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*SessionLock, error)
	predicates    []predicate.SessionLock
}

var _ ent.Mutation = (*SessionLockMutation)(nil)

// sessionlockOption allows management of the mutation configuration using functional options.
type sessionlockOption func(*SessionLockMutation)

// newSessionLockMutation creates new mutation for the SessionLock entity.
func newSessionLockMutation(c config, op Op, opts ...sessionlockOption) *SessionLockMutation {
	m := &SessionLockMutation{
		config:        c,
		op:            op,
		typ:           TypeSessionLock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionLockID sets the ID field of the mutation.
func withSessionLockID(id int) sessionlockOption {
	return func(m *SessionLockMutation) {
		var (
			err   error
			once  sync.Once
			value *SessionLock
		)
		m.oldValue = func(ctx context.Context) (*SessionLock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SessionLock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSessionLock sets the old SessionLock of the mutation.
func withSessionLock(node *SessionLock) sessionlockOption {
	return func(m *SessionLockMutation) {
		m.oldValue = func(context.Context) (*SessionLock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionLockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionLockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionLockMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionLockMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SessionLock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionLockMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionLockMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionLockMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionLockMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionLockMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionLockMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SessionLockMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SessionLockMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SessionLockMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sessionlock.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SessionLockMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sessionlock.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SessionLockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sessionlock.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *SessionLockMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionLockMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionLockMutation) ResetUserID() {
	m.user = nil
}

// SetLockedAt sets the "locked_at" field.
func (m *SessionLockMutation) SetLockedAt(t time.Time) {
	m.locked_at = &t
}

// LockedAt returns the value of the "locked_at" field in the mutation.
func (m *SessionLockMutation) LockedAt() (r time.Time, exists bool) {
	v := m.locked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedAt returns the old "locked_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldLockedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedAt: %w", err)
	}
	return oldValue.LockedAt, nil
}

// ResetLockedAt resets all changes to the "locked_at" field.
func (m *SessionLockMutation) ResetLockedAt() {
	m.locked_at = nil
}

// SetUnlockedAt sets the "unlocked_at" field.
func (m *SessionLockMutation) SetUnlockedAt(t time.Time) {
	m.unlocked_at = &t
}

// UnlockedAt returns the value of the "unlocked_at" field in the mutation.
func (m *SessionLockMutation) UnlockedAt() (r time.Time, exists bool) {
	v := m.unlocked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUnlockedAt returns the old "unlocked_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldUnlockedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnlockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnlockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnlockedAt: %w", err)
	}
	return oldValue.UnlockedAt, nil
}

// ClearUnlockedAt clears the value of the "unlocked_at" field.
func (m *SessionLockMutation) ClearUnlockedAt() {
	m.unlocked_at = nil
	m.clearedFields[sessionlock.FieldUnlockedAt] = struct{}{}
}

// UnlockedAtCleared returns if the "unlocked_at" field was cleared in this mutation.
func (m *SessionLockMutation) UnlockedAtCleared() bool {
	_, ok := m.clearedFields[sessionlock.FieldUnlockedAt]
	return ok
}

// ResetUnlockedAt resets all changes to the "unlocked_at" field.
func (m *SessionLockMutation) ResetUnlockedAt() {
	m.unlocked_at = nil
	delete(m.clearedFields, sessionlock.FieldUnlockedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionLockMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionLockMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionLockMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetReason sets the "reason" field.
func (m *SessionLockMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *SessionLockMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *SessionLockMutation) ResetReason() {
	m.reason = nil
}

// SetLockedBy sets the "locked_by" field.
func (m *SessionLockMutation) SetLockedBy(s string) {
	m.locked_by = &s
}

// LockedBy returns the value of the "locked_by" field in the mutation.
func (m *SessionLockMutation) LockedBy() (r string, exists bool) {
	v := m.locked_by
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedBy returns the old "locked_by" field's value of the SessionLock entity.
// If the SessionLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionLockMutation) OldLockedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedBy: %w", err)
	}
	return oldValue.LockedBy, nil
}

// ClearLockedBy clears the value of the "locked_by" field.
func (m *SessionLockMutation) ClearLockedBy() {
	m.locked_by = nil
	m.clearedFields[sessionlock.FieldLockedBy] = struct{}{}
}

// LockedByCleared returns if the "locked_by" field was cleared in this mutation.
func (m *SessionLockMutation) LockedByCleared() bool {
	_, ok := m.clearedFields[sessionlock.FieldLockedBy]
	return ok
}

// ResetLockedBy resets all changes to the "locked_by" field.
func (m *SessionLockMutation) ResetLockedBy() {
	m.locked_by = nil
	delete(m.clearedFields, sessionlock.FieldLockedBy)
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionLockMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[sessionlock.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionLockMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionLockMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionLockMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionLockMutation builder.
func (m *SessionLockMutation) Where(ps ...predicate.SessionLock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionLockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionLockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SessionLock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionLockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionLockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SessionLock).
func (m *SessionLockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionLockMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, sessionlock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sessionlock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sessionlock.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, sessionlock.FieldUserID)
	}
	if m.locked_at != nil {
		fields = append(fields, sessionlock.FieldLockedAt)
	}
	if m.unlocked_at != nil {
		fields = append(fields, sessionlock.FieldUnlockedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, sessionlock.FieldExpiresAt)
	}
	if m.reason != nil {
		fields = append(fields, sessionlock.FieldReason)
	}
	if m.locked_by != nil {
		fields = append(fields, sessionlock.FieldLockedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionLockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sessionlock.FieldCreatedAt:
		return m.CreatedAt()
	case sessionlock.FieldUpdatedAt:
		return m.UpdatedAt()
	case sessionlock.FieldDeletedAt:
		return m.DeletedAt()
	case sessionlock.FieldUserID:
		return m.UserID()
	case sessionlock.FieldLockedAt:
		return m.LockedAt()
	case sessionlock.FieldUnlockedAt:
		return m.UnlockedAt()
	case sessionlock.FieldExpiresAt:
		return m.ExpiresAt()
	case sessionlock.FieldReason:
		return m.Reason()
	case sessionlock.FieldLockedBy:
		return m.LockedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionLockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sessionlock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sessionlock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sessionlock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case sessionlock.FieldUserID:
		return m.OldUserID(ctx)
	case sessionlock.FieldLockedAt:
		return m.OldLockedAt(ctx)
	case sessionlock.FieldUnlockedAt:
		return m.OldUnlockedAt(ctx)
	case sessionlock.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case sessionlock.FieldReason:
		return m.OldReason(ctx)
	case sessionlock.FieldLockedBy:
		return m.OldLockedBy(ctx)
	}
	return nil, fmt.Errorf("unknown SessionLock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionLockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sessionlock.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sessionlock.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sessionlock.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case sessionlock.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case sessionlock.FieldLockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedAt(v)
		return nil
	case sessionlock.FieldUnlockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnlockedAt(v)
		return nil
	case sessionlock.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case sessionlock.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case sessionlock.FieldLockedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedBy(v)
		return nil
	}
	return fmt.Errorf("unknown SessionLock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionLockMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionLockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionLockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SessionLock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionLockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sessionlock.FieldDeletedAt) {
		fields = append(fields, sessionlock.FieldDeletedAt)
	}
	if m.FieldCleared(sessionlock.FieldUnlockedAt) {
		fields = append(fields, sessionlock.FieldUnlockedAt)
	}
	if m.FieldCleared(sessionlock.FieldLockedBy) {
		fields = append(fields, sessionlock.FieldLockedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionLockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionLockMutation) ClearField(name string) error {
	switch name {
	case sessionlock.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case sessionlock.FieldUnlockedAt:
		m.ClearUnlockedAt()
		return nil
	case sessionlock.FieldLockedBy:
		m.ClearLockedBy()
		return nil
	}
	return fmt.Errorf("unknown SessionLock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionLockMutation) ResetField(name string) error {
	switch name {
	case sessionlock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sessionlock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sessionlock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case sessionlock.FieldUserID:
		m.ResetUserID()
		return nil
	case sessionlock.FieldLockedAt:
		m.ResetLockedAt()
		return nil
	case sessionlock.FieldUnlockedAt:
		m.ResetUnlockedAt()
		return nil
	case sessionlock.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case sessionlock.FieldReason:
		m.ResetReason()
		return nil
	case sessionlock.FieldLockedBy:
		m.ResetLockedBy()
		return nil
	}
	return fmt.Errorf("unknown SessionLock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionLockMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, sessionlock.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionLockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sessionlock.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionLockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionLockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionLockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, sessionlock.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionLockMutation) EdgeCleared(name string) bool {
	switch name {
	case sessionlock.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionLockMutation) ClearEdge(name string) error {
	switch name {
	case sessionlock.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SessionLock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionLockMutation) ResetEdge(name string) error {
	switch name {
	case sessionlock.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SessionLock edge %s", name)
}

// SudoSessionMutation represents an operation that mutates the SudoSession nodes in the graph.
type SudoSessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token_hash    *string
	expires_at    *time.Time
	ip_address    *string
	user_agent    *string
	last_used_at  *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*SudoSession, error)
	predicates    []predicate.SudoSession
}

var _ ent.Mutation = (*SudoSessionMutation)(nil)

// sudosessionOption allows management of the mutation configuration using functional options.
type sudosessionOption func(*SudoSessionMutation)

// newSudoSessionMutation creates new mutation for the SudoSession entity.
func newSudoSessionMutation(c config, op Op, opts ...sudosessionOption) *SudoSessionMutation {
	m := &SudoSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSudoSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSudoSessionID sets the ID field of the mutation.
func withSudoSessionID(id int) sudosessionOption {
	return func(m *SudoSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *SudoSession
		)
		m.oldValue = func(ctx context.Context) (*SudoSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SudoSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSudoSession sets the old SudoSession of the mutation.
func withSudoSession(node *SudoSession) sudosessionOption {
	return func(m *SudoSessionMutation) {
		m.oldValue = func(context.Context) (*SudoSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SudoSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SudoSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SudoSessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SudoSessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SudoSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SudoSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SudoSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SudoSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SudoSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SudoSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SudoSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SudoSessionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SudoSessionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SudoSessionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sudosession.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SudoSessionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sudosession.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SudoSessionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sudosession.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *SudoSessionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SudoSessionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SudoSessionMutation) ResetUserID() {
	m.user = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *SudoSessionMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *SudoSessionMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *SudoSessionMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SudoSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SudoSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SudoSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *SudoSessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *SudoSessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *SudoSessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[sudosession.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *SudoSessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[sudosession.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *SudoSessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, sudosession.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *SudoSessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SudoSessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SudoSessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[sudosession.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SudoSessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[sudosession.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SudoSessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, sudosession.FieldUserAgent)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *SudoSessionMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *SudoSessionMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the SudoSession entity.
// If the SudoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SudoSessionMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *SudoSessionMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[sudosession.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *SudoSessionMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[sudosession.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *SudoSessionMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, sudosession.FieldLastUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *SudoSessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[sudosession.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SudoSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SudoSessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SudoSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SudoSessionMutation builder.
func (m *SudoSessionMutation) Where(ps ...predicate.SudoSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SudoSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SudoSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SudoSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SudoSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SudoSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SudoSession).
func (m *SudoSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SudoSessionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, sudosession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sudosession.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sudosession.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, sudosession.FieldUserID)
	}
	if m.token_hash != nil {
		fields = append(fields, sudosession.FieldTokenHash)
	}
	if m.expires_at != nil {
		fields = append(fields, sudosession.FieldExpiresAt)
	}
	if m.ip_address != nil {
		fields = append(fields, sudosession.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, sudosession.FieldUserAgent)
	}
	if m.last_used_at != nil {
		fields = append(fields, sudosession.FieldLastUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SudoSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sudosession.FieldCreatedAt:
		return m.CreatedAt()
	case sudosession.FieldUpdatedAt:
		return m.UpdatedAt()
	case sudosession.FieldDeletedAt:
		return m.DeletedAt()
	case sudosession.FieldUserID:
		return m.UserID()
	case sudosession.FieldTokenHash:
		return m.TokenHash()
	case sudosession.FieldExpiresAt:
		return m.ExpiresAt()
	case sudosession.FieldIPAddress:
		return m.IPAddress()
	case sudosession.FieldUserAgent:
		return m.UserAgent()
	case sudosession.FieldLastUsedAt:
		return m.LastUsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SudoSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sudosession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sudosession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sudosession.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case sudosession.FieldUserID:
		return m.OldUserID(ctx)
	case sudosession.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case sudosession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case sudosession.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case sudosession.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case sudosession.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SudoSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SudoSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sudosession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sudosession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sudosession.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case sudosession.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case sudosession.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case sudosession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case sudosession.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case sudosession.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case sudosession.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SudoSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SudoSessionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SudoSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SudoSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SudoSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SudoSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sudosession.FieldDeletedAt) {
		fields = append(fields, sudosession.FieldDeletedAt)
	}
	if m.FieldCleared(sudosession.FieldIPAddress) {
		fields = append(fields, sudosession.FieldIPAddress)
	}
	if m.FieldCleared(sudosession.FieldUserAgent) {
		fields = append(fields, sudosession.FieldUserAgent)
	}
	if m.FieldCleared(sudosession.FieldLastUsedAt) {
		fields = append(fields, sudosession.FieldLastUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SudoSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SudoSessionMutation) ClearField(name string) error {
	switch name {
	case sudosession.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case sudosession.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case sudosession.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case sudosession.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown SudoSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SudoSessionMutation) ResetField(name string) error {
	switch name {
	case sudosession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sudosession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sudosession.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case sudosession.FieldUserID:
		m.ResetUserID()
		return nil
	case sudosession.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case sudosession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case sudosession.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case sudosession.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case sudosession.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	}
	return fmt.Errorf("unknown SudoSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SudoSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, sudosession.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SudoSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sudosession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SudoSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SudoSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SudoSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, sudosession.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SudoSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case sudosession.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SudoSessionMutation) ClearEdge(name string) error {
	switch name {
	case sudosession.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SudoSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SudoSessionMutation) ResetEdge(name string) error {
	switch name {
	case sudosession.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SudoSession edge %s", name)
}

// TOTPPendingTokenMutation represents an operation that mutates the TOTPPendingToken nodes in the graph.
type TOTPPendingTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token_hash    *string
	expires_at    *time.Time
	used_at       *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*TOTPPendingToken, error)
	predicates    []predicate.TOTPPendingToken
}

var _ ent.Mutation = (*TOTPPendingTokenMutation)(nil)

// totppendingtokenOption allows management of the mutation configuration using functional options.
type totppendingtokenOption func(*TOTPPendingTokenMutation)

// newTOTPPendingTokenMutation creates new mutation for the TOTPPendingToken entity.
func newTOTPPendingTokenMutation(c config, op Op, opts ...totppendingtokenOption) *TOTPPendingTokenMutation {
	m := &TOTPPendingTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeTOTPPendingToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTOTPPendingTokenID sets the ID field of the mutation.
func withTOTPPendingTokenID(id int) totppendingtokenOption {
	return func(m *TOTPPendingTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *TOTPPendingToken
		)
		m.oldValue = func(ctx context.Context) (*TOTPPendingToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TOTPPendingToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTOTPPendingToken sets the old TOTPPendingToken of the mutation.
func withTOTPPendingToken(node *TOTPPendingToken) totppendingtokenOption {
	return func(m *TOTPPendingTokenMutation) {
		m.oldValue = func(context.Context) (*TOTPPendingToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TOTPPendingTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TOTPPendingTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TOTPPendingTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TOTPPendingTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TOTPPendingToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TOTPPendingTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TOTPPendingTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TOTPPendingTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TOTPPendingTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TOTPPendingTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TOTPPendingTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TOTPPendingTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TOTPPendingTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TOTPPendingTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[totppendingtoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TOTPPendingTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[totppendingtoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TOTPPendingTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, totppendingtoken.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *TOTPPendingTokenMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TOTPPendingTokenMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TOTPPendingTokenMutation) ResetUserID() {
	m.user = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *TOTPPendingTokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *TOTPPendingTokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *TOTPPendingTokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *TOTPPendingTokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TOTPPendingTokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TOTPPendingTokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsedAt sets the "used_at" field.
func (m *TOTPPendingTokenMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *TOTPPendingTokenMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the TOTPPendingToken entity.
// If the TOTPPendingToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TOTPPendingTokenMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *TOTPPendingTokenMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[totppendingtoken.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *TOTPPendingTokenMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[totppendingtoken.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *TOTPPendingTokenMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, totppendingtoken.FieldUsedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *TOTPPendingTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[totppendingtoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TOTPPendingTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TOTPPendingTokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TOTPPendingTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TOTPPendingTokenMutation builder.
func (m *TOTPPendingTokenMutation) Where(ps ...predicate.TOTPPendingToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TOTPPendingTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TOTPPendingTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TOTPPendingToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TOTPPendingTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TOTPPendingTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TOTPPendingToken).
func (m *TOTPPendingTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TOTPPendingTokenMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, totppendingtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, totppendingtoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, totppendingtoken.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, totppendingtoken.FieldUserID)
	}
	if m.token_hash != nil {
		fields = append(fields, totppendingtoken.FieldTokenHash)
	}
	if m.expires_at != nil {
		fields = append(fields, totppendingtoken.FieldExpiresAt)
	}
	if m.used_at != nil {
		fields = append(fields, totppendingtoken.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TOTPPendingTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case totppendingtoken.FieldCreatedAt:
		return m.CreatedAt()
	case totppendingtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case totppendingtoken.FieldDeletedAt:
		return m.DeletedAt()
	case totppendingtoken.FieldUserID:
		return m.UserID()
	case totppendingtoken.FieldTokenHash:
		return m.TokenHash()
	case totppendingtoken.FieldExpiresAt:
		return m.ExpiresAt()
	case totppendingtoken.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TOTPPendingTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case totppendingtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case totppendingtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case totppendingtoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case totppendingtoken.FieldUserID:
		return m.OldUserID(ctx)
	case totppendingtoken.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case totppendingtoken.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case totppendingtoken.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TOTPPendingToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TOTPPendingTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case totppendingtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case totppendingtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case totppendingtoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case totppendingtoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case totppendingtoken.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case totppendingtoken.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case totppendingtoken.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TOTPPendingToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TOTPPendingTokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TOTPPendingTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TOTPPendingTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TOTPPendingToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TOTPPendingTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(totppendingtoken.FieldDeletedAt) {
		fields = append(fields, totppendingtoken.FieldDeletedAt)
	}
	if m.FieldCleared(totppendingtoken.FieldUsedAt) {
		fields = append(fields, totppendingtoken.FieldUsedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TOTPPendingTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TOTPPendingTokenMutation) ClearField(name string) error {
	switch name {
	case totppendingtoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case totppendingtoken.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	}
	return fmt.Errorf("unknown TOTPPendingToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TOTPPendingTokenMutation) ResetField(name string) error {
	switch name {
	case totppendingtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case totppendingtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case totppendingtoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case totppendingtoken.FieldUserID:
		m.ResetUserID()
		return nil
	case totppendingtoken.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case totppendingtoken.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case totppendingtoken.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown TOTPPendingToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TOTPPendingTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, totppendingtoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TOTPPendingTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case totppendingtoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TOTPPendingTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TOTPPendingTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TOTPPendingTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, totppendingtoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TOTPPendingTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case totppendingtoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TOTPPendingTokenMutation) ClearEdge(name string) error {
	switch name {
	case totppendingtoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TOTPPendingToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TOTPPendingTokenMutation) ResetEdge(name string) error {
	switch name {
	case totppendingtoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TOTPPendingToken edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	slug           *string
	name           *string
	description    *string
	color          *string
	icon           *string
	is_active      *bool
	_order         *int
	add_order      *int
	clearedFields  map[string]struct{}
	threads        map[int]struct{}
	removedthreads map[int]struct{}
	clearedthreads bool
	done           bool
	oldValue       func(context.Context) (*Tag, error)
	predicates     []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TagMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TagMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TagMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tag.FieldDeletedAt)
}

// SetSlug sets the "slug" field.
func (m *TagMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TagMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TagMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tag.FieldDescription)
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *TagMutation) ClearColor() {
	m.color = nil
	m.clearedFields[tag.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *TagMutation) ColorCleared() bool {
	_, ok := m.clearedFields[tag.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, tag.FieldColor)
}

// SetIcon sets the "icon" field.
func (m *TagMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *TagMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *TagMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[tag.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *TagMutation) IconCleared() bool {
	_, ok := m.clearedFields[tag.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *TagMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, tag.FieldIcon)
}

// SetIsActive sets the "is_active" field.
func (m *TagMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TagMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TagMutation) ResetIsActive() {
	m.is_active = nil
}

// SetOrder sets the "order" field.
func (m *TagMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *TagMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *TagMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *TagMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *TagMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *TagMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *TagMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *TagMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *TagMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *TagMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *TagMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *TagMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tag.FieldDeletedAt)
	}
	if m.slug != nil {
		fields = append(fields, tag.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	if m.icon != nil {
		fields = append(fields, tag.FieldIcon)
	}
	if m.is_active != nil {
		fields = append(fields, tag.FieldIsActive)
	}
	if m._order != nil {
		fields = append(fields, tag.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldDeletedAt:
		return m.DeletedAt()
	case tag.FieldSlug:
		return m.Slug()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldColor:
		return m.Color()
	case tag.FieldIcon:
		return m.Icon()
	case tag.FieldIsActive:
		return m.IsActive()
	case tag.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tag.FieldSlug:
		return m.OldSlug(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	case tag.FieldIcon:
		return m.OldIcon(ctx)
	case tag.FieldIsActive:
		return m.OldIsActive(ctx)
	case tag.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tag.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case tag.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case tag.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case tag.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, tag.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tag.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDeletedAt) {
		fields = append(fields, tag.FieldDeletedAt)
	}
	if m.FieldCleared(tag.FieldDescription) {
		fields = append(fields, tag.FieldDescription)
	}
	if m.FieldCleared(tag.FieldColor) {
		fields = append(fields, tag.FieldColor)
	}
	if m.FieldCleared(tag.FieldIcon) {
		fields = append(fields, tag.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tag.FieldDescription:
		m.ClearDescription()
		return nil
	case tag.FieldColor:
		m.ClearColor()
		return nil
	case tag.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tag.FieldSlug:
		m.ResetSlug()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	case tag.FieldIcon:
		m.ResetIcon()
		return nil
	case tag.FieldIsActive:
		m.ResetIsActive()
		return nil
	case tag.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.threads != nil {
		edges = append(edges, tag.EdgeThreads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedthreads != nil {
		edges = append(edges, tag.EdgeThreads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedthreads {
		edges = append(edges, tag.EdgeThreads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeThreads:
		return m.clearedthreads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeThreads:
		m.ResetThreads()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// ThreadMutation represents an operation that mutates the Thread nodes in the graph.
type ThreadMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	title                       *string
	summary                     *string
	content_type                *string
	content_json                *map[string]interface{}
	meta                        *map[string]interface{}
	clearedFields               map[string]struct{}
	user                        *int
	cleareduser                 bool
	category                    *int
	clearedcategory             bool
	tags                        map[int]struct{}
	removedtags                 map[int]struct{}
	clearedtags                 bool
	received_credentials        map[int]struct{}
	removedreceived_credentials map[int]struct{}
	clearedreceived_credentials bool
	done                        bool
	oldValue                    func(context.Context) (*Thread, error)
	predicates                  []predicate.Thread
}

var _ ent.Mutation = (*ThreadMutation)(nil)

// threadOption allows management of the mutation configuration using functional options.
type threadOption func(*ThreadMutation)

// newThreadMutation creates new mutation for the Thread entity.
func newThreadMutation(c config, op Op, opts ...threadOption) *ThreadMutation {
	m := &ThreadMutation{
		config:        c,
		op:            op,
		typ:           TypeThread,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadID sets the ID field of the mutation.
func withThreadID(id int) threadOption {
	return func(m *ThreadMutation) {
		var (
			err   error
			once  sync.Once
			value *Thread
		)
		m.oldValue = func(ctx context.Context) (*Thread, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Thread.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThread sets the old Thread of the mutation.
func withThread(node *Thread) threadOption {
	return func(m *ThreadMutation) {
		m.oldValue = func(context.Context) (*Thread, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Thread.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThreadMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThreadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThreadMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ThreadMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ThreadMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ThreadMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[thread.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ThreadMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[thread.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ThreadMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, thread.FieldDeletedAt)
}

// SetCategoryID sets the "category_id" field.
func (m *ThreadMutation) SetCategoryID(i int) {
	m.category = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *ThreadMutation) CategoryID() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *ThreadMutation) ResetCategoryID() {
	m.category = nil
}

// SetUserID sets the "user_id" field.
func (m *ThreadMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ThreadMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ThreadMutation) ResetUserID() {
	m.user = nil
}

// SetTitle sets the "title" field.
func (m *ThreadMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ThreadMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ThreadMutation) ResetTitle() {
	m.title = nil
}

// SetSummary sets the "summary" field.
func (m *ThreadMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *ThreadMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *ThreadMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[thread.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *ThreadMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[thread.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *ThreadMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, thread.FieldSummary)
}

// SetContentType sets the "content_type" field.
func (m *ThreadMutation) SetContentType(s string) {
	m.content_type = &s
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *ThreadMutation) ContentType() (r string, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ResetContentType resets all changes to the "content_type" field.
func (m *ThreadMutation) ResetContentType() {
	m.content_type = nil
}

// SetContentJSON sets the "content_json" field.
func (m *ThreadMutation) SetContentJSON(value map[string]interface{}) {
	m.content_json = &value
}

// ContentJSON returns the value of the "content_json" field in the mutation.
func (m *ThreadMutation) ContentJSON() (r map[string]interface{}, exists bool) {
	v := m.content_json
	if v == nil {
		return
	}
	return *v, true
}

// OldContentJSON returns the old "content_json" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldContentJSON(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentJSON: %w", err)
	}
	return oldValue.ContentJSON, nil
}

// ClearContentJSON clears the value of the "content_json" field.
func (m *ThreadMutation) ClearContentJSON() {
	m.content_json = nil
	m.clearedFields[thread.FieldContentJSON] = struct{}{}
}

// ContentJSONCleared returns if the "content_json" field was cleared in this mutation.
func (m *ThreadMutation) ContentJSONCleared() bool {
	_, ok := m.clearedFields[thread.FieldContentJSON]
	return ok
}

// ResetContentJSON resets all changes to the "content_json" field.
func (m *ThreadMutation) ResetContentJSON() {
	m.content_json = nil
	delete(m.clearedFields, thread.FieldContentJSON)
}

// SetMeta sets the "meta" field.
func (m *ThreadMutation) SetMeta(value map[string]interface{}) {
	m.meta = &value
}

// Meta returns the value of the "meta" field in the mutation.
func (m *ThreadMutation) Meta() (r map[string]interface{}, exists bool) {
	v := m.meta
	if v == nil {
		return
	}
	return *v, true
}

// OldMeta returns the old "meta" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldMeta(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeta: %w", err)
	}
	return oldValue.Meta, nil
}

// ClearMeta clears the value of the "meta" field.
func (m *ThreadMutation) ClearMeta() {
	m.meta = nil
	m.clearedFields[thread.FieldMeta] = struct{}{}
}

// MetaCleared returns if the "meta" field was cleared in this mutation.
func (m *ThreadMutation) MetaCleared() bool {
	_, ok := m.clearedFields[thread.FieldMeta]
	return ok
}

// ResetMeta resets all changes to the "meta" field.
func (m *ThreadMutation) ResetMeta() {
	m.meta = nil
	delete(m.clearedFields, thread.FieldMeta)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ThreadMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[thread.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ThreadMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ThreadMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *ThreadMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[thread.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *ThreadMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *ThreadMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ThreadMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ThreadMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ThreadMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ThreadMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ThreadMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ThreadMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ThreadMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddReceivedCredentialIDs adds the "received_credentials" edge to the ThreadCredential entity by ids.
func (m *ThreadMutation) AddReceivedCredentialIDs(ids ...int) {
	if m.received_credentials == nil {
		m.received_credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.received_credentials[ids[i]] = struct{}{}
	}
}

// ClearReceivedCredentials clears the "received_credentials" edge to the ThreadCredential entity.
func (m *ThreadMutation) ClearReceivedCredentials() {
	m.clearedreceived_credentials = true
}

// ReceivedCredentialsCleared reports if the "received_credentials" edge to the ThreadCredential entity was cleared.
func (m *ThreadMutation) ReceivedCredentialsCleared() bool {
	return m.clearedreceived_credentials
}

// RemoveReceivedCredentialIDs removes the "received_credentials" edge to the ThreadCredential entity by IDs.
func (m *ThreadMutation) RemoveReceivedCredentialIDs(ids ...int) {
	if m.removedreceived_credentials == nil {
		m.removedreceived_credentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.received_credentials, ids[i])
		m.removedreceived_credentials[ids[i]] = struct{}{}
	}
}

// RemovedReceivedCredentials returns the removed IDs of the "received_credentials" edge to the ThreadCredential entity.
func (m *ThreadMutation) RemovedReceivedCredentialsIDs() (ids []int) {
	for id := range m.removedreceived_credentials {
		ids = append(ids, id)
	}
	return
}

// ReceivedCredentialsIDs returns the "received_credentials" edge IDs in the mutation.
func (m *ThreadMutation) ReceivedCredentialsIDs() (ids []int) {
	for id := range m.received_credentials {
		ids = append(ids, id)
	}
	return
}

// ResetReceivedCredentials resets all changes to the "received_credentials" edge.
func (m *ThreadMutation) ResetReceivedCredentials() {
	m.received_credentials = nil
	m.clearedreceived_credentials = false
	m.removedreceived_credentials = nil
}

// Where appends a list predicates to the ThreadMutation builder.
func (m *ThreadMutation) Where(ps ...predicate.Thread) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Thread, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Thread).
func (m *ThreadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, thread.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, thread.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, thread.FieldDeletedAt)
	}
	if m.category != nil {
		fields = append(fields, thread.FieldCategoryID)
	}
	if m.user != nil {
		fields = append(fields, thread.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, thread.FieldTitle)
	}
	if m.summary != nil {
		fields = append(fields, thread.FieldSummary)
	}
	if m.content_type != nil {
		fields = append(fields, thread.FieldContentType)
	}
	if m.content_json != nil {
		fields = append(fields, thread.FieldContentJSON)
	}
	if m.meta != nil {
		fields = append(fields, thread.FieldMeta)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldCreatedAt:
		return m.CreatedAt()
	case thread.FieldUpdatedAt:
		return m.UpdatedAt()
	case thread.FieldDeletedAt:
		return m.DeletedAt()
	case thread.FieldCategoryID:
		return m.CategoryID()
	case thread.FieldUserID:
		return m.UserID()
	case thread.FieldTitle:
		return m.Title()
	case thread.FieldSummary:
		return m.Summary()
	case thread.FieldContentType:
		return m.ContentType()
	case thread.FieldContentJSON:
		return m.ContentJSON()
	case thread.FieldMeta:
		return m.Meta()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case thread.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case thread.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case thread.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case thread.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case thread.FieldUserID:
		return m.OldUserID(ctx)
	case thread.FieldTitle:
		return m.OldTitle(ctx)
	case thread.FieldSummary:
		return m.OldSummary(ctx)
	case thread.FieldContentType:
		return m.OldContentType(ctx)
	case thread.FieldContentJSON:
		return m.OldContentJSON(ctx)
	case thread.FieldMeta:
		return m.OldMeta(ctx)
	}
	return nil, fmt.Errorf("unknown Thread field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case thread.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case thread.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case thread.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case thread.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case thread.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case thread.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case thread.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case thread.FieldContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case thread.FieldContentJSON:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentJSON(v)
		return nil
	case thread.FieldMeta:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeta(v)
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Thread numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(thread.FieldDeletedAt) {
		fields = append(fields, thread.FieldDeletedAt)
	}
	if m.FieldCleared(thread.FieldSummary) {
		fields = append(fields, thread.FieldSummary)
	}
	if m.FieldCleared(thread.FieldContentJSON) {
		fields = append(fields, thread.FieldContentJSON)
	}
	if m.FieldCleared(thread.FieldMeta) {
		fields = append(fields, thread.FieldMeta)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadMutation) ClearField(name string) error {
	switch name {
	case thread.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case thread.FieldSummary:
		m.ClearSummary()
		return nil
	case thread.FieldContentJSON:
		m.ClearContentJSON()
		return nil
	case thread.FieldMeta:
		m.ClearMeta()
		return nil
	}
	return fmt.Errorf("unknown Thread nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadMutation) ResetField(name string) error {
	switch name {
	case thread.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case thread.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case thread.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case thread.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case thread.FieldUserID:
		m.ResetUserID()
		return nil
	case thread.FieldTitle:
		m.ResetTitle()
		return nil
	case thread.FieldSummary:
		m.ResetSummary()
		return nil
	case thread.FieldContentType:
		m.ResetContentType()
		return nil
	case thread.FieldContentJSON:
		m.ResetContentJSON()
		return nil
	case thread.FieldMeta:
		m.ResetMeta()
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, thread.EdgeUser)
	}
	if m.category != nil {
		edges = append(edges, thread.EdgeCategory)
	}
	if m.tags != nil {
		edges = append(edges, thread.EdgeTags)
	}
	if m.received_credentials != nil {
		edges = append(edges, thread.EdgeReceivedCredentials)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeReceivedCredentials:
		ids := make([]ent.Value, 0, len(m.received_credentials))
		for id := range m.received_credentials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtags != nil {
		edges = append(edges, thread.EdgeTags)
	}
	if m.removedreceived_credentials != nil {
		edges = append(edges, thread.EdgeReceivedCredentials)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeReceivedCredentials:
		ids := make([]ent.Value, 0, len(m.removedreceived_credentials))
		for id := range m.removedreceived_credentials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, thread.EdgeUser)
	}
	if m.clearedcategory {
		edges = append(edges, thread.EdgeCategory)
	}
	if m.clearedtags {
		edges = append(edges, thread.EdgeTags)
	}
	if m.clearedreceived_credentials {
		edges = append(edges, thread.EdgeReceivedCredentials)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadMutation) EdgeCleared(name string) bool {
	switch name {
	case thread.EdgeUser:
		return m.cleareduser
	case thread.EdgeCategory:
		return m.clearedcategory
	case thread.EdgeTags:
		return m.clearedtags
	case thread.EdgeReceivedCredentials:
		return m.clearedreceived_credentials
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadMutation) ClearEdge(name string) error {
	switch name {
	case thread.EdgeUser:
		m.ClearUser()
		return nil
	case thread.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Thread unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadMutation) ResetEdge(name string) error {
	switch name {
	case thread.EdgeUser:
		m.ResetUser()
		return nil
	case thread.EdgeCategory:
		m.ResetCategory()
		return nil
	case thread.EdgeTags:
		m.ResetTags()
		return nil
	case thread.EdgeReceivedCredentials:
		m.ResetReceivedCredentials()
		return nil
	}
	return fmt.Errorf("unknown Thread edge %s", name)
}

// ThreadCredentialMutation represents an operation that mutates the ThreadCredential nodes in the graph.
type ThreadCredentialMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	thread        *int
	clearedthread bool
	done          bool
	oldValue      func(context.Context) (*ThreadCredential, error)
	predicates    []predicate.ThreadCredential
}

var _ ent.Mutation = (*ThreadCredentialMutation)(nil)

// threadcredentialOption allows management of the mutation configuration using functional options.
type threadcredentialOption func(*ThreadCredentialMutation)

// newThreadCredentialMutation creates new mutation for the ThreadCredential entity.
func newThreadCredentialMutation(c config, op Op, opts ...threadcredentialOption) *ThreadCredentialMutation {
	m := &ThreadCredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadCredentialID sets the ID field of the mutation.
func withThreadCredentialID(id int) threadcredentialOption {
	return func(m *ThreadCredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *ThreadCredential
		)
		m.oldValue = func(ctx context.Context) (*ThreadCredential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThreadCredential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreadCredential sets the old ThreadCredential of the mutation.
func withThreadCredential(node *ThreadCredential) threadcredentialOption {
	return func(m *ThreadCredentialMutation) {
		m.oldValue = func(context.Context) (*ThreadCredential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadCredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadCredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadCredentialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadCredentialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThreadCredential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadCredentialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadCredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ThreadCredential entity.
// If the ThreadCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadCredentialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThreadCredentialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThreadCredentialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ThreadCredential entity.
// If the ThreadCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCredentialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThreadCredentialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ThreadCredentialMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ThreadCredentialMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ThreadCredential entity.
// If the ThreadCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCredentialMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ThreadCredentialMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[threadcredential.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ThreadCredentialMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[threadcredential.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ThreadCredentialMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, threadcredential.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *ThreadCredentialMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ThreadCredentialMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ThreadCredential entity.
// If the ThreadCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCredentialMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ThreadCredentialMutation) ResetUserID() {
	m.user = nil
}

// SetThreadID sets the "thread_id" field.
func (m *ThreadCredentialMutation) SetThreadID(i int) {
	m.thread = &i
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *ThreadCredentialMutation) ThreadID() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// OldThreadID returns the old "thread_id" field's value of the ThreadCredential entity.
// If the ThreadCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCredentialMutation) OldThreadID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreadID: %w", err)
	}
	return oldValue.ThreadID, nil
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *ThreadCredentialMutation) ResetThreadID() {
	m.thread = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ThreadCredentialMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[threadcredential.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ThreadCredentialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ThreadCredentialMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ThreadCredentialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *ThreadCredentialMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[threadcredential.FieldThreadID] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *ThreadCredentialMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *ThreadCredentialMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *ThreadCredentialMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// Where appends a list predicates to the ThreadCredentialMutation builder.
func (m *ThreadCredentialMutation) Where(ps ...predicate.ThreadCredential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadCredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadCredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadCredential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadCredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadCredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadCredential).
func (m *ThreadCredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadCredentialMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, threadcredential.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, threadcredential.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, threadcredential.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, threadcredential.FieldUserID)
	}
	if m.thread != nil {
		fields = append(fields, threadcredential.FieldThreadID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadCredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threadcredential.FieldCreatedAt:
		return m.CreatedAt()
	case threadcredential.FieldUpdatedAt:
		return m.UpdatedAt()
	case threadcredential.FieldDeletedAt:
		return m.DeletedAt()
	case threadcredential.FieldUserID:
		return m.UserID()
	case threadcredential.FieldThreadID:
		return m.ThreadID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadCredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case threadcredential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case threadcredential.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case threadcredential.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case threadcredential.FieldUserID:
		return m.OldUserID(ctx)
	case threadcredential.FieldThreadID:
		return m.OldThreadID(ctx)
	}
	return nil, fmt.Errorf("unknown ThreadCredential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadCredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threadcredential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case threadcredential.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case threadcredential.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case threadcredential.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case threadcredential.FieldThreadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadCredential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadCredentialMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadCredentialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadCredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ThreadCredential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadCredentialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(threadcredential.FieldDeletedAt) {
		fields = append(fields, threadcredential.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadCredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadCredentialMutation) ClearField(name string) error {
	switch name {
	case threadcredential.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ThreadCredential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadCredentialMutation) ResetField(name string) error {
	switch name {
	case threadcredential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case threadcredential.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case threadcredential.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case threadcredential.FieldUserID:
		m.ResetUserID()
		return nil
	case threadcredential.FieldThreadID:
		m.ResetThreadID()
		return nil
	}
	return fmt.Errorf("unknown ThreadCredential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadCredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, threadcredential.EdgeUser)
	}
	if m.thread != nil {
		edges = append(edges, threadcredential.EdgeThread)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadCredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threadcredential.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case threadcredential.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadCredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadCredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadCredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, threadcredential.EdgeUser)
	}
	if m.clearedthread {
		edges = append(edges, threadcredential.EdgeThread)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadCredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case threadcredential.EdgeUser:
		return m.cleareduser
	case threadcredential.EdgeThread:
		return m.clearedthread
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadCredentialMutation) ClearEdge(name string) error {
	switch name {
	case threadcredential.EdgeUser:
		m.ClearUser()
		return nil
	case threadcredential.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown ThreadCredential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadCredentialMutation) ResetEdge(name string) error {
	switch name {
	case threadcredential.EdgeUser:
		m.ResetUser()
		return nil
	case threadcredential.EdgeThread:
		m.ResetThread()
		return nil
	}
	return fmt.Errorf("unknown ThreadCredential edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	email                            *string
	username                         *string
	password_hash                    *string
	email_verified                   *bool
	avatar_url                       *string
	full_name                        *string
	bio                              *string
	pronouns                         *string
	company                          *string
	telegram                         *string
	social_accounts                  *map[string]interface{}
	totp_secret                      *string
	totp_enabled                     *bool
	totp_verified                    *bool
	totp_verified_at                 *time.Time
	failed_login_attempts            *int
	addfailed_login_attempts         *int
	last_failed_at                   *time.Time
	last_login_at                    *time.Time
	last_login_ip                    *string
	locked_until                     *time.Time
	lock_reason                      *string
	guarantee_amount                 *int64
	addguarantee_amount              *int64
	clearedFields                    map[string]struct{}
	passkeys                         map[int]struct{}
	removedpasskeys                  map[int]struct{}
	clearedpasskeys                  bool
	sessions                         map[int]struct{}
	removedsessions                  map[int]struct{}
	clearedsessions                  bool
	backup_codes                     map[int]struct{}
	removedbackup_codes              map[int]struct{}
	clearedbackup_codes              bool
	threads                          map[int]struct{}
	removedthreads                   map[int]struct{}
	clearedthreads                   bool
	user_badges                      map[int]struct{}
	removeduser_badges               map[int]struct{}
	cleareduser_badges               bool
	session_locks                    map[int]struct{}
	removedsession_locks             map[int]struct{}
	clearedsession_locks             bool
	email_verification_tokens        map[int]struct{}
	removedemail_verification_tokens map[int]struct{}
	clearedemail_verification_tokens bool
	password_reset_tokens            map[int]struct{}
	removedpassword_reset_tokens     map[int]struct{}
	clearedpassword_reset_tokens     bool
	credentials                      map[int]struct{}
	removedcredentials               map[int]struct{}
	clearedcredentials               bool
	totp_pending_tokens              map[int]struct{}
	removedtotp_pending_tokens       map[int]struct{}
	clearedtotp_pending_tokens       bool
	security_events                  map[int]struct{}
	removedsecurity_events           map[int]struct{}
	clearedsecurity_events           bool
	device_fingerprints              map[int]struct{}
	removeddevice_fingerprints       map[int]struct{}
	cleareddevice_fingerprints       bool
	device_user_mappings             map[int]struct{}
	removeddevice_user_mappings      map[int]struct{}
	cleareddevice_user_mappings      bool
	sudo_sessions                    map[int]struct{}
	removedsudo_sessions             map[int]struct{}
	clearedsudo_sessions             bool
	given_credentials                map[int]struct{}
	removedgiven_credentials         map[int]struct{}
	clearedgiven_credentials         bool
	primary_badge                    *int
	clearedprimary_badge             bool
	done                             bool
	oldValue                         func(context.Context) (*User, error)
	predicates                       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetFullName sets the "full_name" field.
func (m *UserMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *UserMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFullName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ClearFullName clears the value of the "full_name" field.
func (m *UserMutation) ClearFullName() {
	m.full_name = nil
	m.clearedFields[user.FieldFullName] = struct{}{}
}

// FullNameCleared returns if the "full_name" field was cleared in this mutation.
func (m *UserMutation) FullNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFullName]
	return ok
}

// ResetFullName resets all changes to the "full_name" field.
func (m *UserMutation) ResetFullName() {
	m.full_name = nil
	delete(m.clearedFields, user.FieldFullName)
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetPronouns sets the "pronouns" field.
func (m *UserMutation) SetPronouns(s string) {
	m.pronouns = &s
}

// Pronouns returns the value of the "pronouns" field in the mutation.
func (m *UserMutation) Pronouns() (r string, exists bool) {
	v := m.pronouns
	if v == nil {
		return
	}
	return *v, true
}

// OldPronouns returns the old "pronouns" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPronouns(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPronouns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPronouns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPronouns: %w", err)
	}
	return oldValue.Pronouns, nil
}

// ClearPronouns clears the value of the "pronouns" field.
func (m *UserMutation) ClearPronouns() {
	m.pronouns = nil
	m.clearedFields[user.FieldPronouns] = struct{}{}
}

// PronounsCleared returns if the "pronouns" field was cleared in this mutation.
func (m *UserMutation) PronounsCleared() bool {
	_, ok := m.clearedFields[user.FieldPronouns]
	return ok
}

// ResetPronouns resets all changes to the "pronouns" field.
func (m *UserMutation) ResetPronouns() {
	m.pronouns = nil
	delete(m.clearedFields, user.FieldPronouns)
}

// SetCompany sets the "company" field.
func (m *UserMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *UserMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *UserMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[user.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *UserMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[user.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *UserMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, user.FieldCompany)
}

// SetTelegram sets the "telegram" field.
func (m *UserMutation) SetTelegram(s string) {
	m.telegram = &s
}

// Telegram returns the value of the "telegram" field in the mutation.
func (m *UserMutation) Telegram() (r string, exists bool) {
	v := m.telegram
	if v == nil {
		return
	}
	return *v, true
}

// OldTelegram returns the old "telegram" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTelegram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelegram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelegram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelegram: %w", err)
	}
	return oldValue.Telegram, nil
}

// ClearTelegram clears the value of the "telegram" field.
func (m *UserMutation) ClearTelegram() {
	m.telegram = nil
	m.clearedFields[user.FieldTelegram] = struct{}{}
}

// TelegramCleared returns if the "telegram" field was cleared in this mutation.
func (m *UserMutation) TelegramCleared() bool {
	_, ok := m.clearedFields[user.FieldTelegram]
	return ok
}

// ResetTelegram resets all changes to the "telegram" field.
func (m *UserMutation) ResetTelegram() {
	m.telegram = nil
	delete(m.clearedFields, user.FieldTelegram)
}

// SetSocialAccounts sets the "social_accounts" field.
func (m *UserMutation) SetSocialAccounts(value map[string]interface{}) {
	m.social_accounts = &value
}

// SocialAccounts returns the value of the "social_accounts" field in the mutation.
func (m *UserMutation) SocialAccounts() (r map[string]interface{}, exists bool) {
	v := m.social_accounts
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialAccounts returns the old "social_accounts" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSocialAccounts(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialAccounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialAccounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialAccounts: %w", err)
	}
	return oldValue.SocialAccounts, nil
}

// ClearSocialAccounts clears the value of the "social_accounts" field.
func (m *UserMutation) ClearSocialAccounts() {
	m.social_accounts = nil
	m.clearedFields[user.FieldSocialAccounts] = struct{}{}
}

// SocialAccountsCleared returns if the "social_accounts" field was cleared in this mutation.
func (m *UserMutation) SocialAccountsCleared() bool {
	_, ok := m.clearedFields[user.FieldSocialAccounts]
	return ok
}

// ResetSocialAccounts resets all changes to the "social_accounts" field.
func (m *UserMutation) ResetSocialAccounts() {
	m.social_accounts = nil
	delete(m.clearedFields, user.FieldSocialAccounts)
}

// SetPrimaryBadgeID sets the "primary_badge_id" field.
func (m *UserMutation) SetPrimaryBadgeID(i int) {
	m.primary_badge = &i
}

// PrimaryBadgeID returns the value of the "primary_badge_id" field in the mutation.
func (m *UserMutation) PrimaryBadgeID() (r int, exists bool) {
	v := m.primary_badge
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryBadgeID returns the old "primary_badge_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrimaryBadgeID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryBadgeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryBadgeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryBadgeID: %w", err)
	}
	return oldValue.PrimaryBadgeID, nil
}

// ClearPrimaryBadgeID clears the value of the "primary_badge_id" field.
func (m *UserMutation) ClearPrimaryBadgeID() {
	m.primary_badge = nil
	m.clearedFields[user.FieldPrimaryBadgeID] = struct{}{}
}

// PrimaryBadgeIDCleared returns if the "primary_badge_id" field was cleared in this mutation.
func (m *UserMutation) PrimaryBadgeIDCleared() bool {
	_, ok := m.clearedFields[user.FieldPrimaryBadgeID]
	return ok
}

// ResetPrimaryBadgeID resets all changes to the "primary_badge_id" field.
func (m *UserMutation) ResetPrimaryBadgeID() {
	m.primary_badge = nil
	delete(m.clearedFields, user.FieldPrimaryBadgeID)
}

// SetTotpSecret sets the "totp_secret" field.
func (m *UserMutation) SetTotpSecret(s string) {
	m.totp_secret = &s
}

// TotpSecret returns the value of the "totp_secret" field in the mutation.
func (m *UserMutation) TotpSecret() (r string, exists bool) {
	v := m.totp_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpSecret returns the old "totp_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpSecret(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpSecret: %w", err)
	}
	return oldValue.TotpSecret, nil
}

// ClearTotpSecret clears the value of the "totp_secret" field.
func (m *UserMutation) ClearTotpSecret() {
	m.totp_secret = nil
	m.clearedFields[user.FieldTotpSecret] = struct{}{}
}

// TotpSecretCleared returns if the "totp_secret" field was cleared in this mutation.
func (m *UserMutation) TotpSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldTotpSecret]
	return ok
}

// ResetTotpSecret resets all changes to the "totp_secret" field.
func (m *UserMutation) ResetTotpSecret() {
	m.totp_secret = nil
	delete(m.clearedFields, user.FieldTotpSecret)
}

// SetTotpEnabled sets the "totp_enabled" field.
func (m *UserMutation) SetTotpEnabled(b bool) {
	m.totp_enabled = &b
}

// TotpEnabled returns the value of the "totp_enabled" field in the mutation.
func (m *UserMutation) TotpEnabled() (r bool, exists bool) {
	v := m.totp_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpEnabled returns the old "totp_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpEnabled: %w", err)
	}
	return oldValue.TotpEnabled, nil
}

// ResetTotpEnabled resets all changes to the "totp_enabled" field.
func (m *UserMutation) ResetTotpEnabled() {
	m.totp_enabled = nil
}

// SetTotpVerified sets the "totp_verified" field.
func (m *UserMutation) SetTotpVerified(b bool) {
	m.totp_verified = &b
}

// TotpVerified returns the value of the "totp_verified" field in the mutation.
func (m *UserMutation) TotpVerified() (r bool, exists bool) {
	v := m.totp_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpVerified returns the old "totp_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpVerified: %w", err)
	}
	return oldValue.TotpVerified, nil
}

// ResetTotpVerified resets all changes to the "totp_verified" field.
func (m *UserMutation) ResetTotpVerified() {
	m.totp_verified = nil
}

// SetTotpVerifiedAt sets the "totp_verified_at" field.
func (m *UserMutation) SetTotpVerifiedAt(t time.Time) {
	m.totp_verified_at = &t
}

// TotpVerifiedAt returns the value of the "totp_verified_at" field in the mutation.
func (m *UserMutation) TotpVerifiedAt() (r time.Time, exists bool) {
	v := m.totp_verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpVerifiedAt returns the old "totp_verified_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpVerifiedAt: %w", err)
	}
	return oldValue.TotpVerifiedAt, nil
}

// ClearTotpVerifiedAt clears the value of the "totp_verified_at" field.
func (m *UserMutation) ClearTotpVerifiedAt() {
	m.totp_verified_at = nil
	m.clearedFields[user.FieldTotpVerifiedAt] = struct{}{}
}

// TotpVerifiedAtCleared returns if the "totp_verified_at" field was cleared in this mutation.
func (m *UserMutation) TotpVerifiedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldTotpVerifiedAt]
	return ok
}

// ResetTotpVerifiedAt resets all changes to the "totp_verified_at" field.
func (m *UserMutation) ResetTotpVerifiedAt() {
	m.totp_verified_at = nil
	delete(m.clearedFields, user.FieldTotpVerifiedAt)
}

// SetFailedLoginAttempts sets the "failed_login_attempts" field.
func (m *UserMutation) SetFailedLoginAttempts(i int) {
	m.failed_login_attempts = &i
	m.addfailed_login_attempts = nil
}

// FailedLoginAttempts returns the value of the "failed_login_attempts" field in the mutation.
func (m *UserMutation) FailedLoginAttempts() (r int, exists bool) {
	v := m.failed_login_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedLoginAttempts returns the old "failed_login_attempts" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFailedLoginAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedLoginAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedLoginAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedLoginAttempts: %w", err)
	}
	return oldValue.FailedLoginAttempts, nil
}

// AddFailedLoginAttempts adds i to the "failed_login_attempts" field.
func (m *UserMutation) AddFailedLoginAttempts(i int) {
	if m.addfailed_login_attempts != nil {
		*m.addfailed_login_attempts += i
	} else {
		m.addfailed_login_attempts = &i
	}
}

// AddedFailedLoginAttempts returns the value that was added to the "failed_login_attempts" field in this mutation.
func (m *UserMutation) AddedFailedLoginAttempts() (r int, exists bool) {
	v := m.addfailed_login_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailedLoginAttempts resets all changes to the "failed_login_attempts" field.
func (m *UserMutation) ResetFailedLoginAttempts() {
	m.failed_login_attempts = nil
	m.addfailed_login_attempts = nil
}

// SetLastFailedAt sets the "last_failed_at" field.
func (m *UserMutation) SetLastFailedAt(t time.Time) {
	m.last_failed_at = &t
}

// LastFailedAt returns the value of the "last_failed_at" field in the mutation.
func (m *UserMutation) LastFailedAt() (r time.Time, exists bool) {
	v := m.last_failed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastFailedAt returns the old "last_failed_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastFailedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastFailedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastFailedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastFailedAt: %w", err)
	}
	return oldValue.LastFailedAt, nil
}

// ClearLastFailedAt clears the value of the "last_failed_at" field.
func (m *UserMutation) ClearLastFailedAt() {
	m.last_failed_at = nil
	m.clearedFields[user.FieldLastFailedAt] = struct{}{}
}

// LastFailedAtCleared returns if the "last_failed_at" field was cleared in this mutation.
func (m *UserMutation) LastFailedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastFailedAt]
	return ok
}

// ResetLastFailedAt resets all changes to the "last_failed_at" field.
func (m *UserMutation) ResetLastFailedAt() {
	m.last_failed_at = nil
	delete(m.clearedFields, user.FieldLastFailedAt)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *UserMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *UserMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (m *UserMutation) ClearLastLoginIP() {
	m.last_login_ip = nil
	m.clearedFields[user.FieldLastLoginIP] = struct{}{}
}

// LastLoginIPCleared returns if the "last_login_ip" field was cleared in this mutation.
func (m *UserMutation) LastLoginIPCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginIP]
	return ok
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *UserMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
	delete(m.clearedFields, user.FieldLastLoginIP)
}

// SetLockedUntil sets the "locked_until" field.
func (m *UserMutation) SetLockedUntil(t time.Time) {
	m.locked_until = &t
}

// LockedUntil returns the value of the "locked_until" field in the mutation.
func (m *UserMutation) LockedUntil() (r time.Time, exists bool) {
	v := m.locked_until
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedUntil returns the old "locked_until" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLockedUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedUntil: %w", err)
	}
	return oldValue.LockedUntil, nil
}

// ClearLockedUntil clears the value of the "locked_until" field.
func (m *UserMutation) ClearLockedUntil() {
	m.locked_until = nil
	m.clearedFields[user.FieldLockedUntil] = struct{}{}
}

// LockedUntilCleared returns if the "locked_until" field was cleared in this mutation.
func (m *UserMutation) LockedUntilCleared() bool {
	_, ok := m.clearedFields[user.FieldLockedUntil]
	return ok
}

// ResetLockedUntil resets all changes to the "locked_until" field.
func (m *UserMutation) ResetLockedUntil() {
	m.locked_until = nil
	delete(m.clearedFields, user.FieldLockedUntil)
}

// SetLockReason sets the "lock_reason" field.
func (m *UserMutation) SetLockReason(s string) {
	m.lock_reason = &s
}

// LockReason returns the value of the "lock_reason" field in the mutation.
func (m *UserMutation) LockReason() (r string, exists bool) {
	v := m.lock_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldLockReason returns the old "lock_reason" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLockReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockReason: %w", err)
	}
	return oldValue.LockReason, nil
}

// ClearLockReason clears the value of the "lock_reason" field.
func (m *UserMutation) ClearLockReason() {
	m.lock_reason = nil
	m.clearedFields[user.FieldLockReason] = struct{}{}
}

// LockReasonCleared returns if the "lock_reason" field was cleared in this mutation.
func (m *UserMutation) LockReasonCleared() bool {
	_, ok := m.clearedFields[user.FieldLockReason]
	return ok
}

// ResetLockReason resets all changes to the "lock_reason" field.
func (m *UserMutation) ResetLockReason() {
	m.lock_reason = nil
	delete(m.clearedFields, user.FieldLockReason)
}

// SetGuaranteeAmount sets the "guarantee_amount" field.
func (m *UserMutation) SetGuaranteeAmount(i int64) {
	m.guarantee_amount = &i
	m.addguarantee_amount = nil
}

// GuaranteeAmount returns the value of the "guarantee_amount" field in the mutation.
func (m *UserMutation) GuaranteeAmount() (r int64, exists bool) {
	v := m.guarantee_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldGuaranteeAmount returns the old "guarantee_amount" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGuaranteeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuaranteeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuaranteeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuaranteeAmount: %w", err)
	}
	return oldValue.GuaranteeAmount, nil
}

// AddGuaranteeAmount adds i to the "guarantee_amount" field.
func (m *UserMutation) AddGuaranteeAmount(i int64) {
	if m.addguarantee_amount != nil {
		*m.addguarantee_amount += i
	} else {
		m.addguarantee_amount = &i
	}
}

// AddedGuaranteeAmount returns the value that was added to the "guarantee_amount" field in this mutation.
func (m *UserMutation) AddedGuaranteeAmount() (r int64, exists bool) {
	v := m.addguarantee_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetGuaranteeAmount resets all changes to the "guarantee_amount" field.
func (m *UserMutation) ResetGuaranteeAmount() {
	m.guarantee_amount = nil
	m.addguarantee_amount = nil
}

// AddPasskeyIDs adds the "passkeys" edge to the Passkey entity by ids.
func (m *UserMutation) AddPasskeyIDs(ids ...int) {
	if m.passkeys == nil {
		m.passkeys = make(map[int]struct{})
	}
	for i := range ids {
		m.passkeys[ids[i]] = struct{}{}
	}
}

// ClearPasskeys clears the "passkeys" edge to the Passkey entity.
func (m *UserMutation) ClearPasskeys() {
	m.clearedpasskeys = true
}

// PasskeysCleared reports if the "passkeys" edge to the Passkey entity was cleared.
func (m *UserMutation) PasskeysCleared() bool {
	return m.clearedpasskeys
}

// RemovePasskeyIDs removes the "passkeys" edge to the Passkey entity by IDs.
func (m *UserMutation) RemovePasskeyIDs(ids ...int) {
	if m.removedpasskeys == nil {
		m.removedpasskeys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.passkeys, ids[i])
		m.removedpasskeys[ids[i]] = struct{}{}
	}
}

// RemovedPasskeys returns the removed IDs of the "passkeys" edge to the Passkey entity.
func (m *UserMutation) RemovedPasskeysIDs() (ids []int) {
	for id := range m.removedpasskeys {
		ids = append(ids, id)
	}
	return
}

// PasskeysIDs returns the "passkeys" edge IDs in the mutation.
func (m *UserMutation) PasskeysIDs() (ids []int) {
	for id := range m.passkeys {
		ids = append(ids, id)
	}
	return
}

// ResetPasskeys resets all changes to the "passkeys" edge.
func (m *UserMutation) ResetPasskeys() {
	m.passkeys = nil
	m.clearedpasskeys = false
	m.removedpasskeys = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddBackupCodeIDs adds the "backup_codes" edge to the BackupCode entity by ids.
func (m *UserMutation) AddBackupCodeIDs(ids ...int) {
	if m.backup_codes == nil {
		m.backup_codes = make(map[int]struct{})
	}
	for i := range ids {
		m.backup_codes[ids[i]] = struct{}{}
	}
}

// ClearBackupCodes clears the "backup_codes" edge to the BackupCode entity.
func (m *UserMutation) ClearBackupCodes() {
	m.clearedbackup_codes = true
}

// BackupCodesCleared reports if the "backup_codes" edge to the BackupCode entity was cleared.
func (m *UserMutation) BackupCodesCleared() bool {
	return m.clearedbackup_codes
}

// RemoveBackupCodeIDs removes the "backup_codes" edge to the BackupCode entity by IDs.
func (m *UserMutation) RemoveBackupCodeIDs(ids ...int) {
	if m.removedbackup_codes == nil {
		m.removedbackup_codes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.backup_codes, ids[i])
		m.removedbackup_codes[ids[i]] = struct{}{}
	}
}

// RemovedBackupCodes returns the removed IDs of the "backup_codes" edge to the BackupCode entity.
func (m *UserMutation) RemovedBackupCodesIDs() (ids []int) {
	for id := range m.removedbackup_codes {
		ids = append(ids, id)
	}
	return
}

// BackupCodesIDs returns the "backup_codes" edge IDs in the mutation.
func (m *UserMutation) BackupCodesIDs() (ids []int) {
	for id := range m.backup_codes {
		ids = append(ids, id)
	}
	return
}

// ResetBackupCodes resets all changes to the "backup_codes" edge.
func (m *UserMutation) ResetBackupCodes() {
	m.backup_codes = nil
	m.clearedbackup_codes = false
	m.removedbackup_codes = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *UserMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *UserMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *UserMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *UserMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *UserMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *UserMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *UserMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// AddUserBadgeIDs adds the "user_badges" edge to the UserBadge entity by ids.
func (m *UserMutation) AddUserBadgeIDs(ids ...int) {
	if m.user_badges == nil {
		m.user_badges = make(map[int]struct{})
	}
	for i := range ids {
		m.user_badges[ids[i]] = struct{}{}
	}
}

// ClearUserBadges clears the "user_badges" edge to the UserBadge entity.
func (m *UserMutation) ClearUserBadges() {
	m.cleareduser_badges = true
}

// UserBadgesCleared reports if the "user_badges" edge to the UserBadge entity was cleared.
func (m *UserMutation) UserBadgesCleared() bool {
	return m.cleareduser_badges
}

// RemoveUserBadgeIDs removes the "user_badges" edge to the UserBadge entity by IDs.
func (m *UserMutation) RemoveUserBadgeIDs(ids ...int) {
	if m.removeduser_badges == nil {
		m.removeduser_badges = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_badges, ids[i])
		m.removeduser_badges[ids[i]] = struct{}{}
	}
}

// RemovedUserBadges returns the removed IDs of the "user_badges" edge to the UserBadge entity.
func (m *UserMutation) RemovedUserBadgesIDs() (ids []int) {
	for id := range m.removeduser_badges {
		ids = append(ids, id)
	}
	return
}

// UserBadgesIDs returns the "user_badges" edge IDs in the mutation.
func (m *UserMutation) UserBadgesIDs() (ids []int) {
	for id := range m.user_badges {
		ids = append(ids, id)
	}
	return
}

// ResetUserBadges resets all changes to the "user_badges" edge.
func (m *UserMutation) ResetUserBadges() {
	m.user_badges = nil
	m.cleareduser_badges = false
	m.removeduser_badges = nil
}

// AddSessionLockIDs adds the "session_locks" edge to the SessionLock entity by ids.
func (m *UserMutation) AddSessionLockIDs(ids ...int) {
	if m.session_locks == nil {
		m.session_locks = make(map[int]struct{})
	}
	for i := range ids {
		m.session_locks[ids[i]] = struct{}{}
	}
}

// ClearSessionLocks clears the "session_locks" edge to the SessionLock entity.
func (m *UserMutation) ClearSessionLocks() {
	m.clearedsession_locks = true
}

// SessionLocksCleared reports if the "session_locks" edge to the SessionLock entity was cleared.
func (m *UserMutation) SessionLocksCleared() bool {
	return m.clearedsession_locks
}

// RemoveSessionLockIDs removes the "session_locks" edge to the SessionLock entity by IDs.
func (m *UserMutation) RemoveSessionLockIDs(ids ...int) {
	if m.removedsession_locks == nil {
		m.removedsession_locks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.session_locks, ids[i])
		m.removedsession_locks[ids[i]] = struct{}{}
	}
}

// RemovedSessionLocks returns the removed IDs of the "session_locks" edge to the SessionLock entity.
func (m *UserMutation) RemovedSessionLocksIDs() (ids []int) {
	for id := range m.removedsession_locks {
		ids = append(ids, id)
	}
	return
}

// SessionLocksIDs returns the "session_locks" edge IDs in the mutation.
func (m *UserMutation) SessionLocksIDs() (ids []int) {
	for id := range m.session_locks {
		ids = append(ids, id)
	}
	return
}

// ResetSessionLocks resets all changes to the "session_locks" edge.
func (m *UserMutation) ResetSessionLocks() {
	m.session_locks = nil
	m.clearedsession_locks = false
	m.removedsession_locks = nil
}

// AddEmailVerificationTokenIDs adds the "email_verification_tokens" edge to the EmailVerificationToken entity by ids.
func (m *UserMutation) AddEmailVerificationTokenIDs(ids ...int) {
	if m.email_verification_tokens == nil {
		m.email_verification_tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.email_verification_tokens[ids[i]] = struct{}{}
	}
}

// ClearEmailVerificationTokens clears the "email_verification_tokens" edge to the EmailVerificationToken entity.
func (m *UserMutation) ClearEmailVerificationTokens() {
	m.clearedemail_verification_tokens = true
}

// EmailVerificationTokensCleared reports if the "email_verification_tokens" edge to the EmailVerificationToken entity was cleared.
func (m *UserMutation) EmailVerificationTokensCleared() bool {
	return m.clearedemail_verification_tokens
}

// RemoveEmailVerificationTokenIDs removes the "email_verification_tokens" edge to the EmailVerificationToken entity by IDs.
func (m *UserMutation) RemoveEmailVerificationTokenIDs(ids ...int) {
	if m.removedemail_verification_tokens == nil {
		m.removedemail_verification_tokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.email_verification_tokens, ids[i])
		m.removedemail_verification_tokens[ids[i]] = struct{}{}
	}
}

// RemovedEmailVerificationTokens returns the removed IDs of the "email_verification_tokens" edge to the EmailVerificationToken entity.
func (m *UserMutation) RemovedEmailVerificationTokensIDs() (ids []int) {
	for id := range m.removedemail_verification_tokens {
		ids = append(ids, id)
	}
	return
}

// EmailVerificationTokensIDs returns the "email_verification_tokens" edge IDs in the mutation.
func (m *UserMutation) EmailVerificationTokensIDs() (ids []int) {
	for id := range m.email_verification_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetEmailVerificationTokens resets all changes to the "email_verification_tokens" edge.
func (m *UserMutation) ResetEmailVerificationTokens() {
	m.email_verification_tokens = nil
	m.clearedemail_verification_tokens = false
	m.removedemail_verification_tokens = nil
}

// AddPasswordResetTokenIDs adds the "password_reset_tokens" edge to the PasswordResetToken entity by ids.
func (m *UserMutation) AddPasswordResetTokenIDs(ids ...int) {
	if m.password_reset_tokens == nil {
		m.password_reset_tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.password_reset_tokens[ids[i]] = struct{}{}
	}
}

// ClearPasswordResetTokens clears the "password_reset_tokens" edge to the PasswordResetToken entity.
func (m *UserMutation) ClearPasswordResetTokens() {
	m.clearedpassword_reset_tokens = true
}

// PasswordResetTokensCleared reports if the "password_reset_tokens" edge to the PasswordResetToken entity was cleared.
func (m *UserMutation) PasswordResetTokensCleared() bool {
	return m.clearedpassword_reset_tokens
}

// RemovePasswordResetTokenIDs removes the "password_reset_tokens" edge to the PasswordResetToken entity by IDs.
func (m *UserMutation) RemovePasswordResetTokenIDs(ids ...int) {
	if m.removedpassword_reset_tokens == nil {
		m.removedpassword_reset_tokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.password_reset_tokens, ids[i])
		m.removedpassword_reset_tokens[ids[i]] = struct{}{}
	}
}

// RemovedPasswordResetTokens returns the removed IDs of the "password_reset_tokens" edge to the PasswordResetToken entity.
func (m *UserMutation) RemovedPasswordResetTokensIDs() (ids []int) {
	for id := range m.removedpassword_reset_tokens {
		ids = append(ids, id)
	}
	return
}

// PasswordResetTokensIDs returns the "password_reset_tokens" edge IDs in the mutation.
func (m *UserMutation) PasswordResetTokensIDs() (ids []int) {
	for id := range m.password_reset_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetPasswordResetTokens resets all changes to the "password_reset_tokens" edge.
func (m *UserMutation) ResetPasswordResetTokens() {
	m.password_reset_tokens = nil
	m.clearedpassword_reset_tokens = false
	m.removedpassword_reset_tokens = nil
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by ids.
func (m *UserMutation) AddCredentialIDs(ids ...int) {
	if m.credentials == nil {
		m.credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credential entity.
func (m *UserMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credential entity was cleared.
func (m *UserMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credential entity by IDs.
func (m *UserMutation) RemoveCredentialIDs(ids ...int) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credential entity.
func (m *UserMutation) RemovedCredentialsIDs() (ids []int) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *UserMutation) CredentialsIDs() (ids []int) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *UserMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// AddTotpPendingTokenIDs adds the "totp_pending_tokens" edge to the TOTPPendingToken entity by ids.
func (m *UserMutation) AddTotpPendingTokenIDs(ids ...int) {
	if m.totp_pending_tokens == nil {
		m.totp_pending_tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.totp_pending_tokens[ids[i]] = struct{}{}
	}
}

// ClearTotpPendingTokens clears the "totp_pending_tokens" edge to the TOTPPendingToken entity.
func (m *UserMutation) ClearTotpPendingTokens() {
	m.clearedtotp_pending_tokens = true
}

// TotpPendingTokensCleared reports if the "totp_pending_tokens" edge to the TOTPPendingToken entity was cleared.
func (m *UserMutation) TotpPendingTokensCleared() bool {
	return m.clearedtotp_pending_tokens
}

// RemoveTotpPendingTokenIDs removes the "totp_pending_tokens" edge to the TOTPPendingToken entity by IDs.
func (m *UserMutation) RemoveTotpPendingTokenIDs(ids ...int) {
	if m.removedtotp_pending_tokens == nil {
		m.removedtotp_pending_tokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.totp_pending_tokens, ids[i])
		m.removedtotp_pending_tokens[ids[i]] = struct{}{}
	}
}

// RemovedTotpPendingTokens returns the removed IDs of the "totp_pending_tokens" edge to the TOTPPendingToken entity.
func (m *UserMutation) RemovedTotpPendingTokensIDs() (ids []int) {
	for id := range m.removedtotp_pending_tokens {
		ids = append(ids, id)
	}
	return
}

// TotpPendingTokensIDs returns the "totp_pending_tokens" edge IDs in the mutation.
func (m *UserMutation) TotpPendingTokensIDs() (ids []int) {
	for id := range m.totp_pending_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTotpPendingTokens resets all changes to the "totp_pending_tokens" edge.
func (m *UserMutation) ResetTotpPendingTokens() {
	m.totp_pending_tokens = nil
	m.clearedtotp_pending_tokens = false
	m.removedtotp_pending_tokens = nil
}

// AddSecurityEventIDs adds the "security_events" edge to the SecurityEvent entity by ids.
func (m *UserMutation) AddSecurityEventIDs(ids ...int) {
	if m.security_events == nil {
		m.security_events = make(map[int]struct{})
	}
	for i := range ids {
		m.security_events[ids[i]] = struct{}{}
	}
}

// ClearSecurityEvents clears the "security_events" edge to the SecurityEvent entity.
func (m *UserMutation) ClearSecurityEvents() {
	m.clearedsecurity_events = true
}

// SecurityEventsCleared reports if the "security_events" edge to the SecurityEvent entity was cleared.
func (m *UserMutation) SecurityEventsCleared() bool {
	return m.clearedsecurity_events
}

// RemoveSecurityEventIDs removes the "security_events" edge to the SecurityEvent entity by IDs.
func (m *UserMutation) RemoveSecurityEventIDs(ids ...int) {
	if m.removedsecurity_events == nil {
		m.removedsecurity_events = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.security_events, ids[i])
		m.removedsecurity_events[ids[i]] = struct{}{}
	}
}

// RemovedSecurityEvents returns the removed IDs of the "security_events" edge to the SecurityEvent entity.
func (m *UserMutation) RemovedSecurityEventsIDs() (ids []int) {
	for id := range m.removedsecurity_events {
		ids = append(ids, id)
	}
	return
}

// SecurityEventsIDs returns the "security_events" edge IDs in the mutation.
func (m *UserMutation) SecurityEventsIDs() (ids []int) {
	for id := range m.security_events {
		ids = append(ids, id)
	}
	return
}

// ResetSecurityEvents resets all changes to the "security_events" edge.
func (m *UserMutation) ResetSecurityEvents() {
	m.security_events = nil
	m.clearedsecurity_events = false
	m.removedsecurity_events = nil
}

// AddDeviceFingerprintIDs adds the "device_fingerprints" edge to the DeviceFingerprint entity by ids.
func (m *UserMutation) AddDeviceFingerprintIDs(ids ...int) {
	if m.device_fingerprints == nil {
		m.device_fingerprints = make(map[int]struct{})
	}
	for i := range ids {
		m.device_fingerprints[ids[i]] = struct{}{}
	}
}

// ClearDeviceFingerprints clears the "device_fingerprints" edge to the DeviceFingerprint entity.
func (m *UserMutation) ClearDeviceFingerprints() {
	m.cleareddevice_fingerprints = true
}

// DeviceFingerprintsCleared reports if the "device_fingerprints" edge to the DeviceFingerprint entity was cleared.
func (m *UserMutation) DeviceFingerprintsCleared() bool {
	return m.cleareddevice_fingerprints
}

// RemoveDeviceFingerprintIDs removes the "device_fingerprints" edge to the DeviceFingerprint entity by IDs.
func (m *UserMutation) RemoveDeviceFingerprintIDs(ids ...int) {
	if m.removeddevice_fingerprints == nil {
		m.removeddevice_fingerprints = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_fingerprints, ids[i])
		m.removeddevice_fingerprints[ids[i]] = struct{}{}
	}
}

// RemovedDeviceFingerprints returns the removed IDs of the "device_fingerprints" edge to the DeviceFingerprint entity.
func (m *UserMutation) RemovedDeviceFingerprintsIDs() (ids []int) {
	for id := range m.removeddevice_fingerprints {
		ids = append(ids, id)
	}
	return
}

// DeviceFingerprintsIDs returns the "device_fingerprints" edge IDs in the mutation.
func (m *UserMutation) DeviceFingerprintsIDs() (ids []int) {
	for id := range m.device_fingerprints {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceFingerprints resets all changes to the "device_fingerprints" edge.
func (m *UserMutation) ResetDeviceFingerprints() {
	m.device_fingerprints = nil
	m.cleareddevice_fingerprints = false
	m.removeddevice_fingerprints = nil
}

// AddDeviceUserMappingIDs adds the "device_user_mappings" edge to the DeviceUserMapping entity by ids.
func (m *UserMutation) AddDeviceUserMappingIDs(ids ...int) {
	if m.device_user_mappings == nil {
		m.device_user_mappings = make(map[int]struct{})
	}
	for i := range ids {
		m.device_user_mappings[ids[i]] = struct{}{}
	}
}

// ClearDeviceUserMappings clears the "device_user_mappings" edge to the DeviceUserMapping entity.
func (m *UserMutation) ClearDeviceUserMappings() {
	m.cleareddevice_user_mappings = true
}

// DeviceUserMappingsCleared reports if the "device_user_mappings" edge to the DeviceUserMapping entity was cleared.
func (m *UserMutation) DeviceUserMappingsCleared() bool {
	return m.cleareddevice_user_mappings
}

// RemoveDeviceUserMappingIDs removes the "device_user_mappings" edge to the DeviceUserMapping entity by IDs.
func (m *UserMutation) RemoveDeviceUserMappingIDs(ids ...int) {
	if m.removeddevice_user_mappings == nil {
		m.removeddevice_user_mappings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_user_mappings, ids[i])
		m.removeddevice_user_mappings[ids[i]] = struct{}{}
	}
}

// RemovedDeviceUserMappings returns the removed IDs of the "device_user_mappings" edge to the DeviceUserMapping entity.
func (m *UserMutation) RemovedDeviceUserMappingsIDs() (ids []int) {
	for id := range m.removeddevice_user_mappings {
		ids = append(ids, id)
	}
	return
}

// DeviceUserMappingsIDs returns the "device_user_mappings" edge IDs in the mutation.
func (m *UserMutation) DeviceUserMappingsIDs() (ids []int) {
	for id := range m.device_user_mappings {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceUserMappings resets all changes to the "device_user_mappings" edge.
func (m *UserMutation) ResetDeviceUserMappings() {
	m.device_user_mappings = nil
	m.cleareddevice_user_mappings = false
	m.removeddevice_user_mappings = nil
}

// AddSudoSessionIDs adds the "sudo_sessions" edge to the SudoSession entity by ids.
func (m *UserMutation) AddSudoSessionIDs(ids ...int) {
	if m.sudo_sessions == nil {
		m.sudo_sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sudo_sessions[ids[i]] = struct{}{}
	}
}

// ClearSudoSessions clears the "sudo_sessions" edge to the SudoSession entity.
func (m *UserMutation) ClearSudoSessions() {
	m.clearedsudo_sessions = true
}

// SudoSessionsCleared reports if the "sudo_sessions" edge to the SudoSession entity was cleared.
func (m *UserMutation) SudoSessionsCleared() bool {
	return m.clearedsudo_sessions
}

// RemoveSudoSessionIDs removes the "sudo_sessions" edge to the SudoSession entity by IDs.
func (m *UserMutation) RemoveSudoSessionIDs(ids ...int) {
	if m.removedsudo_sessions == nil {
		m.removedsudo_sessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sudo_sessions, ids[i])
		m.removedsudo_sessions[ids[i]] = struct{}{}
	}
}

// RemovedSudoSessions returns the removed IDs of the "sudo_sessions" edge to the SudoSession entity.
func (m *UserMutation) RemovedSudoSessionsIDs() (ids []int) {
	for id := range m.removedsudo_sessions {
		ids = append(ids, id)
	}
	return
}

// SudoSessionsIDs returns the "sudo_sessions" edge IDs in the mutation.
func (m *UserMutation) SudoSessionsIDs() (ids []int) {
	for id := range m.sudo_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSudoSessions resets all changes to the "sudo_sessions" edge.
func (m *UserMutation) ResetSudoSessions() {
	m.sudo_sessions = nil
	m.clearedsudo_sessions = false
	m.removedsudo_sessions = nil
}

// AddGivenCredentialIDs adds the "given_credentials" edge to the ThreadCredential entity by ids.
func (m *UserMutation) AddGivenCredentialIDs(ids ...int) {
	if m.given_credentials == nil {
		m.given_credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.given_credentials[ids[i]] = struct{}{}
	}
}

// ClearGivenCredentials clears the "given_credentials" edge to the ThreadCredential entity.
func (m *UserMutation) ClearGivenCredentials() {
	m.clearedgiven_credentials = true
}

// GivenCredentialsCleared reports if the "given_credentials" edge to the ThreadCredential entity was cleared.
func (m *UserMutation) GivenCredentialsCleared() bool {
	return m.clearedgiven_credentials
}

// RemoveGivenCredentialIDs removes the "given_credentials" edge to the ThreadCredential entity by IDs.
func (m *UserMutation) RemoveGivenCredentialIDs(ids ...int) {
	if m.removedgiven_credentials == nil {
		m.removedgiven_credentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.given_credentials, ids[i])
		m.removedgiven_credentials[ids[i]] = struct{}{}
	}
}

// RemovedGivenCredentials returns the removed IDs of the "given_credentials" edge to the ThreadCredential entity.
func (m *UserMutation) RemovedGivenCredentialsIDs() (ids []int) {
	for id := range m.removedgiven_credentials {
		ids = append(ids, id)
	}
	return
}

// GivenCredentialsIDs returns the "given_credentials" edge IDs in the mutation.
func (m *UserMutation) GivenCredentialsIDs() (ids []int) {
	for id := range m.given_credentials {
		ids = append(ids, id)
	}
	return
}

// ResetGivenCredentials resets all changes to the "given_credentials" edge.
func (m *UserMutation) ResetGivenCredentials() {
	m.given_credentials = nil
	m.clearedgiven_credentials = false
	m.removedgiven_credentials = nil
}

// ClearPrimaryBadge clears the "primary_badge" edge to the Badge entity.
func (m *UserMutation) ClearPrimaryBadge() {
	m.clearedprimary_badge = true
	m.clearedFields[user.FieldPrimaryBadgeID] = struct{}{}
}

// PrimaryBadgeCleared reports if the "primary_badge" edge to the Badge entity was cleared.
func (m *UserMutation) PrimaryBadgeCleared() bool {
	return m.PrimaryBadgeIDCleared() || m.clearedprimary_badge
}

// PrimaryBadgeIDs returns the "primary_badge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryBadgeID instead. It exists only for internal usage by the builders.
func (m *UserMutation) PrimaryBadgeIDs() (ids []int) {
	if id := m.primary_badge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryBadge resets all changes to the "primary_badge" edge.
func (m *UserMutation) ResetPrimaryBadge() {
	m.primary_badge = nil
	m.clearedprimary_badge = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.full_name != nil {
		fields = append(fields, user.FieldFullName)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.pronouns != nil {
		fields = append(fields, user.FieldPronouns)
	}
	if m.company != nil {
		fields = append(fields, user.FieldCompany)
	}
	if m.telegram != nil {
		fields = append(fields, user.FieldTelegram)
	}
	if m.social_accounts != nil {
		fields = append(fields, user.FieldSocialAccounts)
	}
	if m.primary_badge != nil {
		fields = append(fields, user.FieldPrimaryBadgeID)
	}
	if m.totp_secret != nil {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.totp_enabled != nil {
		fields = append(fields, user.FieldTotpEnabled)
	}
	if m.totp_verified != nil {
		fields = append(fields, user.FieldTotpVerified)
	}
	if m.totp_verified_at != nil {
		fields = append(fields, user.FieldTotpVerifiedAt)
	}
	if m.failed_login_attempts != nil {
		fields = append(fields, user.FieldFailedLoginAttempts)
	}
	if m.last_failed_at != nil {
		fields = append(fields, user.FieldLastFailedAt)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.last_login_ip != nil {
		fields = append(fields, user.FieldLastLoginIP)
	}
	if m.locked_until != nil {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.lock_reason != nil {
		fields = append(fields, user.FieldLockReason)
	}
	if m.guarantee_amount != nil {
		fields = append(fields, user.FieldGuaranteeAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldFullName:
		return m.FullName()
	case user.FieldBio:
		return m.Bio()
	case user.FieldPronouns:
		return m.Pronouns()
	case user.FieldCompany:
		return m.Company()
	case user.FieldTelegram:
		return m.Telegram()
	case user.FieldSocialAccounts:
		return m.SocialAccounts()
	case user.FieldPrimaryBadgeID:
		return m.PrimaryBadgeID()
	case user.FieldTotpSecret:
		return m.TotpSecret()
	case user.FieldTotpEnabled:
		return m.TotpEnabled()
	case user.FieldTotpVerified:
		return m.TotpVerified()
	case user.FieldTotpVerifiedAt:
		return m.TotpVerifiedAt()
	case user.FieldFailedLoginAttempts:
		return m.FailedLoginAttempts()
	case user.FieldLastFailedAt:
		return m.LastFailedAt()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldLastLoginIP:
		return m.LastLoginIP()
	case user.FieldLockedUntil:
		return m.LockedUntil()
	case user.FieldLockReason:
		return m.LockReason()
	case user.FieldGuaranteeAmount:
		return m.GuaranteeAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldFullName:
		return m.OldFullName(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldPronouns:
		return m.OldPronouns(ctx)
	case user.FieldCompany:
		return m.OldCompany(ctx)
	case user.FieldTelegram:
		return m.OldTelegram(ctx)
	case user.FieldSocialAccounts:
		return m.OldSocialAccounts(ctx)
	case user.FieldPrimaryBadgeID:
		return m.OldPrimaryBadgeID(ctx)
	case user.FieldTotpSecret:
		return m.OldTotpSecret(ctx)
	case user.FieldTotpEnabled:
		return m.OldTotpEnabled(ctx)
	case user.FieldTotpVerified:
		return m.OldTotpVerified(ctx)
	case user.FieldTotpVerifiedAt:
		return m.OldTotpVerifiedAt(ctx)
	case user.FieldFailedLoginAttempts:
		return m.OldFailedLoginAttempts(ctx)
	case user.FieldLastFailedAt:
		return m.OldLastFailedAt(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	case user.FieldLockedUntil:
		return m.OldLockedUntil(ctx)
	case user.FieldLockReason:
		return m.OldLockReason(ctx)
	case user.FieldGuaranteeAmount:
		return m.OldGuaranteeAmount(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldPronouns:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPronouns(v)
		return nil
	case user.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case user.FieldTelegram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelegram(v)
		return nil
	case user.FieldSocialAccounts:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialAccounts(v)
		return nil
	case user.FieldPrimaryBadgeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryBadgeID(v)
		return nil
	case user.FieldTotpSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpSecret(v)
		return nil
	case user.FieldTotpEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpEnabled(v)
		return nil
	case user.FieldTotpVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpVerified(v)
		return nil
	case user.FieldTotpVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpVerifiedAt(v)
		return nil
	case user.FieldFailedLoginAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedLoginAttempts(v)
		return nil
	case user.FieldLastFailedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastFailedAt(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	case user.FieldLockedUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedUntil(v)
		return nil
	case user.FieldLockReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockReason(v)
		return nil
	case user.FieldGuaranteeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuaranteeAmount(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addfailed_login_attempts != nil {
		fields = append(fields, user.FieldFailedLoginAttempts)
	}
	if m.addguarantee_amount != nil {
		fields = append(fields, user.FieldGuaranteeAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFailedLoginAttempts:
		return m.AddedFailedLoginAttempts()
	case user.FieldGuaranteeAmount:
		return m.AddedGuaranteeAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldFailedLoginAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailedLoginAttempts(v)
		return nil
	case user.FieldGuaranteeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGuaranteeAmount(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldFullName) {
		fields = append(fields, user.FieldFullName)
	}
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	if m.FieldCleared(user.FieldPronouns) {
		fields = append(fields, user.FieldPronouns)
	}
	if m.FieldCleared(user.FieldCompany) {
		fields = append(fields, user.FieldCompany)
	}
	if m.FieldCleared(user.FieldTelegram) {
		fields = append(fields, user.FieldTelegram)
	}
	if m.FieldCleared(user.FieldSocialAccounts) {
		fields = append(fields, user.FieldSocialAccounts)
	}
	if m.FieldCleared(user.FieldPrimaryBadgeID) {
		fields = append(fields, user.FieldPrimaryBadgeID)
	}
	if m.FieldCleared(user.FieldTotpSecret) {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.FieldCleared(user.FieldTotpVerifiedAt) {
		fields = append(fields, user.FieldTotpVerifiedAt)
	}
	if m.FieldCleared(user.FieldLastFailedAt) {
		fields = append(fields, user.FieldLastFailedAt)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.FieldCleared(user.FieldLastLoginIP) {
		fields = append(fields, user.FieldLastLoginIP)
	}
	if m.FieldCleared(user.FieldLockedUntil) {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.FieldCleared(user.FieldLockReason) {
		fields = append(fields, user.FieldLockReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldFullName:
		m.ClearFullName()
		return nil
	case user.FieldBio:
		m.ClearBio()
		return nil
	case user.FieldPronouns:
		m.ClearPronouns()
		return nil
	case user.FieldCompany:
		m.ClearCompany()
		return nil
	case user.FieldTelegram:
		m.ClearTelegram()
		return nil
	case user.FieldSocialAccounts:
		m.ClearSocialAccounts()
		return nil
	case user.FieldPrimaryBadgeID:
		m.ClearPrimaryBadgeID()
		return nil
	case user.FieldTotpSecret:
		m.ClearTotpSecret()
		return nil
	case user.FieldTotpVerifiedAt:
		m.ClearTotpVerifiedAt()
		return nil
	case user.FieldLastFailedAt:
		m.ClearLastFailedAt()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case user.FieldLastLoginIP:
		m.ClearLastLoginIP()
		return nil
	case user.FieldLockedUntil:
		m.ClearLockedUntil()
		return nil
	case user.FieldLockReason:
		m.ClearLockReason()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldFullName:
		m.ResetFullName()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldPronouns:
		m.ResetPronouns()
		return nil
	case user.FieldCompany:
		m.ResetCompany()
		return nil
	case user.FieldTelegram:
		m.ResetTelegram()
		return nil
	case user.FieldSocialAccounts:
		m.ResetSocialAccounts()
		return nil
	case user.FieldPrimaryBadgeID:
		m.ResetPrimaryBadgeID()
		return nil
	case user.FieldTotpSecret:
		m.ResetTotpSecret()
		return nil
	case user.FieldTotpEnabled:
		m.ResetTotpEnabled()
		return nil
	case user.FieldTotpVerified:
		m.ResetTotpVerified()
		return nil
	case user.FieldTotpVerifiedAt:
		m.ResetTotpVerifiedAt()
		return nil
	case user.FieldFailedLoginAttempts:
		m.ResetFailedLoginAttempts()
		return nil
	case user.FieldLastFailedAt:
		m.ResetLastFailedAt()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	case user.FieldLockedUntil:
		m.ResetLockedUntil()
		return nil
	case user.FieldLockReason:
		m.ResetLockReason()
		return nil
	case user.FieldGuaranteeAmount:
		m.ResetGuaranteeAmount()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.passkeys != nil {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.backup_codes != nil {
		edges = append(edges, user.EdgeBackupCodes)
	}
	if m.threads != nil {
		edges = append(edges, user.EdgeThreads)
	}
	if m.user_badges != nil {
		edges = append(edges, user.EdgeUserBadges)
	}
	if m.session_locks != nil {
		edges = append(edges, user.EdgeSessionLocks)
	}
	if m.email_verification_tokens != nil {
		edges = append(edges, user.EdgeEmailVerificationTokens)
	}
	if m.password_reset_tokens != nil {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.credentials != nil {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.totp_pending_tokens != nil {
		edges = append(edges, user.EdgeTotpPendingTokens)
	}
	if m.security_events != nil {
		edges = append(edges, user.EdgeSecurityEvents)
	}
	if m.device_fingerprints != nil {
		edges = append(edges, user.EdgeDeviceFingerprints)
	}
	if m.device_user_mappings != nil {
		edges = append(edges, user.EdgeDeviceUserMappings)
	}
	if m.sudo_sessions != nil {
		edges = append(edges, user.EdgeSudoSessions)
	}
	if m.given_credentials != nil {
		edges = append(edges, user.EdgeGivenCredentials)
	}
	if m.primary_badge != nil {
		edges = append(edges, user.EdgePrimaryBadge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePasskeys:
		ids := make([]ent.Value, 0, len(m.passkeys))
		for id := range m.passkeys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBackupCodes:
		ids := make([]ent.Value, 0, len(m.backup_codes))
		for id := range m.backup_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserBadges:
		ids := make([]ent.Value, 0, len(m.user_badges))
		for id := range m.user_badges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessionLocks:
		ids := make([]ent.Value, 0, len(m.session_locks))
		for id := range m.session_locks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEmailVerificationTokens:
		ids := make([]ent.Value, 0, len(m.email_verification_tokens))
		for id := range m.email_verification_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetTokens:
		ids := make([]ent.Value, 0, len(m.password_reset_tokens))
		for id := range m.password_reset_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTotpPendingTokens:
		ids := make([]ent.Value, 0, len(m.totp_pending_tokens))
		for id := range m.totp_pending_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSecurityEvents:
		ids := make([]ent.Value, 0, len(m.security_events))
		for id := range m.security_events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceFingerprints:
		ids := make([]ent.Value, 0, len(m.device_fingerprints))
		for id := range m.device_fingerprints {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceUserMappings:
		ids := make([]ent.Value, 0, len(m.device_user_mappings))
		for id := range m.device_user_mappings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSudoSessions:
		ids := make([]ent.Value, 0, len(m.sudo_sessions))
		for id := range m.sudo_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGivenCredentials:
		ids := make([]ent.Value, 0, len(m.given_credentials))
		for id := range m.given_credentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePrimaryBadge:
		if id := m.primary_badge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedpasskeys != nil {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedbackup_codes != nil {
		edges = append(edges, user.EdgeBackupCodes)
	}
	if m.removedthreads != nil {
		edges = append(edges, user.EdgeThreads)
	}
	if m.removeduser_badges != nil {
		edges = append(edges, user.EdgeUserBadges)
	}
	if m.removedsession_locks != nil {
		edges = append(edges, user.EdgeSessionLocks)
	}
	if m.removedemail_verification_tokens != nil {
		edges = append(edges, user.EdgeEmailVerificationTokens)
	}
	if m.removedpassword_reset_tokens != nil {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.removedcredentials != nil {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.removedtotp_pending_tokens != nil {
		edges = append(edges, user.EdgeTotpPendingTokens)
	}
	if m.removedsecurity_events != nil {
		edges = append(edges, user.EdgeSecurityEvents)
	}
	if m.removeddevice_fingerprints != nil {
		edges = append(edges, user.EdgeDeviceFingerprints)
	}
	if m.removeddevice_user_mappings != nil {
		edges = append(edges, user.EdgeDeviceUserMappings)
	}
	if m.removedsudo_sessions != nil {
		edges = append(edges, user.EdgeSudoSessions)
	}
	if m.removedgiven_credentials != nil {
		edges = append(edges, user.EdgeGivenCredentials)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePasskeys:
		ids := make([]ent.Value, 0, len(m.removedpasskeys))
		for id := range m.removedpasskeys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBackupCodes:
		ids := make([]ent.Value, 0, len(m.removedbackup_codes))
		for id := range m.removedbackup_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserBadges:
		ids := make([]ent.Value, 0, len(m.removeduser_badges))
		for id := range m.removeduser_badges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessionLocks:
		ids := make([]ent.Value, 0, len(m.removedsession_locks))
		for id := range m.removedsession_locks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEmailVerificationTokens:
		ids := make([]ent.Value, 0, len(m.removedemail_verification_tokens))
		for id := range m.removedemail_verification_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetTokens:
		ids := make([]ent.Value, 0, len(m.removedpassword_reset_tokens))
		for id := range m.removedpassword_reset_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTotpPendingTokens:
		ids := make([]ent.Value, 0, len(m.removedtotp_pending_tokens))
		for id := range m.removedtotp_pending_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSecurityEvents:
		ids := make([]ent.Value, 0, len(m.removedsecurity_events))
		for id := range m.removedsecurity_events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceFingerprints:
		ids := make([]ent.Value, 0, len(m.removeddevice_fingerprints))
		for id := range m.removeddevice_fingerprints {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceUserMappings:
		ids := make([]ent.Value, 0, len(m.removeddevice_user_mappings))
		for id := range m.removeddevice_user_mappings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSudoSessions:
		ids := make([]ent.Value, 0, len(m.removedsudo_sessions))
		for id := range m.removedsudo_sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGivenCredentials:
		ids := make([]ent.Value, 0, len(m.removedgiven_credentials))
		for id := range m.removedgiven_credentials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedpasskeys {
		edges = append(edges, user.EdgePasskeys)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedbackup_codes {
		edges = append(edges, user.EdgeBackupCodes)
	}
	if m.clearedthreads {
		edges = append(edges, user.EdgeThreads)
	}
	if m.cleareduser_badges {
		edges = append(edges, user.EdgeUserBadges)
	}
	if m.clearedsession_locks {
		edges = append(edges, user.EdgeSessionLocks)
	}
	if m.clearedemail_verification_tokens {
		edges = append(edges, user.EdgeEmailVerificationTokens)
	}
	if m.clearedpassword_reset_tokens {
		edges = append(edges, user.EdgePasswordResetTokens)
	}
	if m.clearedcredentials {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.clearedtotp_pending_tokens {
		edges = append(edges, user.EdgeTotpPendingTokens)
	}
	if m.clearedsecurity_events {
		edges = append(edges, user.EdgeSecurityEvents)
	}
	if m.cleareddevice_fingerprints {
		edges = append(edges, user.EdgeDeviceFingerprints)
	}
	if m.cleareddevice_user_mappings {
		edges = append(edges, user.EdgeDeviceUserMappings)
	}
	if m.clearedsudo_sessions {
		edges = append(edges, user.EdgeSudoSessions)
	}
	if m.clearedgiven_credentials {
		edges = append(edges, user.EdgeGivenCredentials)
	}
	if m.clearedprimary_badge {
		edges = append(edges, user.EdgePrimaryBadge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePasskeys:
		return m.clearedpasskeys
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeBackupCodes:
		return m.clearedbackup_codes
	case user.EdgeThreads:
		return m.clearedthreads
	case user.EdgeUserBadges:
		return m.cleareduser_badges
	case user.EdgeSessionLocks:
		return m.clearedsession_locks
	case user.EdgeEmailVerificationTokens:
		return m.clearedemail_verification_tokens
	case user.EdgePasswordResetTokens:
		return m.clearedpassword_reset_tokens
	case user.EdgeCredentials:
		return m.clearedcredentials
	case user.EdgeTotpPendingTokens:
		return m.clearedtotp_pending_tokens
	case user.EdgeSecurityEvents:
		return m.clearedsecurity_events
	case user.EdgeDeviceFingerprints:
		return m.cleareddevice_fingerprints
	case user.EdgeDeviceUserMappings:
		return m.cleareddevice_user_mappings
	case user.EdgeSudoSessions:
		return m.clearedsudo_sessions
	case user.EdgeGivenCredentials:
		return m.clearedgiven_credentials
	case user.EdgePrimaryBadge:
		return m.clearedprimary_badge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgePrimaryBadge:
		m.ClearPrimaryBadge()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePasskeys:
		m.ResetPasskeys()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeBackupCodes:
		m.ResetBackupCodes()
		return nil
	case user.EdgeThreads:
		m.ResetThreads()
		return nil
	case user.EdgeUserBadges:
		m.ResetUserBadges()
		return nil
	case user.EdgeSessionLocks:
		m.ResetSessionLocks()
		return nil
	case user.EdgeEmailVerificationTokens:
		m.ResetEmailVerificationTokens()
		return nil
	case user.EdgePasswordResetTokens:
		m.ResetPasswordResetTokens()
		return nil
	case user.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case user.EdgeTotpPendingTokens:
		m.ResetTotpPendingTokens()
		return nil
	case user.EdgeSecurityEvents:
		m.ResetSecurityEvents()
		return nil
	case user.EdgeDeviceFingerprints:
		m.ResetDeviceFingerprints()
		return nil
	case user.EdgeDeviceUserMappings:
		m.ResetDeviceUserMappings()
		return nil
	case user.EdgeSudoSessions:
		m.ResetSudoSessions()
		return nil
	case user.EdgeGivenCredentials:
		m.ResetGivenCredentials()
		return nil
	case user.EdgePrimaryBadge:
		m.ResetPrimaryBadge()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserBadgeMutation represents an operation that mutates the UserBadge nodes in the graph.
type UserBadgeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	reason        *string
	granted_at    *time.Time
	revoked_at    *time.Time
	revoke_reason *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	badge         *int
	clearedbadge  bool
	admin         *int
	clearedadmin  bool
	done          bool
	oldValue      func(context.Context) (*UserBadge, error)
	predicates    []predicate.UserBadge
}

var _ ent.Mutation = (*UserBadgeMutation)(nil)

// userbadgeOption allows management of the mutation configuration using functional options.
type userbadgeOption func(*UserBadgeMutation)

// newUserBadgeMutation creates new mutation for the UserBadge entity.
func newUserBadgeMutation(c config, op Op, opts ...userbadgeOption) *UserBadgeMutation {
	m := &UserBadgeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBadge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserBadgeID sets the ID field of the mutation.
func withUserBadgeID(id int) userbadgeOption {
	return func(m *UserBadgeMutation) {
		var (
			err   error
			once  sync.Once
			value *UserBadge
		)
		m.oldValue = func(ctx context.Context) (*UserBadge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserBadge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserBadge sets the old UserBadge of the mutation.
func withUserBadge(node *UserBadge) userbadgeOption {
	return func(m *UserBadgeMutation) {
		m.oldValue = func(context.Context) (*UserBadge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBadgeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBadgeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserBadgeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserBadgeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserBadge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserBadgeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserBadgeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserBadgeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserBadgeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserBadgeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserBadgeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserBadgeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserBadgeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserBadgeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userbadge.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserBadgeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userbadge.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserBadgeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userbadge.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserBadgeMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserBadgeMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserBadgeMutation) ResetUserID() {
	m.user = nil
}

// SetBadgeID sets the "badge_id" field.
func (m *UserBadgeMutation) SetBadgeID(i int) {
	m.badge = &i
}

// BadgeID returns the value of the "badge_id" field in the mutation.
func (m *UserBadgeMutation) BadgeID() (r int, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadgeID returns the old "badge_id" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldBadgeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadgeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadgeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadgeID: %w", err)
	}
	return oldValue.BadgeID, nil
}

// ResetBadgeID resets all changes to the "badge_id" field.
func (m *UserBadgeMutation) ResetBadgeID() {
	m.badge = nil
}

// SetReason sets the "reason" field.
func (m *UserBadgeMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *UserBadgeMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *UserBadgeMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[userbadge.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *UserBadgeMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[userbadge.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *UserBadgeMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, userbadge.FieldReason)
}

// SetGrantedBy sets the "granted_by" field.
func (m *UserBadgeMutation) SetGrantedBy(i int) {
	m.admin = &i
}

// GrantedBy returns the value of the "granted_by" field in the mutation.
func (m *UserBadgeMutation) GrantedBy() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedBy returns the old "granted_by" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldGrantedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedBy: %w", err)
	}
	return oldValue.GrantedBy, nil
}

// ResetGrantedBy resets all changes to the "granted_by" field.
func (m *UserBadgeMutation) ResetGrantedBy() {
	m.admin = nil
}

// SetGrantedAt sets the "granted_at" field.
func (m *UserBadgeMutation) SetGrantedAt(t time.Time) {
	m.granted_at = &t
}

// GrantedAt returns the value of the "granted_at" field in the mutation.
func (m *UserBadgeMutation) GrantedAt() (r time.Time, exists bool) {
	v := m.granted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedAt returns the old "granted_at" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldGrantedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedAt: %w", err)
	}
	return oldValue.GrantedAt, nil
}

// ResetGrantedAt resets all changes to the "granted_at" field.
func (m *UserBadgeMutation) ResetGrantedAt() {
	m.granted_at = nil
}

// SetRevokedAt sets the "revoked_at" field.
func (m *UserBadgeMutation) SetRevokedAt(t time.Time) {
	m.revoked_at = &t
}

// RevokedAt returns the value of the "revoked_at" field in the mutation.
func (m *UserBadgeMutation) RevokedAt() (r time.Time, exists bool) {
	v := m.revoked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokedAt returns the old "revoked_at" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldRevokedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokedAt: %w", err)
	}
	return oldValue.RevokedAt, nil
}

// ClearRevokedAt clears the value of the "revoked_at" field.
func (m *UserBadgeMutation) ClearRevokedAt() {
	m.revoked_at = nil
	m.clearedFields[userbadge.FieldRevokedAt] = struct{}{}
}

// RevokedAtCleared returns if the "revoked_at" field was cleared in this mutation.
func (m *UserBadgeMutation) RevokedAtCleared() bool {
	_, ok := m.clearedFields[userbadge.FieldRevokedAt]
	return ok
}

// ResetRevokedAt resets all changes to the "revoked_at" field.
func (m *UserBadgeMutation) ResetRevokedAt() {
	m.revoked_at = nil
	delete(m.clearedFields, userbadge.FieldRevokedAt)
}

// SetRevokeReason sets the "revoke_reason" field.
func (m *UserBadgeMutation) SetRevokeReason(s string) {
	m.revoke_reason = &s
}

// RevokeReason returns the value of the "revoke_reason" field in the mutation.
func (m *UserBadgeMutation) RevokeReason() (r string, exists bool) {
	v := m.revoke_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRevokeReason returns the old "revoke_reason" field's value of the UserBadge entity.
// If the UserBadge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBadgeMutation) OldRevokeReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevokeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevokeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevokeReason: %w", err)
	}
	return oldValue.RevokeReason, nil
}

// ClearRevokeReason clears the value of the "revoke_reason" field.
func (m *UserBadgeMutation) ClearRevokeReason() {
	m.revoke_reason = nil
	m.clearedFields[userbadge.FieldRevokeReason] = struct{}{}
}

// RevokeReasonCleared returns if the "revoke_reason" field was cleared in this mutation.
func (m *UserBadgeMutation) RevokeReasonCleared() bool {
	_, ok := m.clearedFields[userbadge.FieldRevokeReason]
	return ok
}

// ResetRevokeReason resets all changes to the "revoke_reason" field.
func (m *UserBadgeMutation) ResetRevokeReason() {
	m.revoke_reason = nil
	delete(m.clearedFields, userbadge.FieldRevokeReason)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserBadgeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userbadge.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserBadgeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserBadgeMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserBadgeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearBadge clears the "badge" edge to the Badge entity.
func (m *UserBadgeMutation) ClearBadge() {
	m.clearedbadge = true
	m.clearedFields[userbadge.FieldBadgeID] = struct{}{}
}

// BadgeCleared reports if the "badge" edge to the Badge entity was cleared.
func (m *UserBadgeMutation) BadgeCleared() bool {
	return m.clearedbadge
}

// BadgeIDs returns the "badge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BadgeID instead. It exists only for internal usage by the builders.
func (m *UserBadgeMutation) BadgeIDs() (ids []int) {
	if id := m.badge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBadge resets all changes to the "badge" edge.
func (m *UserBadgeMutation) ResetBadge() {
	m.badge = nil
	m.clearedbadge = false
}

// SetAdminID sets the "admin" edge to the Admin entity by id.
func (m *UserBadgeMutation) SetAdminID(id int) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *UserBadgeMutation) ClearAdmin() {
	m.clearedadmin = true
	m.clearedFields[userbadge.FieldGrantedBy] = struct{}{}
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *UserBadgeMutation) AdminCleared() bool {
	return m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *UserBadgeMutation) AdminID() (id int, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *UserBadgeMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *UserBadgeMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// Where appends a list predicates to the UserBadgeMutation builder.
func (m *UserBadgeMutation) Where(ps ...predicate.UserBadge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBadgeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBadgeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBadge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBadgeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBadgeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBadge).
func (m *UserBadgeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBadgeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, userbadge.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userbadge.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userbadge.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, userbadge.FieldUserID)
	}
	if m.badge != nil {
		fields = append(fields, userbadge.FieldBadgeID)
	}
	if m.reason != nil {
		fields = append(fields, userbadge.FieldReason)
	}
	if m.admin != nil {
		fields = append(fields, userbadge.FieldGrantedBy)
	}
	if m.granted_at != nil {
		fields = append(fields, userbadge.FieldGrantedAt)
	}
	if m.revoked_at != nil {
		fields = append(fields, userbadge.FieldRevokedAt)
	}
	if m.revoke_reason != nil {
		fields = append(fields, userbadge.FieldRevokeReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBadgeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userbadge.FieldCreatedAt:
		return m.CreatedAt()
	case userbadge.FieldUpdatedAt:
		return m.UpdatedAt()
	case userbadge.FieldDeletedAt:
		return m.DeletedAt()
	case userbadge.FieldUserID:
		return m.UserID()
	case userbadge.FieldBadgeID:
		return m.BadgeID()
	case userbadge.FieldReason:
		return m.Reason()
	case userbadge.FieldGrantedBy:
		return m.GrantedBy()
	case userbadge.FieldGrantedAt:
		return m.GrantedAt()
	case userbadge.FieldRevokedAt:
		return m.RevokedAt()
	case userbadge.FieldRevokeReason:
		return m.RevokeReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBadgeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userbadge.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userbadge.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userbadge.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userbadge.FieldUserID:
		return m.OldUserID(ctx)
	case userbadge.FieldBadgeID:
		return m.OldBadgeID(ctx)
	case userbadge.FieldReason:
		return m.OldReason(ctx)
	case userbadge.FieldGrantedBy:
		return m.OldGrantedBy(ctx)
	case userbadge.FieldGrantedAt:
		return m.OldGrantedAt(ctx)
	case userbadge.FieldRevokedAt:
		return m.OldRevokedAt(ctx)
	case userbadge.FieldRevokeReason:
		return m.OldRevokeReason(ctx)
	}
	return nil, fmt.Errorf("unknown UserBadge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBadgeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userbadge.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userbadge.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userbadge.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userbadge.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userbadge.FieldBadgeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadgeID(v)
		return nil
	case userbadge.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case userbadge.FieldGrantedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedBy(v)
		return nil
	case userbadge.FieldGrantedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedAt(v)
		return nil
	case userbadge.FieldRevokedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokedAt(v)
		return nil
	case userbadge.FieldRevokeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevokeReason(v)
		return nil
	}
	return fmt.Errorf("unknown UserBadge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBadgeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBadgeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBadgeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserBadge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBadgeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userbadge.FieldDeletedAt) {
		fields = append(fields, userbadge.FieldDeletedAt)
	}
	if m.FieldCleared(userbadge.FieldReason) {
		fields = append(fields, userbadge.FieldReason)
	}
	if m.FieldCleared(userbadge.FieldRevokedAt) {
		fields = append(fields, userbadge.FieldRevokedAt)
	}
	if m.FieldCleared(userbadge.FieldRevokeReason) {
		fields = append(fields, userbadge.FieldRevokeReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBadgeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBadgeMutation) ClearField(name string) error {
	switch name {
	case userbadge.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userbadge.FieldReason:
		m.ClearReason()
		return nil
	case userbadge.FieldRevokedAt:
		m.ClearRevokedAt()
		return nil
	case userbadge.FieldRevokeReason:
		m.ClearRevokeReason()
		return nil
	}
	return fmt.Errorf("unknown UserBadge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBadgeMutation) ResetField(name string) error {
	switch name {
	case userbadge.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userbadge.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userbadge.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userbadge.FieldUserID:
		m.ResetUserID()
		return nil
	case userbadge.FieldBadgeID:
		m.ResetBadgeID()
		return nil
	case userbadge.FieldReason:
		m.ResetReason()
		return nil
	case userbadge.FieldGrantedBy:
		m.ResetGrantedBy()
		return nil
	case userbadge.FieldGrantedAt:
		m.ResetGrantedAt()
		return nil
	case userbadge.FieldRevokedAt:
		m.ResetRevokedAt()
		return nil
	case userbadge.FieldRevokeReason:
		m.ResetRevokeReason()
		return nil
	}
	return fmt.Errorf("unknown UserBadge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBadgeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, userbadge.EdgeUser)
	}
	if m.badge != nil {
		edges = append(edges, userbadge.EdgeBadge)
	}
	if m.admin != nil {
		edges = append(edges, userbadge.EdgeAdmin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBadgeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userbadge.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userbadge.EdgeBadge:
		if id := m.badge; id != nil {
			return []ent.Value{*id}
		}
	case userbadge.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBadgeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBadgeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBadgeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, userbadge.EdgeUser)
	}
	if m.clearedbadge {
		edges = append(edges, userbadge.EdgeBadge)
	}
	if m.clearedadmin {
		edges = append(edges, userbadge.EdgeAdmin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBadgeMutation) EdgeCleared(name string) bool {
	switch name {
	case userbadge.EdgeUser:
		return m.cleareduser
	case userbadge.EdgeBadge:
		return m.clearedbadge
	case userbadge.EdgeAdmin:
		return m.clearedadmin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBadgeMutation) ClearEdge(name string) error {
	switch name {
	case userbadge.EdgeUser:
		m.ClearUser()
		return nil
	case userbadge.EdgeBadge:
		m.ClearBadge()
		return nil
	case userbadge.EdgeAdmin:
		m.ClearAdmin()
		return nil
	}
	return fmt.Errorf("unknown UserBadge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBadgeMutation) ResetEdge(name string) error {
	switch name {
	case userbadge.EdgeUser:
		m.ResetUser()
		return nil
	case userbadge.EdgeBadge:
		m.ResetBadge()
		return nil
	case userbadge.EdgeAdmin:
		m.ResetAdmin()
		return nil
	}
	return fmt.Errorf("unknown UserBadge edge %s", name)
}
